const t=JSON.parse('{"key":"v-f8fed74e","path":"/java/io/io-design-patterns.html","title":"Java IO设计模式总结","lang":"zh-CN","frontmatter":{"title":"Java IO设计模式总结","category":["Java"],"tag":["Java IO","Java基础"],"description":"这篇文章我们简单来看看我们从 IO 中能够学习到哪些设计模式的应用。 装饰器模式 装饰器（Decorator）模式 可以在不改变原有对象的情况下拓展其功能。 装饰器模式通过组合替代继承来扩展原始类的功能，在一些继承关系比较复杂的场景（IO 这一场景各种类的继承关系就比较复杂）更加实用。 对于字节流来说， FilterInputStream （对应输入流）和FilterOutputStream（对应输出流）是装饰器模式的核心，分别用于增强 InputStream 和OutputStream子类对象的功能。","head":[["meta",{"property":"og:url","content":"https://javaguide.cn/java/io/io-design-patterns.html"}],["meta",{"property":"og:site_name","content":"JavaGuide(Java面试+学习指南)"}],["meta",{"property":"og:title","content":"Java IO设计模式总结"}],["meta",{"property":"og:description","content":"这篇文章我们简单来看看我们从 IO 中能够学习到哪些设计模式的应用。 装饰器模式 装饰器（Decorator）模式 可以在不改变原有对象的情况下拓展其功能。 装饰器模式通过组合替代继承来扩展原始类的功能，在一些继承关系比较复杂的场景（IO 这一场景各种类的继承关系就比较复杂）更加实用。 对于字节流来说， FilterInputStream （对应输入流）和FilterOutputStream（对应输出流）是装饰器模式的核心，分别用于增强 InputStream 和OutputStream子类对象的功能。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:tag","content":"Java IO"}],["meta",{"property":"article:tag","content":"Java基础"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java IO设计模式总结\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[]}"]]},"headers":[{"level":2,"title":"装饰器模式","slug":"装饰器模式","link":"#装饰器模式","children":[]},{"level":2,"title":"适配器模式","slug":"适配器模式","link":"#适配器模式","children":[]},{"level":2,"title":"工厂模式","slug":"工厂模式","link":"#工厂模式","children":[]},{"level":2,"title":"观察者模式","slug":"观察者模式","link":"#观察者模式","children":[]},{"level":2,"title":"参考","slug":"参考","link":"#参考","children":[]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"readingTime":{"minutes":7.77,"words":2332},"filePathRelative":"java/io/io-design-patterns.md","excerpt":"<p>这篇文章我们简单来看看我们从 IO 中能够学习到哪些设计模式的应用。</p>\\n<h2> 装饰器模式</h2>\\n<p><strong>装饰器（Decorator）模式</strong> 可以在不改变原有对象的情况下拓展其功能。</p>\\n<p>装饰器模式通过组合替代继承来扩展原始类的功能，在一些继承关系比较复杂的场景（IO 这一场景各种类的继承关系就比较复杂）更加实用。</p>\\n<p>对于字节流来说， <code>FilterInputStream</code> （对应输入流）和<code>FilterOutputStream</code>（对应输出流）是装饰器模式的核心，分别用于增强 <code>InputStream</code> 和<code>OutputStream</code>子类对象的功能。</p>","copyright":{},"autoDesc":true}');export{t as data};
