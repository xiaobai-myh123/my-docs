<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xsl" href="https://javaguide.cn/rss.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://javaguide.cn/rss.xml" rel="self" type="application/rss+xml"/>
    <title>JavaGuide(Java面试+学习指南)</title>
    <link>https://javaguide.cn/</link>
    <description>「Java学习指北+Java面试指南」一份涵盖大部分 Java 程序员所需要掌握的核心知识。准备 Java 面试，复习 Java 知识点，首选 JavaGuide！  </description>
    <language>zh-CN</language>
    <pubDate>Wed, 29 Mar 2023 11:56:18 GMT</pubDate>
    <lastBuildDate>Wed, 29 Mar 2023 11:56:18 GMT</lastBuildDate>
    <generator>vuepress-plugin-feed2</generator>
    <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
    <copyright>Copyright by Guide</copyright>
    <image>
      <title>JavaGuide(Java面试+学习指南)</title>
      <url>https://javaguide.cn/logo.png</url>
      <link>https://javaguide.cn/</link>
    </image>
    <category>软件安装</category>
    <category>走近作者</category>
    <category>计算机书籍</category>
    <category>数据库</category>
    <category>分布式</category>
    <category>高性能</category>
    <category>高可用</category>
    <category>知识星球</category>
    <category>面试准备</category>
    <category>走近项目</category>
    <category>开源项目</category>
    <category>系统设计</category>
    <category>Java面试指北</category>
    <category>计算机基础</category>
    <item>
      <title>docker 安装</title>
      <link>https://javaguide.cn/my-blog/software-installation/docker.html</link>
      <guid>https://javaguide.cn/my-blog/software-installation/docker.html</guid>
      <source url="https://javaguide.cn/rss.xml">docker 安装</source>
      <description>安装基础软件 👉 日常博客文章，编写docker 若依网址来的 👉 作者：小白 原文：忘记了！！！ 应用容器部署 1. 基本介绍基本介绍 虚拟机问题 虚拟机是带环境安装的一种解决方案。它可以在一种操作系统里面运行另一种操作系统，比如在Windows系统里面运行Linux系统。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。</description>
      <category>软件安装</category>
      <pubDate>Wed, 29 Mar 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<div class="hint-container tip">
<p class="hint-container-title">安装基础软件</p>
<p>👉 日常博客文章，编写docker 若依网址来的</p>
<p>👉 作者：小白</p>
</div>
<blockquote>
<p>原文：忘记了！！！</p>
</blockquote>
<h1> 应用容器部署</h1>
<h2> 1. 基本介绍基本介绍</h2>
<ul>
<li>虚拟机问题</li>
</ul>
<p>虚拟机是带环境安装的一种解决方案。它可以在一种操作系统里面运行另一种操作系统，比如在<code>Windows</code>系统里面运行<code>Linux</code>系统。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。</p>
<p>虽然用户可以通过虚拟机还原软件的原始环境。但是，这个方案有几个缺点。</p>
<p>（1）资源占用多</p>
<p>虚拟机会独占一部分内存和硬盘空间。它运行的时候，其他程序就不能使用这些资源了。哪怕虚拟机里面的应用程序，真正使用的内存只有 1MB，虚拟机依然需要几百 MB 的内存才能运行。</p>
<p>（2）冗余步骤多</p>
<p>虚拟机是完整的操作系统，一些系统级别的操作步骤，往往无法跳过，比如用户登录。</p>
<p>（3）启动慢</p>
<p>启动操作系统需要多久，启动虚拟机就需要多久。可能要等几分钟，应用程序才能真正运行。</p>
<ul>
<li>什么是应用容器</li>
</ul>
<p>我们可以把它看成虚拟机，能在一台服务器上隔离出若干个互不干扰的环境。把自己的应用放入容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。它具有启动快、资源占用少、体积小、易操作等等。相比虚拟机有很多优势。</p>
<ul>
<li>为什么要使用应用容器</li>
</ul>
<p>因为软件更新发布及部署低效，过程繁琐且需要人工介入。环境一致性难以保证，不同环境之间迁移成本太高。有了应用容器部署可以很大程度解决上面的问题。</p>
<ul>
<li>Docker 应用容器部署</li>
</ul>
<p><code>Docker</code>是一个开源的应用容器引擎，目前有三大类。</p>
<p>（1）提供一次性的环境。比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。</p>
<p>（2）提供弹性的云服务。因为<code>Docker</code>容器可以随开随关，很适合动态扩容和缩容。</p>
<p>（3）组建微服务架构。通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。</p>
<h2> 2.下载方式</h2>
<p><code>Docker</code>是一个开源的商业产品，有两个版本：社区版（Community Edition，缩写为 CE）和企业版（Enterprise Edition，缩写为 EE）。企业版包含了一些收费服务，个人开发者一般用不到。下面的介绍都针对社区版。</p>
<ul>
<li>Docker 环境安装</li>
</ul>
<p>安装详细说明参考官方文档：<code>https://docs.docker.com/get-docker</code>，以<code>CentOS</code>为例。</p>
<ul>
<li>安装所需的软件包</li>
</ul>
<p>安装<code>yum-utils</code>包</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>设置存储库</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>安装<code>Docker</code>引擎</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>安装完成后，运行下面的命令，验证是否安装成功。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 3.配置镜像</h2>
<p><code>Docker</code>默认拉取镜像是从这里拉取(<code>https://hub.docker.com</code>)，国外地址拉取的速度比较慢。我们也可以配置国内镜像源。</p>
<ul>
<li>阿里云镜像加速器</li>
</ul>
<p>访问地址：<code>https://help.aliyun.com/document_detail/60750.html</code>，进入容器镜像服务控制台创建加速器。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-25befe4051199696c80debe588ccbf4c588.png" alt="alibaba-docker"></p>
<p>使用配置文件<code>/etc/docker/daemon.json</code>（没有时新建该文件）。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>重启<code>Docker Daemon</code>即可。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> 4.架构概念</h2>
<p>通过下图可以得知，<code>Docker</code>在运行时分为<code>Docker引擎（服务端守护进程）</code>和<code>客户端工具</code>，我们日常使用各种<code>docker命令</code>，其实就是在使用<code>客户端工具</code>与<code>Docker</code>引擎进行交互。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-216ccca6be8f28927f914b667ad9b2dad74.JPEG" alt="docker"></p>
<h3> 1.Client 客户端</h3>
<p><code>Docker</code>是一个客户端-服务器（C/S）架构程序。<code>Docker</code>客户端只需要向<code>Docker</code>服务器或者守护进程发出请求，服务器或者守护进程将完成所有工作并返回结果。<code>Docker</code>提供了一个命令行工具<code>Docker</code>以及一整套<code>RESTful API</code>。你可以在同一台宿主机上运行<code>Docker</code>守护进程和客户端，也可以从本地的<code>Docker</code>客户端连接到运行在另一台宿主机上的远程<code>Docker</code>守护进程。</p>
<h3> 2.Host 主机(Docker 引擎)</h3>
<p>一个物理或者虚拟的机器用于执行<code>Docker</code>守护进程和容器。</p>
<h3> 3.Image 镜像</h3>
<p>什么是<code>Docker</code>镜像？简单的理解，<code>Docker</code>镜像就是一个<code>Linux</code>的<code>文件系统（Root FileSystem）</code>，这个文件系统里面包含可以运行在<code>Linux</code>内核的程序以及相应的数据。</p>
<p>通过镜像启动一个容器，一个镜像就是一个可执行的包，其中包括运行应用程序所需要的所有内容：包含代码，运行时间，库，环境变量和配置文件等。</p>
<p>Docker 把 App 文件打包成为一个镜像，并且采用类似多次快照的存储技术，可以实现：</p>
<ul>
<li>多个<code>App</code>可以共用相同的底层镜像（初始的操作系统镜像）；</li>
<li><code>App</code>运行时的<code>IO</code>操作和镜像文件隔离；</li>
<li>通过挂载包含不同配置/数据文件的目录或者卷（Volume），单个<code>App</code>镜像可以用来运行无数个不同业务的容器。</li>
</ul>
<h3> 4.Container 容器</h3>
<p>镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p>
<table>
<thead>
<tr>
<th>Docker</th>
<th style="text-align:right">面向对象</th>
</tr>
</thead>
<tbody>
<tr>
<td>镜像</td>
<td style="text-align:right">类</td>
</tr>
<tr>
<td>容器</td>
<td style="text-align:right">对象</td>
</tr>
</tbody>
</table>
<h3> 5.镜像分层</h3>
<p>Docker 支持通过扩展现有镜像，创建新的镜像。实际上，<code>Docker Hub</code>中<code>99%</code>的镜像都是通过在<code>base</code>镜像中安装和配置需要的软件构建出来的。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-ecb10fa765db240f013173a51f23a56a488.png" alt="docker"></p>
<p>从上图可以看到，新镜像是从<code>base</code>镜像一层一层叠加生成的。每安装一个软件，就在现有镜像的基础上增加一层。</p>
<p>镜像分层最大的一个好处就是共享资源。比如说有多个镜像都从相同的<code>base</code>镜像构建而来，那么<code>Docker Host</code>只需在磁盘上保存一份<code>base</code>镜像；同时内存中也只需加载一份<code>base</code>镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。</p>
<p>如果多个容器共享一份基础镜像，当某个容器修改了基础镜像的内容，比如<code>/etc</code>下的文件，这时其他容器的<code>/etc</code>是不会被修改的，修改只会被限制在单个容器内。这就是容器<code>Copy-on-Write</code>特性。</p>
<h3> 6.Volume 数据卷</h3>
<p>实际上我们的容器就好像是一个简易版的操作系统，只不过系统中只安装了我们的程序运行所需要的环境，前边说到我们的容器是可以删除的，那如果删除了，容器中的程序产生的需要持久化的数据怎么办呢？容器运行的时候我们可以进容器去查看，容器一旦删除就什么都没有了。</p>
<p>所以数据卷就是来解决这个问题的，是用来将数据持久化到我们宿主机上，与容器间实现数据共享，简单的说就是将宿主机的目录映射到容器中的目录，应用程序在容器中的目录读写数据会同步到宿主机上，这样容器产生的数据就可以持久化了，比如我们的数据库容器，就可以把数据存储到我们宿主机上的真实磁盘中。</p>
<h3> Registry 注册中心</h3>
<p><code>Docker</code>用<code>Registry</code>来保存用户构建的镜像。<code>Registry</code>分为公共和私有两种。<code>Docker</code>公司运营公共的<code>Registry</code>叫做<code>Docker Hub</code>。用户可以在<code>Docker Hub</code>注册账号，分享并保存自己的镜像。</p>
<p><code>Docker</code>公司提供了公共的镜像仓库<code>https://hub.docker.com</code>（Docker 称之为 Repository）提供了庞大的镜像集合供使用。</p>
<p>一个<code>Docker Registry</code>中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。</p>
<p>通常，一个仓库会包含同一个软件不同版本的镜像，而标签对应该软件的各个版本。我们可以通过<code>&lt;仓库名&gt;:&lt;标签&gt;</code>的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以<code>latest</code>作为默认标签。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-e31f10f60dc8a570c46de029c49d9826863.png" alt="alibaba-docker"></p>
<h2> 5.镜像命令</h2>
<p>官方文档：<code>https://docs.docker.com/reference</code></p>
<h3> 1.查看镜像</h3>
<p>执行命令：<code>docker images</code></p>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:right">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>REPOSITORY</td>
<td style="text-align:right">镜像在仓库中的名称</td>
</tr>
<tr>
<td>TAG</td>
<td style="text-align:right">镜像标签</td>
</tr>
<tr>
<td>IMAGE ID</td>
<td style="text-align:right">镜像 ID</td>
</tr>
<tr>
<td>CREATED</td>
<td style="text-align:right">镜像的创建日期</td>
</tr>
<tr>
<td>SIZE</td>
<td style="text-align:right">镜像大小</td>
</tr>
</tbody>
</table>
<p>这些镜像都是存储在<code>Docker</code>宿主机的<code>/var/lib/docker</code>目录下。</p>
<h3> 2.搜索镜像</h3>
<p>如果你需要从网络中查找需要的镜像，可以通过以下命令搜索。</p>
<p>执行命令：<code>docker search 镜像名称</code></p>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:right">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>NAME</td>
<td style="text-align:right">镜像名称</td>
</tr>
<tr>
<td>DESCRIPTION</td>
<td style="text-align:right">镜像描述</td>
</tr>
<tr>
<td>STARS</td>
<td style="text-align:right">用户评价</td>
</tr>
<tr>
<td>OFFICIAL</td>
<td style="text-align:right">是否为官方构建</td>
</tr>
<tr>
<td>AUTOMATED</td>
<td style="text-align:right">Docker Hub 自动构建</td>
</tr>
</tbody>
</table>
<h3> 3.拉取镜像</h3>
<p>拉取镜像就是从中央仓库下载镜像到本地。</p>
<p>执行命令：<code>docker pull 镜像名称</code></p>
<p>如果不声明<code>tag</code>镜像标签信息则默认拉取<code>latest</code>版本。</p>
<h3> 4.删除镜像</h3>
<p>按镜像<code>ID</code>删除单个镜像。</p>
<p>执行命令：<code>docker rmi 镜像ID</code></p>
<p>按镜像<code>ID</code>删除多个镜像。</p>
<p>执行命令：<code>docker rmi 镜像ID 镜像ID 镜像ID</code></p>
<p><code>docker images -q</code>可以查询到所有镜像的<code>ID</code>，通过组合命令可以实现删除所有镜像的操作。</p>
<p>执行命令：<code>docker rmi docker images -q</code></p>
<div class="hint-container tip">
<p class="hint-container-title">提示</p>
<p>提示</p>
<p>注意：如果通过某个镜像创建了容器，则该镜像无法删除。
解决办法：先删除镜像中的容器，再删除该镜像。</p>
</div>
<h2> 6.容器命令</h2>
<h3> 1.查看容器</h3>
<p>查看正在运行的容器。</p>
<p>执行命令：<code>docker ps</code></p>
<table>
<thead>
<tr>
<th>属性</th>
<th style="text-align:right">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>CONTAINER ID</td>
<td style="text-align:right">容器 ID</td>
</tr>
<tr>
<td>IMAGE</td>
<td style="text-align:right">所属镜像</td>
</tr>
<tr>
<td>COMMAND</td>
<td style="text-align:right">启动容器时运行的命令</td>
</tr>
<tr>
<td>CREATED</td>
<td style="text-align:right">创建时间</td>
</tr>
<tr>
<td>STATUS</td>
<td style="text-align:right">容器状态</td>
</tr>
<tr>
<td>PORTS</td>
<td style="text-align:right">端口</td>
</tr>
<tr>
<td>NAMES</td>
<td style="text-align:right">容器名称</td>
</tr>
</tbody>
</table>
<p>查看停止的容器。</p>
<p>执行命令：<code>docker ps -f status=exited</code></p>
<p>查看所有容器（包括运行和停止）。</p>
<p>执行命令：<code>docker ps -a</code></p>
<p>查看最后一次运行的容器。</p>
<p>执行命令：<code>docker ps -l</code></p>
<p>列出最近创建的 n 个容器。</p>
<p>执行命令：<code>docker ps -n 5</code></p>
<h3> 2.创建与启动容器</h3>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>-i：表示运行容器；</li>
<li>-t：表示容器启动后会进入其命令行。加入这两个参数后，容器创建就能登录进去。即分配一个伪终端；</li>
<li>--name：为创建的容器命名；</li>
<li>-v：表示目录映射关系（前者是宿主机目录，后者是映射到宿主机上的目录），可以使用多个 -v 做多个目录或文件映射。注意：最好做目录映射，在宿主机上做修改，然后共享到容器上；</li>
<li>-d：在 run 后面加上 -d 参数，则会创建一个守护式容器在后台运行（这样创建容器后不会自动登录容器，如果只加 -i -t 两个参数，创建容器后就会自动进容器里）；</li>
<li>-p：表示端口映射，前者是宿主机端口，后者是容器内的映射端口。可以使用多个 -p 做多个端口映射。</li>
<li>-P：随机使用宿主机的可用端口与容器内暴露的端口映射。</li>
</ul>
<h3> 3.创建并进入容器</h3>
<p>下面这行命令的意思就是通过镜像 AA 创建一个容器 BB，运行容器并进入容器的<code>/bin/bash</code>。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>注意：<code>Docker</code>容器运行必须有一个前台进程，如果没有前台进程执行，容器认为是空闲状态，就会自动退出。</p>
<h3> 4.退出当前容器</h3>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 5.守护式方式创建容器</h3>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 6.登录守护式容器方式</h3>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 7.停止与启动容器</h3>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 8.文件拷贝</h3>
<p>如果我们需要将文件拷贝到容器内可以使用<code>cp</code>命令。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>也可以将文件从容器内拷贝出来。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 9.目录挂载</h3>
<p>我们可以在创建容器的时候，将宿主机的目录与容器内的目录进行映射，这样我们就可以通过修改宿主机某个目录的文件从而去影响容器，而且这个操作是双向绑定的，也就是说容器内的操作也会影响到宿主机，实现备份功能。</p>
<p>但是容器被删除的时候，宿主机的内容并不会被删除。如果多个容器挂载同一个目录，其中一个容器被删除，其他容器的内容也不会受到影响。</p>
<p>创建容器添加<code>-v</code>参数，格式为宿主机目录:容器目录，例如：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>提示</p>
<p>目录挂载操作可能会出现权限不足的提示。这是因为<code>CentOS7</code>中的安全模块<code>SELinux</code>把权限禁掉了，在<code>docker run</code>时通过<code>--privileged=true</code>给该容器加权限来解决挂载的目录没有权限的问题。</p>
<ul>
<li>匿名挂载</li>
</ul>
<p>匿名挂载只需要写容器目录即可，容器外对应的目录会在<code>/var/lib/docker/volumes</code>中生成。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>具名挂载</li>
</ul>
<p>具名挂载就是给数据卷起了个名字，容器外对应的目录会在<code>/var/lib/docker/volume</code>中生成。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>指定目录挂载</li>
</ul>
<p>之前挂载方式就属于指定目录挂载，这种方式的挂载不会在<code>/var/lib/docker/volume</code>目录生成内容。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>查看目录挂载关系</li>
</ul>
<p>通过<code>docker volume inspect</code>数据卷名称 可以查看该数据卷对应宿主机的目录地址。</p>
<p>执行命令：<code>docker volume inspect docker_centos_data</code></p>
<p>通过<code>docker inspect</code>容器ID或名称 ，在返回的<code>JSON</code>节点中找到<code>Mounts</code>，可以查看详细的数据挂载信息。</p>
<ul>
<li>只读/读写</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 10.删除容器</h3>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 11.查看容器 IP 地址</h3>
<p>我们可以通过以下命令查看容器的元信息。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>也可以直接执行下面的命令直接输出 IP 地址。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> 7.应用部署</h2>
<h3> 1.Nacos</h3>
<p>拉取官方<code>nacos</code>镜像</p>
<p>执行命令：<code>docker pull nacos/nacos-server</code></p>
<p>启动<code>nacos</code></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li><code>MODE=standalone</code>表示单机启动</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2.Nginx</h3>
<p>拉取官方<code>nginx</code>镜像</p>
<p>执行命令：<code>docker pull nginx</code></p>
<p>创建<code>Nginx</code>容器。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>将容器内的配置文件拷贝到指定目录（请先提前创建好目录）。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>终止并删除容器</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>创建<code>Nginx</code>容器，并将容器中的<code>/etc/nginx</code>目录和宿主机的<code>/home/ruoyi/nginx/conf</code>目录进行挂载。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 3.Mysql</h3>
<p>拉取官方<code>mysql5.7</code>镜像</p>
<p>执行命令：<code>docker pull mysql:5.7</code></p>
<ul>
<li>创建容器</li>
</ul>
<p>在本地创建<code>mysql</code>的映射目录</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>创建容器，将数据、日志、配置文件映射到本机</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>-d: 后台运行容器</li>
<li>-p 将容器的端口映射到本机的端口</li>
<li>-v 将主机目录挂载到容器的目录</li>
<li>-e 设置参数</li>
</ul>
<p>进入容器/执行命令：<code>docker exec -it mysql /bin/bash</code></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4.Redis</h3>
<p>拉取官方<code>redis</code>镜像</p>
<p>执行命令：<code>docker pull redis</code></p>
<p>创建容器。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>连接容器中的<code>Redis</code>时，只需要连接宿主机的<code>IP + 指定的映射端口</code>即可。</p>
<h2> 8.镜像构建</h2>
<p>我们可以通过公共仓库拉取镜像使用，但是，有些时候公共仓库拉取的镜像并不符合我们的需求。尽管已经从繁琐的部署工作中解放出来，但是实际开发时，我们可能希望镜像包含整个项目的完整环境，在其他机器上拉取打包完整的镜像，直接运行即可。</p>
<p>Docker 支持自己构建镜像，还支持将自己构建的镜像上传至公共仓库，镜像构建可以通过以下两种方式来实现：</p>
<ul>
<li><code>docker commit</code>：从容器创建一个新的镜像；</li>
<li><code>docker build</code>： 配合<code>Dockerfile</code>文件创建镜像。</li>
</ul>
<p>下面我们先通过<code>docker commit</code>来实现镜像的构建。</p>
<p>目标：接下来我们通过基础镜像<code>centos:7</code>，在该镜像中安装<code>jdk</code>和<code>tomcat</code>以后将其制作为一个新的镜像<code>mycentos:7</code>。</p>
<h3> 1.创建容器</h3>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2.拷贝资源</h3>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3.安装资源</h3>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4.构建镜像</h3>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>-a：提交的镜像作者；</li>
<li>-c：使用 Dockerfile 指令来创建镜像；</li>
<li>-m：提交时的说明文字；</li>
<li>-p：在 commit 时，将容器暂停。</li>
</ul>
<p>使用构建的镜像创建容器</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>访问<code>http://{ip}:{port}</code>，看到<code>tomcat</code>页面说明环境表示成功。</p>
<h2> 9.Dockerfile</h2>
<p>在<code>Docker</code>中构建镜像最常用的方式，就是使用<code>Dockerfile</code>。<code>Dockerfile</code>是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明。官方文档：<code>https://docs.docker.com/engine/reference/builder</code></p>
<h3> 1.Dockerfile 常用指令</h3>
<table>
<thead>
<tr>
<th>指令</th>
<th>语法</th>
<th style="text-align:right">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>FROM</td>
<td><code>FROM &lt;image&gt;:&lt;tag&gt;</code></td>
<td style="text-align:right">指明构建的新镜像是来自于哪个基础镜像，如果没有选择<code>tag</code>，那么默认值为<code>latest</code></td>
</tr>
<tr>
<td>MAINTAINER</td>
<td><code>MAINTAINER &lt;name&gt;</code></td>
<td style="text-align:right">指明镜像维护者及其联系方式（一般是邮箱地址）。官方说明已过时，推荐使用<code>LABEL</code></td>
</tr>
<tr>
<td>LABEL</td>
<td><code>LABEL &lt;key&gt;=&lt;value&gt; ...</code></td>
<td style="text-align:right">功能是为镜像指定标签。也可以使用<code>LABEL</code>来指定镜像作者</td>
</tr>
<tr>
<td>RUN</td>
<td><code>RUN &lt;command&gt;</code></td>
<td style="text-align:right">构建镜像时运行的<code>Shell</code>命令，比如构建的新镜像中我们想在<code>/usr/local</code>目录下创建一个<code>java</code>目录</td>
</tr>
<tr>
<td>ADD</td>
<td><code>ADD &lt;src&gt;... &lt;dest&gt;</code></td>
<td style="text-align:right">拷贝文件或目录到镜像中。src 可以是一个本地文件，还可以是一个<code>url</code>。然后自动下载和解压</td>
</tr>
<tr>
<td>COPY</td>
<td><code>COPY &lt;src&gt;... &lt;dest&gt;</code></td>
<td style="text-align:right">拷贝文件或目录到镜像中。用法同 ADD，只是不支持自动下载和解压</td>
</tr>
<tr>
<td>EXPOSE</td>
<td><code>EXPOSE &lt;port&gt; [&lt;port&gt;/&lt;protocol&gt;...]</code></td>
<td style="text-align:right">暴露容器运行时的监听端口给外部，可以指定端口是监听 TCP 还是 UDP，如果未指定协议，则默认为 TCP</td>
</tr>
<tr>
<td>ENV</td>
<td><code>ENV &lt;key&gt;=&lt;value&gt; ...</code></td>
<td style="text-align:right">设置容器内环境变量</td>
</tr>
<tr>
<td>CMD</td>
<td><code>CMD ["executable","param1","param2"]</code></td>
<td style="text-align:right">启动容器时执行的<code>Shell</code>命令。在<code>Dockerfile</code>中只能有一条<code>CMD</code>指令。如果设置了多条<code>CMD</code>，只有最后一条会生效</td>
</tr>
<tr>
<td>ENTRYPOINT</td>
<td><code>ENTRYPOINT ["executable", "param1", "param2"]</code></td>
<td style="text-align:right">启动容器时执行的 Shell 命令，同 CMD 类似，不会被 docker run 命令行指定的参数所覆盖，如果设置了多条<code>ENTRYPOINT</code>，只有最后一条会生效</td>
</tr>
<tr>
<td>WORKDIR</td>
<td><code>WORKDIR param</code></td>
<td style="text-align:right">为 RUN、CMD、ENTRYPOINT 以及 COPY 和 AND 设置工作目录</td>
</tr>
<tr>
<td>VOLUME</td>
<td><code>VOLUME ["param"]</code></td>
<td style="text-align:right">指定容器挂载点到宿主机自动生成的目录或其他容器。一般的使用场景为需要持久化存储数据时</td>
</tr>
</tbody>
</table>
<h3> 2.构建镜像</h3>
<p><code>Dockerfile</code>文件编写好以后，真正构建镜像时需要通过<code>docker build</code>命令。</p>
<p><code>docker build</code>命令用于使用<code>Dockerfile</code>创建镜像。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>-f：指定要使用的 Dockerfile 路径；</li>
<li>--tag, -t：镜像的名字及标签，可以在一次构建中为一个镜像设置多个标签。</li>
</ul>
<h3> 3.Dockerfile 实践</h3>
<p>接下来我们通过基础镜像<code>centos:7</code>，在该镜像中安装<code>jdk</code>和<code>tomcat</code>以后将其制作为一个新的镜像<code>mycentos:7</code></p>
<p>创建目录，编写<code>Dockerfile</code>文件</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>执行命令：<code>vi Dockerfile</code>，写入信息。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>构建镜像</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>启动镜像</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>进入容器</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 4.镜像构建历史</h3>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2> 10.镜像仓库</h2>
<p>我们使用的镜像都是从<code>DockerHub</code>公共仓库拉取的，我们也学习了如何制作自己的镜像，但是通过<code>tar</code>包的方式实现镜像的备份恢复迁移对于团队协作开发并不是特别友好，我们也可以将镜像推送至<code>DockerHub</code>仓库方便使用。</p>
<p>温馨提示：如果构建的镜像内携带了项目数据，建议还是使用私有仓库比较好。</p>
<h3> 1.注册账号</h3>
<p>官网：<code>https://hub.docker.com</code></p>
<p><img src="https://oscimg.oschina.net/oscnet/up-86c7ba7bd32377d3dd5420f5f0926290647.png" alt="docker"></p>
<h3> 2.登录账号</h3>
<p>通过<code>docker login</code>命令输入账号密码登录<code>DockerHub</code>。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-505dc6408f10079822d4fa3c5eb201b3b82.png" alt="docker"></p>
<h3> 3.推送镜像至仓库</h3>
<p>为了方便测试，我们将<code>hello-world</code>镜像拉取至本地，然后再上传至<code>DockerHub</code>仓库中。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4.查看仓库</h3>
<p><img src="https://oscimg.oschina.net/oscnet/up-7589f00e3b6c4e83a07e318a4298580381c.png" alt="docker"></p>
<h3> 5.拉取镜像</h3>
<p>通过<code>docker pull ruoyivip/test-hello-world:1.0.0</code>测试镜像是否可以拉取。</p>
<h3> 6.退出账号</h3>
<p>通过<code>docker logout</code>退出账号</p>
<h2> 11.Docker Compose</h2>
<p>通过前面几篇文章的学习，我们可以通过<code>Dockerfile</code>文件让用户很方便的定义一个单独的应用容器。然而，在日常工作中，经常会碰到需要多个容器相互配合来完成某项任务的情况，或者开发一个<code>Web</code>应用，除了<code>Web</code>服务容器本身，还需要数据库服务容器、缓存容器，甚至还包括负载均衡容器等等。</p>
<p><code>Docker Compose</code>恰好满足了这样的需求，它是用于定义和运行多容器<code>Docker</code>应用程序的工具。通过<code>Compose</code>，您可以使用<code>YAML</code>文件来配置应用程序所需要的服务。然后使用一个命令，就可以通过<code>YAML</code>配置文件创建并启动所有服务。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><code>Docker Compose</code>使用的三个步骤为：</p>
<ul>
<li>使用<code>Dockerfile</code>文件定义应用程序的环境；</li>
<li>使用<code>docker-compose.yml</code>文件定义构成应用程序的服务，这样它们可以在隔离环境中一起运行；</li>
<li>执行<code>docker-compose up</code>命令来创建并启动所有服务。</li>
</ul>
<h3> 1.Compose 安装</h3>
<p>官方文档：https://docs.docker.com/compose/install/</p>
<p>您可以在<code>macOS</code>，<code>Windows</code>和<code>Linux</code>上运行<code>Compose</code>。本文演示基于<code>Linux</code>环境的安装。我们可以使用<code>curl</code>命令从<code>Github</code>下载它的二进制文件来使用，运行以下命令下载<code>Docker Compose</code>的当前稳定版本。或者从网页下载后上传至服务器指定目录<code>/usr/local/bin</code>也行。</p>
<ul>
<li>下载</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>您可以通过修改 URL 中的版本，自定义您所需要的版本文件。</p>
<p>安装完成以后，查看指定目录，发现该文件没有可执行权限，进行授权操作。</p>
<ul>
<li>授权</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>测试</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>卸载</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 2.docker-compose.yml 文件详解</h3>
<p>官方文档：<code>https://docs.docker.com/compose/compose-file/</code></p>
<p><code>Docker Compose</code>允许用户通过<code>docker-compose.yml</code>文件（YAML 格式）来定义一组相关联的容器为一个工程（project）。一个工程包含多个服务（service），每个服务中定义了创建容器时所需的镜像、参数、依赖等。</p>
<p><code>Docker Compose</code>模板文件我们需要关注的顶级配置有<code>version</code>、<code>services</code>、<code>networks</code>、<code>volumes</code>几个部分，除<code>version</code>外，其他几个顶级配置下还有很多下级配置，后面也会详细给大家介绍，先来看看这几个顶级配置都什么意思：</p>
<ul>
<li><code>version</code>：描述<code>Compose</code>文件的版本信息，当前最新版本为<code>3.8</code>，对应的<code>Docker</code>版本为<code>19.03.0+</code></li>
<li><code>services</code>：定义服务，可以多个，每个服务中定义了创建容器时所需的镜像、参数、依赖等</li>
<li><code>networkds</code>：定义网络，可以多个，根据<code>DNS server</code>让相同网络中的容器可以直接通过容器名称进行通信</li>
<li><code>volumes</code>：数据卷，用于实现目录挂载</li>
</ul>
<p>示例</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用<code>docker-compose up</code>创建并启动所有服务。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>浏览器访问：http://192.168.10.10/ 结果如下</p>
<p>使用<code>docker-compose down</code>可以停止并删除容器、网络。</p>
<h4> 2.1 version 版本信息</h4>
<p>描述<code>Compose</code>文件的版本信息，当前最新版本为<code>3.8</code>，对应的<code>Docker</code>版本为<code>19.03.0+</code>。关于每个版本的详细信息请参考：<code>https://docs.docker.com/compose/compose-file/compose-versioning/</code></p>
<p>以下为<code>Compose</code>文件的版本信息所对应的<code>Docker</code>版本。</p>
<table>
<thead>
<tr>
<th>Compose file format</th>
<th style="text-align:right">Docker Engine release</th>
</tr>
</thead>
<tbody>
<tr>
<td>3.8</td>
<td style="text-align:right">19.03.0+</td>
</tr>
<tr>
<td>3.7</td>
<td style="text-align:right">18.06.0+</td>
</tr>
<tr>
<td>3.6</td>
<td style="text-align:right">18.02.0+</td>
</tr>
<tr>
<td>3.5</td>
<td style="text-align:right">17.12.0+</td>
</tr>
<tr>
<td>3.4</td>
<td style="text-align:right">17.09.0+</td>
</tr>
<tr>
<td>3.3</td>
<td style="text-align:right">17.06.0+</td>
</tr>
<tr>
<td>3.2</td>
<td style="text-align:right">17.04.0+</td>
</tr>
<tr>
<td>3.1</td>
<td style="text-align:right">1.13.1+</td>
</tr>
<tr>
<td>3.0</td>
<td style="text-align:right">1.13.0+</td>
</tr>
<tr>
<td>...</td>
<td style="text-align:right">1.x.x</td>
</tr>
</tbody>
</table>
<h4> 2.2 services 定义服务</h4>
<p><code>services</code>用来定义服务，可以多个，每个服务中定义了创建容器时所需的镜像、参数、依赖等，就像将命令行参数传递给<code>docker run</code>一样。同样，网络和数据卷的定义也是一样的。</p>
<p>比如，通过<code>docker run</code>命令构建一个<code>MySQL</code>应用容器的命令如下：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>使用<code>docker-compose.yml</code>以后则可以这样定义：</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2.3 image 镜像名称标签</h4>
<p>指定创建容器时所需的镜像名称标签或者镜像<code>ID</code>。如果镜像在本地不存在，会去远程拉取。</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2.4 build 构建容器</h4>
<p>除了可以基于指定的镜像构建容器，还可以基于<code>Dockerfile</code>文件构建，在使用<code>up</code>命令时会执行构建任</p>
<h4> 2.5 context 文件路径</h4>
<p>该选项可以是<code>Dockerfile</code>文件的绝对/相对路径，也可以是远程<code>Git</code>仓库的<code>URL</code>，当提供的值是相对路径时，相对当前<code>docker-compose.yml</code>文件所在目录。</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2.6 dockerfile 构建镜像</h4>
<p>一般情况下，默认都基于文件名叫<code>Dockerfile</code>的文件构建镜像，当然也可以是自定义的文件名，使用<code>dockerfile</code>声明，不过这个选项只能声明文件名，文件所在路径还是要通过<code>centext</code>来声明。</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2.7 container_name 容器名称</h4>
<p><code>Compose</code>创建的容器默认生成的名称格式为：<code>工程名称_服务条目名称_序号</code>。如果要使用自定义名称，使用<code>container_name</code>声明。</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因为<code>Docker</code>容器名称必须是唯一的，所以如果指定了自定义名称，就不能将服务扩展至多个容器。这样做可能会导致错误。</p>
<h4> 2.8 depends_on 容器依赖</h4>
<p>使用<code>Compose</code>最大的好处就是敲最少的命令做更多的事情，但一般项目容器启动的顺序是有要求的，如果直接从上到下启动容器，必然会因为容器依赖问题而启动失败。例如在没有启动数据库容器的情况下启动了<code>Web</code>应用容器，应用容器会因为找不到数据库而退出。<code>depends_on</code>就是用来解决容器依赖、启动先后问题的配置项。</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述<code>YAML</code>文件定义的容器会先启动<code>db</code>和<code>redis</code>两个服务，最后才启动<code>web</code>服务。</p>
<h4> 2.9 ports 暴露端口</h4>
<p>容器对外暴露的端口，格式：左边宿主机端口:右边容器端口。</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2.10 expose 接受端口范围</h4>
<p>容器暴露的端口不映射到宿主机，只允许能被连接的服务访问。</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2.11 restart 重启策略</h4>
<p>容器重启策略，简单的理解就是<code>Docker</code>重启以后容器要不要一起启动</p>
<ul>
<li>no：默认的重启策略，在任何情况下都不会重启容器；</li>
<li>on-failure：容器非正常退出时，比如退出状态为非0(异常退出)，才会重启容器；</li>
<li>always：容器总是重新启动，即使容器被手动停止了，当<code>Docker</code>重启时容器也还是会一起启动；</li>
<li>unless-stopped：容器总是重新启动，除非容器被停止（手动或其他方式），那么<code>Docker</code>重启时容器则不会启动。</li>
</ul>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2.12 environment 环境变量</h4>
<p>添加环境变量。可以使用数组也可以使用字典。布尔相关的值（true、false、yes、no）都需要用引号括起来，以确保 YML 解析器不会将它们转换为真或假。</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>或者以下格式：</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2.13 env_file 文件获取环境变量</h4>
<p>从文件中获取环境变量，可以指定一个或多个文件，其优先级低于<code>environment</code>指定的环境变量。</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意：env 文件中的每一行需采用<code>键=值</code>格式。以<code>#</code>开头的行会被视为注释并被忽略。空行也会被忽略。</p>
<h4> 2.14 command 执行命令</h4>
<p>覆盖容器启动后默认执行的命令。</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>该命令也可以是一个列表。</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 2.15 volumes 目录挂载</h4>
<p>数据卷，用于实现目录挂载，支持指定目录挂载、匿名挂载、具名挂载。</p>
<ul>
<li>指定目录挂载的格式为：左边宿主机目录:右边容器目录，或者左边宿主机目录:右边容器目录:读写权限；</li>
<li>匿名挂载格式为：容器目录即可，或者容器目录即可:读写权限；</li>
<li>具名挂载格式为：数据卷条目名称:容器目录，或者数据卷条目名称:容器目录:读写权限。</li>
</ul>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2.16 network_mode 网络模式</h4>
<p>设置网络模式，类似 docker run 时添加的参数 --net host 或者 --network host 的用法</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2.17 networks</h4>
<p>配置容器连接的网络，引用顶级 networks 下的条目。</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2.18 aliases</h4>
<p>网络上此服务的别名。同一网络上的其他容器可以使用服务名或此别名连接到服务容器。同一服务在不同的网络上可以具有不同的别名。</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3. Compose 常用命令</h3>
<p>官方文档：<code>https://docs.docker.com/compose/reference/overview/</code></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>部分命令选项如下：</p>
<ul>
<li>-f，--file：指定使用的 Compose 模板文件，默认为 docker-compose.yml，可以多次指定，指定多个 yml；</li>
<li>-p, --project-name：指定工程名称，默认使用 docker-compose.yml 文件所在目录的名称；</li>
<li>-v：打印版本并退出；</li>
<li>--log-level：定义日志等级（DEBUG, INFO, WARNING, ERROR, CRITICAL）。</li>
</ul>
<h4> help</h4>
<p><code>docker-compose -help</code>查看帮助。</p>
<h4> config</h4>
<p><code>docker-compose config -q</code>验证<code>docker-compose.yml</code>文件。当配置正确时，不输出任何内容，当配置错误时，输出错误信息。</p>
<h4> pull</h4>
<p><code>docker-compose pull</code>拉取服务依赖的镜像。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> up</h4>
<p><code>docker-compose up</code>创建并启动所有服务的容器。指定多个<code>yml</code>加<code>-f</code>选项。以守护进程模式运行加<code>-d</code>选项。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> logs</h4>
<p><code>docker-compose logs</code>查看服务容器的输出日志。默认情况下，<code>docker-compose</code>将对不同的服务输出使用不同的颜色来区分。可以通过<code>--no-color</code>来关闭颜色。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> ps</h4>
<p><code>docker-compose ps</code>列出工程中所有服务的容器。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> run</h4>
<p><code>docker-compose run</code>在指定服务容器上执行一个命令。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4> exec</h4>
<p><code>docker-compose exec</code>进入服务容器。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> pause</h4>
<p><code>docker-compose pause</code>暂停服务容器</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> unpause</h4>
<p><code>docker-compose unpause</code>恢复服务容器。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> restart</h4>
<p><code>docker-compose restart</code>重启服务容器。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> start</h4>
<p><code>docker-compose start</code>启动服务容器。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> stop</h4>
<p><code>docker-compose stop</code>停止服务容器。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> kill</h4>
<p><code>docker-compose kill</code>通过发送<code>SIGKILL</code>信号停止指定服务的容器。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4> rm</h4>
<p>docker-compose rm 删除服务（停止状态）容器。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> down</h4>
<p>停止并删除所有服务的容器、网络、镜像、数据卷。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> images</h4>
<p><code>docker-compose images</code>打印服务容器所对应的镜像。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> port</h4>
<p><code>docker-compose port</code>打印指定服务容器的某个端口所映射的宿主机端口。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> top</h4>
<p><code>docker-compose top</code>显示正在运行的进程。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 11.项目部署</h2>
<p>项目提供了<code>docker</code>部署，只需要复制<code>jar文件</code>到对应的<code>/docker/ruoyi</code>目录下。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上传文件到自己的服务器，通过<code>deploy.sh</code>执行命令控制。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>时区设置</p>
<p>如果服务器的时区不正确，可以在<code>docker-compose.yml</code>设置<code>environment</code>新增时区<code>TZ: Asia/Shanghai</code>，示例如下。</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
      <enclosure url="https://oscimg.oschina.net/oscnet/up-25befe4051199696c80debe588ccbf4c588.png" type="image/png"/>
    </item>
    <item>
      <title>工具代码</title>
      <link>https://javaguide.cn/my-blog/tools-code/code.html</link>
      <guid>https://javaguide.cn/my-blog/tools-code/code.html</guid>
      <source url="https://javaguide.cn/rss.xml">工具代码</source>
      <description>工具代码 👉 日常博客文章，编写工具代码 有些代码总数忘记怎么写，然后用的比较多，所以就记录下来。 👉 作者：小白 原文：https://blog.csdn.net/zhouqi1427/article/details/126061684 1. mybatis插件使用 import com.baomidou.mybatisplus.core.toolkit.PluginUtils; import com.baomidou.mybatisplus.extension.handlers.AbstractSqlParserHandler; import org.apache.ibatis.executor.statement.StatementHandler; import org.apache.ibatis.mapping.BoundSql; import org.apache.ibatis.mapping.MappedStatement; import org.apache.ibatis.mapping.SqlCommandType; import org.apache.ibatis.plugin.Interceptor; import org.apache.ibatis.plugin.Intercepts; import org.apache.ibatis.plugin.Invocation; import org.apache.ibatis.plugin.Signature; import org.apache.ibatis.reflection.MetaObject; import org.apache.ibatis.reflection.SystemMetaObject; import org.springframework.stereotype.Component; import java.sql.Connection; import java.util.Properties; @Intercepts({@Signature( type = StatementHandler.class, method = &amp;quot;prepare&amp;quot;, args = {Connection.class, Integer.class} )}) @Component public class MyBatisPlusInterceptor extends AbstractSqlParserHandler implements Interceptor { @Override public Object intercept(Invocation invocation) throws Throwable { StatementHandler statementHandler = PluginUtils.realTarget(invocation.getTarget()); MetaObject metaObject = SystemMetaObject.forObject(statementHandler); this.sqlParser(metaObject); MappedStatement mappedStatement = (MappedStatement) metaObject.getValue(&amp;quot;delegate.mappedStatement&amp;quot;); if(!SqlCommandType.SELECT.equals(mappedStatement.getSqlCommandType()) &amp;amp;&amp;amp; !SqlCommandType.DELETE.equals(mappedStatement.getSqlCommandType())) { return invocation.proceed(); } BoundSql boundSql = (BoundSql) metaObject.getValue(&amp;quot;delegate.boundSql&amp;quot;); // 执行的SQL语句 String sql = boundSql.getSql(); // 查询控制 if(SqlCommandType.SELECT.equals(mappedStatement.getSqlCommandType())) { if(!sql.toUpperCase().contains(&amp;quot;WHERE&amp;quot;)) { throw new Exception(&amp;quot;缺少查询条件&amp;quot;); } } // 删除控制 if(SqlCommandType.DELETE.equals(mappedStatement.getSqlCommandType())) { if(!sql.toUpperCase().contains(&amp;quot;WHERE&amp;quot;)) { throw new Exception(&amp;quot;缺少删除条件&amp;quot;); } } // SQL语句的参数 Object parameterObject = boundSql.getParameterObject(); // 重新设置SQL // metaObject.setValue(&amp;quot;delegate.boundSql.sql&amp;quot;, sql); return invocation.proceed(); } /** * 生成拦截对象代理 * @param target * @return */ @Override public Object plugin(Object target) { return Interceptor.super.plugin(target); } @Override public void setProperties(Properties properties) { Interceptor.super.setProperties(properties); } }</description>
      <category>软件安装</category>
      <pubDate>Wed, 29 Mar 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<div class="hint-container tip">
<p class="hint-container-title">工具代码</p>
<p>👉 日常博客文章，编写工具代码
有些代码总数忘记怎么写，然后用的比较多，所以就记录下来。</p>
<p>👉 作者：小白</p>
</div>
<blockquote>
<p>原文：https://blog.csdn.net/zhouqi1427/article/details/126061684</p>
</blockquote>
<h3> 1. mybatis插件使用</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 2.请求转发参数传递</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>Centos7.9安装elk</title>
      <link>https://javaguide.cn/my-blog/software-installation/elk.html</link>
      <guid>https://javaguide.cn/my-blog/software-installation/elk.html</guid>
      <source url="https://javaguide.cn/rss.xml">Centos7.9安装elk</source>
      <description>安装基础软件 👉 日常博客文章，编写elk 若依网址来的 👉 作者：小白 基本介绍 什么是分布式日志 在分布式应用中，日志被分散在储存不同的设备上。如果你管理数十上百台服务器，你还在使用依次登录每台机器的传统方法查阅日志。这样是不是感觉很繁琐和效率低下。所以我们使用集中化的日志管理，分布式日志就是对大规模日志数据进行采集、追踪、处理。 为什么要使用分布式日志</description>
      <category>软件安装</category>
      <pubDate>Tue, 07 Feb 2023 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<div class="hint-container tip">
<p class="hint-container-title">安装基础软件</p>
<p>👉 日常博客文章，编写elk 若依网址来的</p>
<p>👉 作者：小白</p>
</div>
<h2> 基本介绍</h2>
<ul>
<li>什么是分布式日志</li>
</ul>
<p>在分布式应用中，日志被分散在储存不同的设备上。如果你管理数十上百台服务器，你还在使用依次登录每台机器的传统方法查阅日志。这样是不是感觉很繁琐和效率低下。所以我们使用集中化的日志管理，分布式日志就是对大规模日志数据进行采集、追踪、处理。</p>
<ul>
<li>为什么要使用分布式日志</li>
</ul>
<p>一般我们需要进行日志分析场景：直接在日志文件中<code>grep</code>、<code>awk</code>就可以获得自己想要的信息。但在规模较大的场景中，此方法效率低下，面临问题包括日志量太大如何归档、文本搜索太慢怎么办、如何多维度查询。需要集中化的日志管理，所有服务器上的日志收集汇总。常见解决思路是建立集中式日志收集系统，将所有节点上的日志统一收集，管理，访问。</p>
<ul>
<li>ELK 分布式日志</li>
</ul>
<p>实际上<code>ELK</code>是三款软件的简称，分别是<code>Elasticsearch</code>、 <code>Logstash</code>、<code>Kibana</code>组成。</p>
<p><strong>Elasticsearch</strong> 基于<code>java</code>，是个开源分布式搜索引擎，它的特点有：分布式，零配置，自动发现，索引自动分片，索引副本机制，<code>restful</code>风格接口，多数据源，自动搜索负载等。</p>
<p><strong>Kibana</strong> 基于<code>nodejs</code>，也是一个开源和免费的工具，<code>Kibana</code>可以为<code>Logstash</code>和<code>ElasticSearch</code>提供的日志分析友好的Web 界面，可以汇总、分析和搜索重要数据日志。</p>
<p><strong>Logstash</strong> 基于<code>java</code>，是一个开源的用于收集,分析和存储日志的工具。</p>
<p>下面是<code>ELK</code>的工作原理： <img src="https://oscimg.oschina.net/oscnet/up-c62bd9299557f77a05d1a9c4ccd046f8fef.png" alt="elk"></p>
<h2> Elasticsearch</h2>
<h3> 简介</h3>
<p>ElasticSearch是一个基于Lucene的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。Elasticsearch是用Java开发的，并作为Apache许可条款下的开放源码发布，是当前流行的企业级搜索引擎。设计用于云计算中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。</p>
<p>我们建立一个网站或应用程序，并要添加搜索功能，但是想要完成搜索工作的创建是非常困难的。我们希望搜索解决方案要运行速度快，我们希望能有一个零配置和一个完全免费的搜索模式，我们希望能够简单地使用JSON通过HTTP来索引数据，我们希望我们的搜索服务器始终可用，我们希望能够从一台开始并扩展到数百台，我们要实时搜索，我们要简单的多租户，我们希望建立一个云的解决方案。因此我们利用Elasticsearch来解决所有这些问题及可能出现的更多其它问题。</p>
<p>ElasticSearch是Elastic Stack的核心，同时Elasticsearch 是一个分布式、RESTful风格的搜索和数据分析引擎，能够解决不断涌现出的各种用例。作为Elastic Stack的核心，它集中存储您的数据，帮助您发现意料之中以及意料之外的情况。</p>
<h3> 下载</h3>
<p>到官网下载： (<a href="https://www.elastic.co/cn/downloads/elasticsearch" target="_blank" rel="noopener noreferrer">https://www.elastic.co/cn/downloads/elasticsearch (opens new window)</a>) <img src="https://oscimg.oschina.net/oscnet/up-d392963dafc68bc669d12ada72348dbf95b.png" alt="Elasticsearch"></p>
<h3> 安装</h3>
<ul>
<li>解压到相应目录</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>修改配置</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>创建<code>es</code>用户 因为<code>ElasticSearch</code>不支持<code>Root</code>用户直接操作，因此我们需要创建一个<code>es</code>用户</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 启动</h3>
<ul>
<li>切换用户成es用户进行操作</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>后台启动</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在浏览器打开<code>9200</code>端口地址： (<a href="http://120.78.129.95:9200/" target="_blank" rel="noopener noreferrer">http://120.78.129.95:9200/ (opens new window)</a>)，如果出现了下面的信息，就表示已经成功启动了 <img src="https://oscimg.oschina.net/oscnet/up-38da6dfc0998a88b8b2f974f6192ae6420a.png" alt="Elasticsearch"></p>
<h2> Logstash</h2>
<h3> 简介</h3>
<p>Logstash是一个开源的服务器端数据处理管道，能够同时从多个来源采集数据，转换数据，然后将数据发送到最喜欢的存储库中（我们的存储库当然是ElasticSearch）</p>
<h3> 下载</h3>
<p>到官网下载： (<a href="https://www.elastic.co/cn/downloads/logstash" target="_blank" rel="noopener noreferrer">https://www.elastic.co/cn/downloads/logstash (opens new window)</a>)
<img src="https://oscimg.oschina.net/oscnet/up-7780b6e1555bae2c2d2ce3e1dde44d9e783.png" alt="Logstash"></p>
<h3> 安装</h3>
<ul>
<li>解压到相应目录</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>新增配置文件</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 启动</h3>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> Kibana</h2>
<h3> 简介</h3>
<p>Kibana 是一款开源的数据分析和可视化平台，它是 Elastic Stack 成员之一，设计用于和 Elasticsearch 协作。您可以使用 Kibana 对 Elasticsearch 索引中的数据进行搜索、查看、交互操作。您可以很方便的利用图表、表格及地图对数据进行多元化的分析和呈现。</p>
<h3> 下载</h3>
<p>到官网下载： (<a href="https://www.elastic.co/cn/downloads/kibana" target="_blank" rel="noopener noreferrer">https://www.elastic.co/cn/downloads/kibana (opens new window)</a>)
<img src="https://oscimg.oschina.net/oscnet/up-8a4821b16ba2f3bd96baf9a3b2bb7b55f0b.png" alt="Kibana"></p>
<h3> 安装</h3>
<ul>
<li>解压到相应目录</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>修改配置</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>授权es用户</li>
</ul>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 启动</h3>
<ul>
<li>切换用户成es用户进行操作</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>后台启动</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在浏览器打开<code>5601</code>端口地址： (<a href="http://120.78.129.95:5601/" target="_blank" rel="noopener noreferrer">http://120.78.129.95:5601/ (opens new window)</a>)，如果出现了下面的信息，就表示已经成功启动了 <img src="https://oscimg.oschina.net/oscnet/up-f9bd125ad0b1d3887a2d3f94df9e9202d2c.png" alt="kibana"></p>
<h2> 切换中文</h2>
<p>在<code>config/kibana.yml</code>添加</p>
<div class="language-yaml line-numbers-mode" data-ext="yml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> 日志收集</h2>
<p>对应服务器安装<code>logstash</code>，配置规则，例如新建<code>logstash-apache.conf</code></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>启动logstash</li>
</ul>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>通过<code>kibana</code>可视化检索各个服务日志数据 <img src="https://oscimg.oschina.net/oscnet/up-928d6f45a566fc7e6191db840a4b27de551.png" alt="kibana"></li>
</ul>
<h2> ES集群搭建详细步骤[通俗易懂]</h2>
<p>@系统：<em>Centos6</em>*** ES版本：6.4.0 <a href="https://cloud.tencent.com/product/cvm?from=10680" target="_blank" rel="noopener noreferrer">服务器</a>三台 172.16.0.8 172.16.0.6 172.16.0.22</p>
<p>部署jdk 解压jdk放在/data目录，/data/jdk 配置环境变量，/etc/proifle里面加入如下</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>复制</p>
<p>source /etc/profile生效，查看版本java -version</p>
<p>部署ES集群，三台机器同样的操作</p>
<h3> 1、添加普通用户启动</h3>
<p>es <code>useradd elasticsearch</code></p>
<h3> 2、安装ES</h3>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>复制</p>
<h3> 3、配置elasticsearch.yml文件内容</h3>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>复制</p>
<p>三台机器不一样的配置点如下</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4、配置文件重点参数解析</h3>
<p>（1）cluster.name 集群名字，三台集群的集群名字都必须一致</p>
<p>（2）node.name 节点名字，三台ES节点字都必须不一样</p>
<p>（3）discovery.zen.minimum_master_nodes:2 表示集群最少的master数，如果集群的最少master数据少于指定的数，将无法启动，官方推荐node master数设置为集群数/2+1，我这里三台ES服务器，配置最少需要两台master，整个集群才可正常运行，</p>
<p>（4）node.master该节点是否有资格选举为master，如果上面设了两个mater_node 2，也就是最少两个master节点，则集群中必须有两台es服务器的配置为node.master: true的配置，配置了2个节点的话，如果主服务器宕机，整个集群会不可用，所以三台服务器，需要配置3个node.masdter为true,这样三个master，宕了一个主节点的话，他又会选举新的master，还有两个节点可以用，只要配了node master为true的ES服务器数正在运行的数量不少于master_node的配置数，则整个集群继续可用，我这里则配置三台es node.master都为true，也就是三个master，master服务器主要管理集群状态，负责元数据处理，比如索引增加删除分片分配等，数据存储和查询都不会走主节点，压力较小，jvm内存可分配较低一点</p>
<p>（5）node.data 存储索引数据，三台都设为true即可</p>
<p>（6）bootstrap.memory_lock: true 锁住物理内存，不使用swap内存，有swap内存的可以开启此项</p>
<p>（7）discovery.zen.ping_timeout: 3000s 自动发现拼其他节点超时时间</p>
<p>（8）discovery.zen.ping.unicast.hosts: [“172.16.0.8:9300″,”172.16.0.6:9300″,”172.16.0.22:9300”] 设置集群的初始节点列表，集群互通端口为9300</p>
<h3> 5、jvm调优</h3>
<p>vim /data/elasticsearch/config/jvm.options</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>复制</p>
<p>设置为物理内存一半最佳，可根据服务器内存去选择调</p>
<h3> 6、设置权限</h3>
<p>chown -R elasticsearch: /data/elasticsearch</p>
<h3> 7、操作系统调优</h3>
<p>（必须配置，否则ES起不来）</p>
<p>【1】内存优化 在/etc/sysctl.conf添加如下内容</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>复制</p>
<p>sysctl -p生效</p>
<p>解释： （1）vm.max_map_count=655360 系统最大打开文件描述符数</p>
<p>（2）vm.max_map_count=655360 限制一个进程拥有虚拟内存区域的大小</p>
<p>【2】修改vim /etc/security/limits.conf</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>复制</p>
<p>解释: (nofile)最大开打开文件描述符 (nproc)最大用户进程数 (memlock)最大锁定内存地址空间</p>
<p>【3】修改/etc/security/limits.d/90-nproc.conf 将1024修改为65536</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>复制</p>
<p>ctrl +d从进终端 ulimit -a查看</p>
<h3> 8、编写es启动脚本</h3>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>复制</p>
<p>查看启动</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>复制</p>
<h3> 9、监控API</h3>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
      <enclosure url="https://oscimg.oschina.net/oscnet/up-c62bd9299557f77a05d1a9c4ccd046f8fef.png" type="image/png"/>
    </item>
    <item>
      <title>JavaGuide（Java学习&amp;&amp;面试指南）</title>
      <link>https://javaguide.cn/home.html</link>
      <guid>https://javaguide.cn/home.html</guid>
      <source url="https://javaguide.cn/rss.xml">JavaGuide（Java学习&amp;&amp;面试指南）</source>
      <description>友情提示 面试专版 ：准备 Java 面试的小伙伴可以考虑面试专版：《Java 面试进阶指北 》 (质量很高，专为面试打造，配合 JavaGuide 食用)。 知识星球 ：专属面试小册/一对一交流/简历修改/专属求职指南，欢迎加入 JavaGuide 知识星球（点击链接即可查看星球的详细介绍，一定一定一定确定自己真的需要再加入，一定一定要看完详细介绍之后再加我）。 转载须知 ：以下所有文章如非文首说明为转载皆为 JavaGuide 原创，转载在文首注明出处，如发现恶意抄袭/搬运，会动用法律武器维护自己的权益。让我们一起维护一个良好的技术创作环境！</description>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<div class="hint-container tip">
<p class="hint-container-title">友情提示</p>
<ul>
<li><strong>面试专版</strong> ：准备 Java 面试的小伙伴可以考虑面试专版：<strong><a href="/zhuanlan/java-mian-shi-zhi-bei.html" target="blank">《Java 面试进阶指北 》</a></strong> (质量很高，专为面试打造，配合 JavaGuide 食用)。</li>
<li><strong>知识星球</strong> ：专属面试小册/一对一交流/简历修改/专属求职指南，欢迎加入 <strong><a href="/about-the-author/zhishixingqiu-two-years.html" target="blank">JavaGuide 知识星球</a></strong>（点击链接即可查看星球的详细介绍，一定一定一定确定自己真的需要再加入，一定一定要看完详细介绍之后再加我）。</li>
<li><strong>转载须知</strong> ：以下所有文章如非文首说明为转载皆为 JavaGuide 原创，转载在文首注明出处，如发现恶意抄袭/搬运，会动用法律武器维护自己的权益。让我们一起维护一个良好的技术创作环境！</li>
</ul>
</div>
<div align="center">
    <p>
        <a href="https://github.com/Snailclimb/JavaGuide" target="_blank">
            <img src="https://img-blog.csdnimg.cn/img_convert/1c00413c65d1995993bf2b0daf7b4f03.png#pic_center" width="">
        </a>
    </p>
    <p>
        <a href="https://javaguide.cn/"><img src="https://img.shields.io/badge/阅读-read-brightgreen.svg" alt="阅读"></a>
        <img src="https://img.shields.io/github/stars/Snailclimb/JavaGuide" alt="stars">
        <img src="https://img.shields.io/github/forks/Snailclimb/JavaGuide" alt="forks">
        <img src="https://img.shields.io/github/issues/Snailclimb/JavaGuide" alt="issues">
    </p>
    <p>
        <a href="https://github.com/Snailclimb/JavaGuide">Github</a> |
        <a href="https://gitee.com/SnailClimb/JavaGuide">Gitee</a>
    </p>  
</div>
<div style="text-align:center">
    <p>
        <a href="https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc">
            <img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/gongzhonghaoxuanchuan.png" style="margin: 0 auto;">
        </a>
    </p>
</div>
<h2> 项目相关</h2>
<ul>
<li><a href="/javaguide/intro.html" target="blank">项目介绍</a></li>
<li><a href="/javaguide/contribution-guideline.html" target="blank">贡献指南</a></li>
<li><a href="/javaguide/faq.html" target="blank">常见问题</a></li>
<li><a href="/javaguide/todo.html" target="blank">项目代办</a></li>
</ul>
<h2> Java</h2>
<h3> 基础</h3>
<p><strong>知识点/面试题总结</strong> : (必看👍 )：</p>
<ul>
<li><a href="/java/basis/java-basic-questions-01.html" target="blank">Java 基础常见知识点&amp;面试题总结(上)</a></li>
<li><a href="/java/basis/java-basic-questions-02.html" target="blank">Java 基础常见知识点&amp;面试题总结(中)</a></li>
<li><a href="/java/basis/java-basic-questions-03.html" target="blank">Java 基础常见知识点&amp;面试题总结(下)</a></li>
</ul>
<p><strong>重要知识点详解</strong> ：</p>
<ul>
<li><a href="/java/basis/why-there-only-value-passing-in-java.html" target="blank">为什么 Java 中只有值传递？</a></li>
<li><a href="/java/basis/serialization.html" target="blank">Java 序列化详解</a></li>
<li><a href="/java/basis/generics-and-wildcards.html" target="blank">泛型&amp;通配符详解</a></li>
<li><a href="/java/basis/reflection.html" target="blank">Java 反射机制详解</a></li>
<li><a href="/java/basis/proxy.html" target="blank">Java 代理模式详解</a></li>
<li><a href="/java/basis/bigdecimal.html" target="blank">BigDecimal 详解</a></li>
<li><a href="/java/basis/unsafe.html" target="blank">Java 魔法类 Unsafe 详解</a></li>
<li><a href="/java/basis/spi.html" target="blank">Java SPI 机制详解</a></li>
<li><a href="/java/basis/syntactic-sugar.html" target="blank">Java 语法糖详解</a></li>
</ul>
<h3> 集合</h3>
<p><strong>知识点/面试题总结</strong> ：</p>
<ul>
<li><a href="/java/collection/java-collection-questions-01.html" target="blank">Java 集合常见知识点&amp;面试题总结(上)</a> (必看 👍)</li>
<li><a href="/java/collection/java-collection-questions-02.html" target="blank">Java 集合常见知识点&amp;面试题总结(下)</a> (必看 👍)</li>
<li><a href="/java/collection/java-collection-precautions-for-use.html" target="blank">Java 容器使用注意事项总结</a></li>
</ul>
<p><strong>源码分析</strong> ：</p>
<ul>
<li><a href="/java/collection/arraylist-source-code.html" target="blank">ArrayList 源码+扩容机制分析</a></li>
<li><a href="/java/collection/hashmap-source-code.html" target="blank">HashMap(JDK1.8)源码+底层数据结构分析</a></li>
<li><a href="/java/collection/concurrent-hash-map-source-code.html" target="blank">ConcurrentHashMap 源码+底层数据结构分析</a></li>
</ul>
<h3> IO</h3>
<ul>
<li><a href="/java/io/io-basis.html" target="blank">IO 基础知识总结</a></li>
<li><a href="/java/io/io-design-patterns.html" target="blank">IO 设计模式总结</a></li>
<li><a href="/java/io/io-model.html" target="blank">IO 模型详解</a></li>
</ul>
<h3> 并发</h3>
<p><strong>知识点/面试题总结</strong> : (必看 👍)</p>
<ul>
<li><a href="/java/concurrent/java-concurrent-questions-01.html" target="blank">Java 并发常见知识点&amp;面试题总结（上）</a></li>
<li><a href="/java/concurrent/java-concurrent-questions-02.html" target="blank">Java 并发常见知识点&amp;面试题总结（中）</a></li>
<li><a href="/java/concurrent/java-concurrent-questions-03.html" target="blank">Java 并发常见知识点&amp;面试题总结（下）</a></li>
</ul>
<p><strong>重要知识点详解</strong> ：</p>
<ul>
<li><a href="/java/concurrent/jmm.html" target="blank">JMM（Java 内存模型）详解</a></li>
<li><strong>线程池</strong> ：<a href="/java/concurrent/java-thread-pool-summary.html" target="blank">Java 线程池详解</a>、<a href="/java/concurrent/java-thread-pool-best-practices.html" target="blank">Java 线程池最佳实践</a></li>
<li><a href="/java/concurrent/threadlocal.html" target="blank">ThreadLocal 详解</a></li>
<li><a href="/java/concurrent/java-concurrent-collections.html" target="blank">Java 并发容器总结</a></li>
<li><a href="/java/concurrent/atomic-classes.html" target="blank">Atomic 原子类总结</a></li>
<li><a href="/java/concurrent/aqs.html" target="blank">AQS 详解</a></li>
<li><a href="/java/concurrent/completablefuture-intro.html" target="blank">CompletableFuture入门</a></li>
</ul>
<h3> JVM (必看 👍)</h3>
<p>JVM 这部分内容主要参考 <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html" target="_blank" rel="noopener noreferrer">JVM 虚拟机规范-Java8 </a> 和周志明老师的<a href="https://book.douban.com/subject/34907497/" target="_blank" rel="noopener noreferrer">《深入理解Java虚拟机（第3版）》</a> （强烈建议阅读多遍！）。</p>
<ul>
<li><strong><a href="/java/jvm/memory-area.html" target="blank">Java 内存区域</a></strong></li>
<li><strong><a href="/java/jvm/jvm-garbage-collection.html" target="blank">JVM 垃圾回收</a></strong></li>
<li><a href="/java/jvm/class-file-structure.html" target="blank">类文件结构</a></li>
<li><strong><a href="/java/jvm/class-loading-process.html" target="blank">类加载过程</a></strong></li>
<li><a href="/java/jvm/classloader.html" target="blank">类加载器</a></li>
<li><a href="/java/jvm/jvm-parameters-intro.html" target="blank">【待完成】最重要的 JVM 参数总结（翻译完善了一半）</a></li>
<li><a href="/java/jvm/jvm-intro.html" target="blank">【加餐】大白话带你认识 JVM</a></li>
<li><a href="/java/jvm/jdk-monitoring-and-troubleshooting-tools.html" target="blank">JDK 监控和故障处理工具</a></li>
</ul>
<h3> 新特性</h3>
<ul>
<li><strong>Java 8</strong> ：<a href="/java/new-features/java8-tutorial-translate.html" target="blank">Java 8 新特性总结（翻译）</a>、<a href="/java/new-features/java8-common-new-features.html" target="blank">Java8常用新特性总结</a></li>
<li><a href="/java/new-features/java9.html" target="blank">Java 9 新特性概览</a></li>
<li><a href="/java/new-features/java10.html" target="blank">Java 10 新特性概览</a></li>
<li><a href="/java/new-features/java11.html" target="blank">Java 11 新特性概览</a></li>
<li><a href="/java/new-features/java12-13.html" target="blank">Java 12~13 新特性概览</a></li>
<li><a href="/java/new-features/java14.html" target="blank">Java 14 新特性概览</a></li>
<li><a href="/java/new-features/java15.html" target="blank">Java 15 新特性概览</a></li>
<li><a href="/java/new-features/java16.html" target="blank">Java 16 新特性概览</a></li>
<li><a href="/java/new-features/java17.html" target="blank">Java 17 新特性概览</a></li>
<li><a href="/java/new-features/java18.html" target="blank">Java 18 新特性概览</a></li>
<li><a href="/java/new-features/java19.html" target="blank">Java 19 新特性概览</a></li>
</ul>
<h2> 计算机基础</h2>
<h3> 操作系统</h3>
<ul>
<li><a href="/cs-basics/operating-system/operating-system-basic-questions-01.html" target="blank">操作系统常见问题总结！</a></li>
<li><a href="/cs-basics/operating-system/linux-intro.html" target="blank">后端程序员必备的 Linux 基础知识总结</a></li>
<li><a href="/cs-basics/operating-system/shell-intro.html" target="blank">Shell 编程基础知识总结</a></li>
</ul>
<h3> 网络</h3>
<p><strong>知识点/面试题总结</strong> ：</p>
<ul>
<li><a href="/cs-basics/network/other-network-questions.html" target="blank">计算机网络常见知识点&amp;面试题总结</a></li>
<li><a href="/cs-basics/network/computer-network-xiexiren-summary.html" target="blank">谢希仁老师的《计算机网络》内容总结（补充）</a></li>
</ul>
<p><strong>重要知识点详解</strong> ：</p>
<ul>
<li><a href="/cs-basics/network/osi&amp;tcp-ip-model.html" target="blank">OSI 和 TCP/IP 网络分层模型详解（基础）</a></li>
<li><a href="/cs-basics/network/application-layer-protocol.html" target="blank">应用层常见协议总结（应用层）</a></li>
<li><a href="/cs-basics/network/http&amp;https.html" target="blank">HTTP vs HTTPS（应用层）</a></li>
<li><a href="/cs-basics/network/http1.0&amp;http1.1.html" target="blank">HTTP 1.0 vs HTTP 1.1（应用层）</a></li>
<li><a href="/cs-basics/network/http-status-codes.html" target="blank">HTTP 常见状态码（应用层）</a></li>
<li><a href="/cs-basics/network/tcp-connection-and-disconnection.html" target="blank">TCP 三次握手和四次挥手（传输层）</a></li>
<li><a href="/cs-basics/network/tcp-reliability-guarantee.html" target="blank">TCP 传输可靠性保障（传输层）</a></li>
<li><a href="/cs-basics/network/arp.html" target="blank">ARP 协议详解(网络层)</a></li>
</ul>
<h3> 数据结构</h3>
<p><strong>图解数据结构：</strong></p>
<ul>
<li><a href="/cs-basics/data-structure/linear-data-structure.html" target="blank">线性数据结构 :数组、链表、栈、队列</a></li>
<li><a href="/cs-basics/data-structure/graph.html" target="blank">图</a></li>
<li><a href="/cs-basics/data-structure/heap.html" target="blank">堆</a></li>
<li><a href="/cs-basics/data-structure/tree.html" target="blank">树</a> ：重点关注<a href="/cs-basics/data-structure/red-black-tree.html" target="blank">红黑树</a>、B-，B+，B*树、LSM树</li>
</ul>
<p>其他常用数据结构 ：</p>
<ul>
<li><a href="/cs-basics/data-structure/bloom-filter.html" target="blank">布隆过滤器</a></li>
</ul>
<h3> 算法</h3>
<p>算法这部分内容非常重要，如果你不知道如何学习算法的话，可以看下我写的：</p>
<ul>
<li><a href="https://www.zhihu.com/question/323359308/answer/1545320858" target="_blank" rel="noopener noreferrer">算法学习书籍+资源推荐</a> 。</li>
<li><a href="https://www.zhihu.com/question/31092580/answer/1534887374" target="_blank" rel="noopener noreferrer">如何刷Leetcode?</a></li>
</ul>
<p><strong>常见算法问题总结</strong> ：</p>
<ul>
<li><a href="/cs-basics/algorithms/string-algorithm-problems.html" target="blank">几道常见的字符串算法题总结 </a></li>
<li><a href="/cs-basics/algorithms/linkedlist-algorithm-problems.html" target="blank">几道常见的链表算法题总结 </a></li>
<li><a href="/cs-basics/algorithms/the-sword-refers-to-offer.html" target="blank">剑指 offer 部分编程题</a></li>
<li><a href="/cs-basics/algorithms/10-classical-sorting-algorithms.html" target="blank">十大经典排序算法</a></li>
</ul>
<p>另外，<a href="https://www.geeksforgeeks.org/fundamentals-of-algorithms/" target="_blank" rel="noopener noreferrer">GeeksforGeeks</a> 这个网站总结了常见的算法 ，比较全面系统。</p>
<h2> 数据库</h2>
<h3> 基础</h3>
<ul>
<li><a href="/database/basis.html" target="blank">数据库基础知识总结</a></li>
<li><a href="/database/character-set.html" target="blank">字符集详解</a></li>
</ul>
<h3> MySQL</h3>
<p><strong>知识点/面试题总结：</strong></p>
<ul>
<li><strong><a href="/database/mysql/mysql-questions-01.html" target="blank">MySQL知识点总结</a></strong> (必看 👍)</li>
<li><a href="/database/mysql/mysql-high-performance-optimization-specification-recommendations.html" target="blank">MySQL 高性能优化规范建议总结</a></li>
</ul>
<p><strong>重要知识点：</strong></p>
<ul>
<li><a href="/database/mysql/mysql-index.html" target="blank">MySQL数据库索引总结</a></li>
<li><a href="/database/mysql/transaction-isolation-level.html" target="blank">事务隔离级别(图文详解)</a></li>
<li><a href="/database/mysql/mysql-logs.html" target="blank">MySQL三大日志(binlog、redo log和undo log)详解</a></li>
<li><a href="/database/mysql/innodb-implementation-of-mvcc.html" target="blank">InnoDB存储引擎对MVCC的实现</a></li>
<li><a href="/database/mysql/how-sql-executed-in-mysql.html" target="blank">SQL语句在MySQL中的执行过程</a></li>
<li><a href="/database/mysql/some-thoughts-on-database-storage-time.html" target="blank">关于数据库中如何存储时间的一点思考</a></li>
<li><a href="/database/mysql/index-invalidation-caused-by-implicit-conversion.html" target="blank">MySQL中的隐式转换造成的索引失效</a></li>
</ul>
<h3> Redis</h3>
<p><strong>知识点/面试题总结</strong> : (必看👍 )：</p>
<ul>
<li><a href="/database/redis/redis-questions-01.html" target="blank">Redis 常见问题总结(上)</a></li>
<li><a href="/database/redis/redis-questions-02.html" target="blank">Redis 常见问题总结(下)</a></li>
</ul>
<p><strong>重要知识点：</strong></p>
<ul>
<li><a href="/database/redis/3-commonly-used-cache-read-and-write-strategies.html" target="blank">3种常用的缓存读写策略详解</a></li>
<li><a href="/database/redis/redis-data-structures-01.html" target="blank">Redis 5 种基本数据结构详解</a></li>
<li><a href="/database/redis/redis-data-structures-02.html" target="blank">Redis 3 种特殊数据结构详解</a></li>
<li><a href="/database/redis/redis-memory-fragmentation.html" target="blank">Redis 内存碎片详解</a></li>
<li><a href="/database/redis/redis-cluster.html" target="blank">Redis 集群详解</a></li>
</ul>
<h2> 搜索引擎</h2>
<p>用于提高搜索效率，功能和浏览器搜索引擎类似。比较常见的搜索引擎是 Elasticsearch（推荐） 和 Solr。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/gongzhonghaoxuanchuan.png" alt="JavaGuide 官方公众号"></p>
<h2> 开发工具</h2>
<h3> Docker</h3>
<ul>
<li><a href="/tools/docker/docker-intro.html" target="blank">Docker 基本概念解读</a></li>
<li><a href="/tools/docker/docker-in-action.html" target="blank">Docker从入门到上手干事</a></li>
</ul>
<h3> Git</h3>
<ul>
<li><a href="/tools/git/git-intro.html" target="blank">Git 入门</a></li>
<li><a href="/tools/git/github-tips.html" target="blank">Github 小技巧</a></li>
</ul>
<h2> 系统设计</h2>
<ul>
<li><a href="/system-design/system-design-questions.html" target="blank">系统设计常见面试题总结</a></li>
<li><a href="/system-design/design-pattern.html" target="blank">设计模式常见面试题总结</a></li>
</ul>
<h3> 基础</h3>
<ul>
<li><a href="/system-design/basis/RESTfulAPI.html" target="blank">RestFul API 简明教程</a></li>
<li><a href="/system-design/basis/naming.html" target="blank">Java 编码命名之道</a></li>
<li><a href="/system-design/basis/refactoring.html" target="blank">代码重构指南</a></li>
<li><a href="/system-design/basis/unit-test.html" target="blank">单元测试指南</a></li>
</ul>
<h3> 常用框架</h3>
<h4> Spring/SpringBoot (必看 👍)</h4>
<p><strong>知识点/面试题总结</strong> :</p>
<ul>
<li><a href="/system-design/framework/spring/spring-knowledge-and-questions-summary.html" target="blank">Spring 常见知识点&amp;面试题总结</a></li>
<li><a href="/system-design/framework/spring/springboot-knowledge-and-questions-summary.html" target="blank">SpringBoot 常见知识点&amp;面试题总结</a></li>
<li><a href="/system-design/framework/spring/spring-common-annotations.html" target="blank">Spring/Spring Boot 常用注解总结</a></li>
<li><a href="https://github.com/Snailclimb/springboot-guide" target="_blank" rel="noopener noreferrer">SpringBoot 入门指南</a></li>
</ul>
<p><strong>重要知识点详解</strong> ：</p>
<ul>
<li><a href="/system-design/framework/spring/spring-transaction.html" target="blank">Spring 事务详解</a></li>
<li><a href="/system-design/framework/spring/spring-design-patterns-summary.html" target="blank">Spring 中的设计模式详解</a></li>
<li><a href="/system-design/framework/spring/spring-boot-auto-assembly-principles.html" target="blank">SpringBoot 自动装配原理详解</a></li>
</ul>
<h4> MyBatis</h4>
<p><a href="/system-design/framework/mybatis/mybatis-interview.html" target="blank">MyBatis 常见面试题总结</a></p>
<h3> 安全</h3>
<h4> 认证授权</h4>
<ul>
<li><a href="/system-design/security/basis-of-authority-certification.html" target="blank">认证授权基础概念详解</a></li>
<li><a href="/system-design/security/jwt-intro.html" target="blank">JWT 基础概念详解</a></li>
<li><a href="/system-design/security/advantages&amp;disadvantages-of-jwt.html" target="blank">JWT 优缺点分析以及常见问题解决方案</a></li>
<li><a href="/system-design/security/sso-intro.html" target="blank">SSO 单点登录详解</a></li>
<li><a href="/system-design/security/design-of-authority-system.html" target="blank">权限系统设计详解</a></li>
</ul>
<h4> 数据脱敏</h4>
<p>数据脱敏说的就是我们根据特定的规则对敏感信息数据进行变形，比如我们把手机号、身份证号某些位数使用 * 来代替。</p>
<h4> 敏感词过滤</h4>
<p><a href="/system-design/security/sentive-words-filter.html" target="blank">敏感词过滤方案总结</a></p>
<h3> 定时任务</h3>
<p><a href="/system-design/schedule-task.html" target="blank">Java 定时任务详解</a></p>
<h3> Web 实时消息推送</h3>
<p><a href="/system-design/web-real-time-message-push.html" target="blank">Web 实时消息推送详解</a></p>
<h2> 分布式</h2>
<h3> 理论&amp;算法&amp;协议</h3>
<ul>
<li><a href="/distributed-system/theorem&amp;algorithm&amp;protocol/cap&amp;base-theorem.html" target="blank">CAP 理论和 BASE 理论解读</a></li>
<li><a href="/distributed-system/theorem&amp;algorithm&amp;protocol/paxos-algorithm.html" target="blank">Paxos 算法解读</a></li>
<li><a href="/distributed-system/theorem&amp;algorithm&amp;protocol/raft-algorithm.html" target="blank">Raft 算法解读</a></li>
</ul>
<h3> API 网关</h3>
<p><a href="/distributed-system/api-gateway.html" target="blank">API 网关详解</a></p>
<h3> 分布式 ID</h3>
<p><a href="/distributed-system/distributed-id.html" target="blank">分布式 ID 详解</a></p>
<h3> 分布式锁</h3>
<p><a href="/distributed-system/distributed-lock.html" target="blank">分布式锁详解</a></p>
<h3> 分布式事务</h3>
<p><a href="/distributed-system/distributed-transaction.html" target="blank">分布式事务详解</a></p>
<h3> 分布式配置中心</h3>
<p><a href="/distributed-system/distributed-configuration-center.html" target="blank">分布式配置中心详解</a></p>
<h3> RPC</h3>
<ul>
<li><a href="/distributed-system/rpc/rpc-intro.html" target="blank">RPC 基础常见知识点&amp;面试题总结</a></li>
<li><a href="/distributed-system/rpc/dubbo.html" target="blank">Dubbo 常见知识点&amp;面试题总结</a></li>
</ul>
<h3> ZooKeeper</h3>
<blockquote>
<p>前两篇文章可能有内容重合部分，推荐都看一遍。</p>
</blockquote>
<ul>
<li><a href="/distributed-system/distributed-process-coordination/zookeeper/zookeeper-intro.html" target="blank">ZooKeeper 相关概念总结(入门)</a></li>
<li><a href="/distributed-system/distributed-process-coordination/zookeeper/zookeeper-plus.html" target="blank">ZooKeeper 相关概念总结(进阶)</a></li>
<li><a href="/distributed-system/distributed-process-coordination/zookeeper/zookeeper-in-action.html" target="blank">ZooKeeper 实战</a></li>
</ul>
<h2> 高性能</h2>
<h3> 读写分离&amp;分库分表</h3>
<p><a href="/high-performance/read-and-write-separation-and-library-subtable.html" target="blank">读写分离&amp;分库分表详解</a></p>
<h3> 负载均衡</h3>
<p><a href="/high-performance/load-balancing.html" target="blank">负载均衡详解</a></p>
<h3> SQL 优化</h3>
<p><a href="/high-performance/sql-optimization.html" target="blank">常见 SQL 优化手段总结</a></p>
<h3> CDN</h3>
<p><a href="/high-performance/cdn.html" target="blank">CDN（内容分发网络）详解</a></p>
<h3> 消息队列</h3>
<p>消息队列在分布式系统中主要是为了解耦和削峰。相关阅读： <a href="/high-performance/message-queue/message-queue.html" target="blank">消息队列常见问题总结</a>。</p>
<ul>
<li><strong>RabbitMQ</strong> : <a href="/high-performance/message-queue/rabbitmq-intro.html" target="blank">RabbitMQ 基础知识总结</a>、<a href="/high-performance/message-queue/rabbitmq-questions.html" target="blank">RabbitMQ 常见面试题</a></li>
<li><strong>RocketMQ</strong> : <a href="/high-performance/message-queue/rocketmq-intro.html" target="blank">RocketMQ 基础知识总结</a>、<a href="/high-performance/message-queue/rocketmq-questions.html" target="blank">RocketMQ 常见面试题总结</a></li>
<li><strong>Kafka</strong> ：<a href="/high-performance/message-queue/kafka-questions-01.html" target="blank">Kafka 常见问题总结</a></li>
</ul>
<h2> 高可用</h2>
<p><a href="/high-availability/high-availability-system-design.html" target="blank">高可用系统设计指南</a></p>
<h3> 冗余设计</h3>
<p><a href="/high-availability/redundancy.html" target="blank">冗余设计详解</a></p>
<h3> 限流</h3>
<p><a href="/high-availability/limit-request.html" target="blank">服务限流详解</a></p>
<h3> 降级&amp;熔断</h3>
<p><a href="/high-availability/fallback&amp;circuit-breaker.html" target="blank">降级&amp;熔断详解</a></p>
<h3> 超时&amp;重试</h3>
<p><a href="/high-availability/timeout-and-retry.html" target="blank">超时&amp;重试详解</a></p>
<h3> 集群</h3>
<p>相同的服务部署多份，避免单点故障。</p>
<h3> 灾备设计和异地多活</h3>
<p><strong>灾备</strong>  = 容灾+备份。</p>
<ul>
<li><strong>备份</strong> ： 将系统所产生的的所有重要数据多备份几份。</li>
<li><strong>容灾</strong> ： 在异地建立两个完全相同的系统。当某个地方的系统突然挂掉，整个应用系统可以切换到另一个，这样系统就可以正常提供服务了。</li>
</ul>
<p><strong>异地多活</strong> 描述的是将服务部署在异地并且服务同时对外提供服务。和传统的灾备设计的最主要区别在于“多活”，即所有站点都是同时在对外提供服务的。异地多活是为了应对突发状况比如火灾、地震等自然或者人为灾害。</p>
<h2> Star 趋势</h2>
<p><img src="https://api.star-history.com/svg?repos=Snailclimb/JavaGuide&amp;type=Date" alt=""></p>
<h2> 公众号</h2>
<p>如果大家想要实时关注我更新的文章以及分享的干货的话，可以关注我的公众号“<strong>JavaGuide</strong>”。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/gongzhonghaoxuanchuan.png" alt="JavaGuide 官方公众号"></p>
]]></content:encoded>
      <enclosure url="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/gongzhonghaoxuanchuan.png" type="image/png"/>
    </item>
    <item>
      <title></title>
      <link>https://javaguide.cn/template.html</link>
      <guid>https://javaguide.cn/template.html</guid>
      <source url="https://javaguide.cn/rss.xml"></source>
      <description>title: Centos7.9安装Nginx category: 软件安装 author: xiaobai tag: nginx docker 安装基础软件 👉 日常博客文章，编写关于dokcer相关内容 👉 作者：小白 原文：https://blog.csdn.net/zhouqi1427/article/details/126061684</description>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<hr>
<p>title:  Centos7.9安装Nginx
category: 软件安装
author: xiaobai
tag:</p>
<ul>
<li>nginx</li>
</ul>
<hr>
<div class="hint-container tip">
<p class="hint-container-title">docker 安装基础软件</p>
<p>👉 日常博客文章，编写关于dokcer相关内容</p>
<p>👉 作者：小白</p>
</div>
<blockquote>
<p>原文：https://blog.csdn.net/zhouqi1427/article/details/126061684</p>
</blockquote>
<hr>
<p>内容</p>
]]></content:encoded>
    </item>
    <item>
      <title>害，毕业三年了！</title>
      <link>https://javaguide.cn/about-the-author/my-college-life.html</link>
      <guid>https://javaguide.cn/about-the-author/my-college-life.html</guid>
      <source url="https://javaguide.cn/rss.xml">害，毕业三年了！</source>
      <description>关于初高中的生活，可以看 2020年我写的我曾经也是网瘾少年这篇文章。 2019 年 6 月份毕业，距今已经过去了 3 年。趁着高考以及应届生毕业之际，简单聊聊自己的大学生活。 下面是正文。 我本科毕业于荆州校区的长江大学，一所不起眼的双非一本。</description>
      <category>走近作者</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>关于初高中的生活，可以看 2020年我写的<a href="https://javaguide.cn/about-the-author/internet-addiction-teenager.html" target="_blank" rel="noopener noreferrer">我曾经也是网瘾少年</a>这篇文章。</p>
</blockquote>
<p>2019 年 6 月份毕业，距今已经过去了 3 年。趁着高考以及应届生毕业之际，简单聊聊自己的大学生活。</p>
<p>下面是正文。</p>
<p>我本科毕业于荆州校区的长江大学，一所不起眼的双非一本。</p>
<p>在这里度过的四年大学生活还是过的挺开心的，直到现在，我依然非常怀念！</p>
<p>在学校的这几年的生活，总体来说，还算是比较丰富多彩的。我会偶尔通宵敲代码，也会偶尔半夜发疯跑出去和同学一起走走古城墙、去网吧锤一夜的 LOL。</p>
<p>写下这篇杂文，记录自己逝去的大学生活！希望未来继续砥砺前行，不忘初心！</p>
<h2> 大一</h2>
<p>大一那会，我没有把精力放在学习编程上，大部分时间都在参加课外活动。</p>
<p>或许是因为来到了一座新鲜的城市，对周围的一切都充满了兴趣。又或许是因为当时的我还比较懵懂，也没有任何学习方向。</p>
<p>这一年，我和班里的一群新同学去逛了荆州的很多地方比如荆州博物馆、长江大桥、张居正故居、关帝庙。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/about-the-author/college-life/41239dd7d18642f7af201292ead94f1a~tplv-k3u1fbpfcp-zoom-1.image.png" alt="大一的一次班级出行"></p>
<p>即使如此，我当时还是对未来充满了希望，憧憬着工作之后的生活。</p>
<p>我还记得当时我们 6 个室友那会一起聊天的时候，其他 5 个室友都觉得说未来找工作能找一个 6k 的就很不错了。我当时就说：“怎么得至少也要 8k 吧！”。他们无言，觉得我的想法太天真。</p>
<p>其实，我当时内心想的是至少是月薪 1w 起步，只是不太好意思直接说出来。</p>
<p>我不爱出风头，性格有点内向。刚上大学那会，内心还是有一点不自信，干什么事情都畏畏缩缩，还是迫切希望改变自己的！</p>
<p>于是，凭借着一腔热血，我尝试了很多我之前从未尝试过的事情：<strong>露营</strong>、<strong>户外烧烤</strong>、<strong>公交车演讲</strong>、<strong>环跑古城墙</strong>、<strong>徒步旅行</strong>、<strong>异地求生</strong>、<strong>圣诞节卖苹果</strong> 、<strong>元旦晚会演出</strong>...。</p>
<p>下面这些都是我和社团的小伙伴利用课外时间自己做的，在圣诞节那周基本都卖完了。我记得，为了能够多卖一些，我们还挨个去每一个寝室推销了一遍。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/about-the-author/college-life/7cf1a2da505249a58e1f29834dbac435~tplv-k3u1fbpfcp-zoom-1.image.png" alt=""></p>
<p>我还参加了大一元旦晚会，不过，那次演出我还是没放开，说实话，感觉没有表现出应该有的那味。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/about-the-author/college-life/850cae1f8c644c5d920140f66ae9303d~tplv-k3u1fbpfcp-zoom-1.image.png" alt=""></p>
<p>经过这次演出之后，我发现我是真的没有表演的天赋，很僵硬。并且，这种僵硬呆板是自己付出努力之后也没办法改变的。</p>
<p>下图是某一次社团聚餐，我喝的有点小醉之后，被朋友拍下的。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/about-the-author/college-life/82a503e365354bd1bf190540fbf1039a~tplv-k3u1fbpfcp-zoom-1.image.png" alt=""></p>
<p>那时候，还经常和和社团的几位小伙伴一起去夜走荆州古城墙。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/about-the-author/college-life/007a83e6d26c43b9aa6e0b0266c3314b~tplv-k3u1fbpfcp-zoom-1.image.png" alt="某一次要去夜走古城墙的路上我拍的"></p>
<p>不知道社团的大家现在过得怎么样呢？</p>
<p>虽然这些经历对于我未来的工作和发展其实没有任何帮助，但却让我的大学生活更加完整，经历了更多有趣的事情，有了更多可以回忆的经历。</p>
<p>我的室友们都窝在寝室玩游戏、玩手机的时候，我很庆幸自己做了这些事情。</p>
<p>个人感觉，大一的时候参加一些不错的社团活动，认识一些志同道合的朋友还是很不错的！</p>
<p><strong>参加课外活动之余，CS 专业的小伙伴，尽量早一点养成一个好的编程习惯，学好一门编程语言，然后平时没事就刷刷算法题。</strong></p>
<h3> 办补习班</h3>
<p>大一暑假的时候，我作为负责人，在孝感的小乡镇上办过 5 个补习班（本来是 7 个，后来砍掉了 2 个） 。</p>
<p>从租房子、租借桌椅再到招生基本都是从零开始做的。</p>
<p>每个周末我都会从荆州坐车跑到孝感，在各个县城之间来回跑。绝大部分时候，只有我一个人，偶尔也会有几个社团的小伙伴陪我一起。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/about-the-author/college-life/6ee6358c236144d8a8a205cc6bc99b9b~tplv-k3u1fbpfcp-zoom-1.image.png" alt=""></p>
<p>记忆犹新，那一年孝感也是闹洪水，还挺严重的。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/image-20210820201908759.png" alt=""></p>
<p>有一次我差点回不去学校参加期末考试。虽然没有备考，但是也没有挂过任何一门课，甚至很多科目考的还不错。不过，这还是对我绩点产生了比较大的影响，导致我后面没有机会拿到奖学金。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/about-the-author/college-life/3c5fe7af43ba4e348244df1692500fce~tplv-k3u1fbpfcp-zoom-1.image.png" alt=""></p>
<p>这次比较赶时间，所以就坐的是火车回学校。在火车上竟然还和别人撞箱子了！</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/about-the-author/college-life/570f5791aeb54fa1a76892b69e46fec2~tplv-k3u1fbpfcp-zoom-1.image.png" alt=""></p>
<p>当时去小乡镇上的时候，自己最差的时候住过 15 元的旅馆。真的是 15 元，你没看错。就那种老旧民房的小破屋，没有独卫，床上用品也很不卫生，还不能洗澡。</p>
<p>下面这个还是我住过最豪华的一个，因为当时坐客车去了孝感之后，突然下大雨，我就在车站附近找了一个相对便宜点的。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/about-the-author/college-life/687c3ede3f094c65a72d812ca0f06bb4~tplv-k3u1fbpfcp-zoom-1.image.png" alt=""></p>
<p>为了以更低的价钱租到房子，我经常和房东砍价砍的面红耳赤。</p>
<p>说句心里话，这些都是我不太愿意去做的事情，我本身属于比较爱面子而且不那么自信的人。</p>
<p>当时，我需要在各个乡镇来回跑，每天就直接顶着太阳晒 。每次吃饭都特别香，随便炒个蔬菜都能吃几碗米饭。</p>
<p>我本身是比较挑食的，这次经历让我真正体会到人饿了之后吃嘛嘛香!</p>
<p>我一个人给 6 个老师加上 10 来个学生和房东们一家做了一个多月的饭，我的厨艺也因此得到了很大的锻炼。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/about-the-author/college-life/2e3b6101abcd46a8a213c08782aeac33~tplv-k3u1fbpfcp-zoom-1.image.png" alt=""></p>
<p>这些学生有小学的，也有初中的，都比较听话。有很多还是留守儿童，爸爸妈妈在外打工，跟着爷爷奶奶一起生活。</p>
<p>加上我的话，我们一共有 4 位老师，我主要讲的是初中和高中的物理课。</p>
<p>学生们都挺听话，没有出现和我们几个老师闹过矛盾。只有两个调皮的小学生被我训斥之后，怀恨在心，写下了一些让我忍俊不禁的话！哈哈哈哈！太可爱了！</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/about-the-author/college-life/3680cead2c0f4165bb4865f038326b61~tplv-k3u1fbpfcp-zoom-1.image.png" alt=""></p>
<p>离开之前的前一天的晚上，我和老师们商量请一些近点的同学们来吃饭。我们一大早就出去买菜了，下图是做成后的成品。虽然是比较简单的一顿饭，但我们吃的特别香。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/about-the-author/college-life/f36bfd719b9b4463b2f1d3edc51faa97~tplv-k3u1fbpfcp-zoom-1.image.png" alt="补习班的最后一顿晚餐"></p>
<p>那天晚上还有几个家长专门跑过来看我做饭，家长们说他们的孩子非常喜欢我做的饭，哈哈哈！我表面淡然说自己做的不好，实则内心暗暗自喜，就很“闷骚”的一个人，哈哈哈！</p>
<p>不知道这些学生们，现在怎么样呢？怀念啊！</p>
<p>培训班结束，我回家之后，我爸妈都以为我是逃荒回来的。</p>
<h3> 自己赚钱去孤儿院</h3>
<p>大一尾声的时候，还做了一件非常有意义的事情。我和我的朋友们去了一次孤儿院（荆州私立孤儿教养院）。这个孤儿院曾经还被多家电视台报道过，目前也被百度百科收录。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/about-the-author/college-life/db8f5c276f4d4a7c9d7bd1e6100de301~tplv-k3u1fbpfcp-zoom-1.image.png" alt=""></p>
<p>孤儿院的孩子们，大多是一些无父无母或者本身有一些疾病被父母遗弃的孩子。</p>
<p>去之前，我们买了很多小孩子的玩具、文具、零食这些东西。这些钱的来源也比较有意义，都是我和社团的一些小伙伴自己去外面兼职赚的一些钱。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/about-the-author/college-life/cf43853c49bd489a9fc0ee437a2af432~tplv-k3u1fbpfcp-zoom-1.image.png" alt="离开之前和创建孤儿院的老爷爷的一张合照"></p>
<p>勿以善小而不为！引用《爱的风险》这首歌的一句歌词：“只要人人都献出一点爱，世界将变成美好的人间” 。</p>
<p>我想看看这个孤儿院的现状，于是在网上有搜了一下，看到了去年 1 月份荆州新闻网的一份报道。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/about-the-author/college-life/0ac27206389c498882dd7f6f440c6abb~tplv-k3u1fbpfcp-zoom-1.image.png" alt=""></p>
<p>孤儿教养院创办 33 年来，累计收养孤儿 85 人，其中有 5 人参军入伍报效祖国，20 人上大学，有的早已参加工作并成家立业。</p>
<p>叔叔也慢慢老了，白发越来越多。有点心酸，想哭，希望有机会再回去看看您！一定会的！</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/about-the-author/college-life/ea803a99c08149f892ca29e784653503~tplv-k3u1fbpfcp-zoom-1.image.png" alt=""></p>
<h3> 徒步旅行</h3>
<p>大一那会还有一件让我印象非常深刻的事情——徒步旅行。</p>
<p>我和一群社团的小伙伴，徒步走了接近 45 公里。我们从学校的西校区，徒步走到了枝江那边的一个沙滩。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/about-the-author/college-life/94ca5b6c5ea84dfb9e12b7a718587ea3~tplv-k3u1fbpfcp-zoom-1.image.png" alt=""></p>
<p>是真的全程步行，这还是我第一次走这么远。</p>
<p>走到目的地的时候，我的双腿已经不听使唤，脚底被磨了很多水泡。</p>
<p>我们在沙滩上露营，烧烤，唱歌跳舞，一直到第二天早上才踏上回学校的路程。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/about-the-author/college-life/8120d45d30254c908f9db20b3c00f514~tplv-k3u1fbpfcp-zoom-1.image.png" alt=""></p>
<h2> 大二</h2>
<p>到了大二，我开始把自己的重点转移到编程知识的学习上。</p>
<p>不过，我遇到一个让我比较纠结的问题：社团里玩的最好的几个朋友为了能让社团能继续延续下去，希望我和他们一起来继续带这个团队。</p>
<p>但是，我当时已经规划好了自己大二要做的事情，真的想把精力都放在编程学习上，想要好好沉淀一下自己的技术。</p>
<p>迫于无奈，我最终还是妥协，选择了和朋友一起带社团。毕竟，遇到几个真心的朋友属实不易！</p>
<h3> 带社团</h3>
<p>带社团确实需要花费很多业余时间，除了每周要从东校区打车到西校区带着他们跑步之外，我们还需要经常带着他们组织一些活动。</p>
<p>比如我们一起去了长江边上烧烤露营。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/about-the-author/college-life/8a6945ccc087017c1f96ee93f3af8178-20220608154206500.png" alt=""></p>
<p>再比如我们一起去环跑了古城墙。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/about-the-author/college-life/2cfba22049e8b99e11955bcb7662d790.png" alt=""></p>
<p>大学那会，我还是非常热爱运动的！</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/about-the-author/college-life/2dd503a60f814a7a953816bc3b5194cd~tplv-k3u1fbpfcp-zoom-1.image.png" alt=""></p>
<p>大二那会，我就已经环跑了 3 次古城墙。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/about-the-author/college-life/949543b550e847d5a7314b7e1842489b~tplv-k3u1fbpfcp-zoom-1.image.png" alt=""></p>
<h3> 加入长大在线</h3>
<p>在大二的时候，我还加入了学校党委宣传部下的组织——长大在线。这是一个比较偏技术性质的组织，主要负责帮学校做做网站、APP 啥的。</p>
<p>在百度上，还能搜索到长大在线的词条。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/about-the-author/college-life/34ecf650120a4289a68b7549eb7d00cc~tplv-k3u1fbpfcp-zoom-1.image.png" alt=""></p>
<p>莫名其妙还被发了一个记者证，哈哈哈！</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/about-the-author/college-life/image-20220606121111042.png" alt=""></p>
<p>我选的是安卓组，然后我就开始了学习安卓开发的旅程。</p>
<p>刚加入这个组织的时候，我连 HTML、CSS、JS、Java、Linux 这些名词都不知道啥意思。</p>
<p>再到后面，我留下来当了副站长，继续为组织服务了大半年多。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/about-the-author/college-life/image-20220608121413761.png" alt=""></p>
<h3> 第一次参加比赛</h3>
<p>那会也比较喜欢去参加一些学校的比赛，也获得过一些不错的名次，让我印象最深的是一次 PPT 大赛，这也是我第一次参加学校的比赛。</p>
<p>参加比赛之前，自己也是一个 PPT 小白，苦心学了一周多之后，我的一个作品竟然顺利获得了第一名。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/about-the-author/college-life/image-20220608121446529.png" alt=""></p>
<p>也正是因为这次比赛，我免费拥有了自己的第一个机械键盘，这个键盘陪我度过了后面的大学生活。</p>
<h3> 确定技术方向</h3>
<p>在大二上学期末，我最终确定了自己以后要走的技术方向是走 Java 后端。于是，我就开始制定学习计划，开始了自己的 Java 后端领域的打怪升级之路。</p>
<p>每次忙到很晚，一个人走在校园的时候还是很爽的！非常喜欢这种安静的感觉。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/about-the-author/college-life/336fd489ce314d259d6090194f237e1b~tplv-k3u1fbpfcp-zoom-1.image.png" alt=""></p>
<p>当时身体素质真好，熬夜之后第二天照常起来上课学习。现在熬个夜，后面两天直接就废了！</p>
<p>到了大三，我基本把 Java 后端领域一些必备的技术都给过了一遍，还用自己学的东西做了两个实战项目。</p>
<p>由于缺少正确的人指导，我当时学的时候也走了很多弯路，浪费了不少时间（我很羡慕大家能有我，就很厚脸皮！）。</p>
<p>那个时候还贼自恋，没事就喜欢自拍一张。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/about-the-author/college-life/image-20210820202341008.png" alt=""></p>
<p>国庆节的时候也不回家，继续在学校刷 Java 视频和书籍。</p>
<p>我记得那次国庆节的时候效率还是非常高的，学习起来也特别有动力。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/about-the-author/college-life/WX20210820-203458.png" alt=""></p>
<h2> 大三</h2>
<p>整个大三，我依然没有周末，基本没有什么娱乐时间。绝大部分时间都是一个人在寝室默默学习，平时偶尔也会去图书馆和办公室。</p>
<p>虽然室友经常会玩游戏和看剧什么的，但是我对我并没有什么影响。一个人戴上耳机之后，世界仿佛都是自己的。</p>
<p>和很多大佬可能不太一样，比起图书馆和办公室，我在寝室的学习效率更高一些。</p>
<h3> JavaGuide 诞生</h3>
<p>我的开源项目 JavaGuide 和公众号都是这一年启动的。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/about-the-author/college-life/the-birth-of-javaguide.jpeg" alt=""></p>
<p>目前的话，JavaGuide 也已经 100k star ，我的公众号也已经有 15w+ 的关注。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/about-the-author/college-life/image-20210820211926742.png" alt=""></p>
<h3> 接私活赚钱</h3>
<p>一些机遇也让我这一年也接了一些私活赚钱。为了能够顺利交付，偶尔也会熬夜。当时的心态是即使熬夜也还是很开心、充实。每次想到自己通过技术赚到了钱，就会非常有动力。</p>
<p>我也曾写过文章分享过接私活的经历：<a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247499539&amp;idx=1&amp;sn=ff153f9bd98bb3109b1f14e58ed9a785&amp;chksm=cea1b0d8f9d639cee4744f845042df6b1fc319f4383b87eba76a944c2648c81a51c28d25e3b6&amp;token=2114015135&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">唠唠嗑！大学那会接私活赚了 3w+</a> 。</p>
<p>不过，我接的几个私活也是比较杂的，并不太适合作为简历上的项目经历。</p>
<p>于是，为了能让简历上的项目经历看着更好看一些，我自己也找了两个项目做。一个是我跟着视频一起做的，是一个商城类型的项目。另外一个是自己根据自己的想法做的，是一个视频网站类型的项目。</p>
<p>商城类型的项目大概的架构图如下（没有找到当时自己画的原图）：</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/about-the-author/college-life/206fab84bf5b4c048f8a88bc68c942f6~tplv-k3u1fbpfcp-zoom-1.image.png" alt=""></p>
<p>那会商城项目貌似也已经烂大街了，用的人比较多。为了让自己的商城项目更有竞争力，对照着视频教程做完之后，我加入了很多自己的元素比如更换消息队列 ActiveMQ 为 Kafka、增加二级缓存。</p>
<p>在暑假的时候，还和同学老师一起做了一个员工绩效管理的企业真实项目。这个项目和我刚进公司做的项目，非常非常相似，不过公司做得可能更高级点 ，代码质量也要更高一些。实在是太巧了！</p>
<p>我记得当时自己独立做项目的时候，遇到了很多问题。<strong>就很多时候，你看书很容易就明白的东西，等到你实践的时候，总是会遇到一些小问题。我一般都是通过 Google 搜索解决的，用好搜索引擎真的能解决自己 99% 的问题。</strong></p>
<h3> 参加软件设计大赛</h3>
<p>大三这一年也有遗憾吧！我和几位志同道合的朋友一起参加过一个软件设计大赛，我们花了接近两个月做的系统顺利进入了复赛。</p>
<p>不过，我后面因为自己个人觉得再花时间做这个系统学不到什么东西还浪费时间就直接退出了。然后，整个团队就散了。</p>
<p>其实，先来回头看也是可以学到东西的，自己当时的心态有点飘了吧，心态有一些好高骛远。</p>
<p>现在想来，还是挺对不起那些一起奋斗到深夜的小伙伴。</p>
<p>人生就是这样，一生很长，任何时候你回头看过去的自己，肯定都会有让自己后悔的事情。</p>
<h3> 放弃读研</h3>
<p>当时，我也有纠结过是否读研，毕竟学校确实一般，读个研确实能够镀点金，提升一下学历。</p>
<p>不过，我最终还是放弃了读研。当时比较自信，心里就觉得自己不需要读研也能够找到好工作。</p>
<h3> 实习</h3>
<p>大三还找了一家离学校不远的公司实习，一位老学长创办的。不过，说实话哈，总体实习体验很差，没有学到什么东西不说，还耽误了自己很多已经计划好的事情。</p>
<p>我记得当时这个公司很多项目还是在用 JSP，用的技术很老。如果是老项目还好，我看几个月前启动的项目也还是用的 JSP，就很离谱。。。</p>
<p>当时真的很难受，而且一来就想着让你上手干活，活还贼多，干不完还想让你免费加班。。。</p>
<p>当时也没办法，因为荆州实在是找不到其他公司可以让你实习，你又没办法跑到其他城市去实习。这也是放弃选择一二线城市的学校带来的问题吧！</p>
<h2> 大四</h2>
<h3> 开始找工作</h3>
<p>找实习找工作时候，才知道大学所在的城市的重要性。</p>
<p>由于，我的学校在荆州，而且本身学校就很一般，因此，基本没有什么比较好的企业来招人。</p>
<p>当时，唯一一个还算可以的就是苏宁，不过，我遇到的那个苏宁的 HR 还挺恶心的，第一轮面试的时候就开始压薪资了，问我能不能加班。然后，我也就对苏宁没有了想法。</p>
<p>秋招我犯了一个比较严重的问题，那就是投递简历开始的太晚。我是把学校的项目差不多做完之后，才开始在网上投递简历。这个时候，暑假差不多已经结束了，秋招基本已经尾声了。</p>
<p>可能也和学校环境有一些关系，当时，身边的同学没有参加秋招的。大三暑假的时候，都跑去搞学院组织的实习。我是留在学校做项目，没有去参加那次实习。</p>
<p>我觉得学校还是非常有必要提醒学生们把握住秋招这次不错的机会的！</p>
<p>在网上投递了一些简历之后，很多笔试我觉得做的还可以的都没有回应。</p>
<p>我有点慌了！于是，我就从荆州来到武汉，想在武大华科这些不错的学校参加一些宣讲会。</p>
<p>到了武汉之后，我花了一天时间找了一个蛋壳公寓住下。第二天，我就跑去武汉理工大学参加宣讲会。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/about-the-author/college-life/image-20210820204919942.png" alt=""></p>
<p>当天，我就面试了自己求职过程中的第一家公司—<strong>玄武科技</strong>。</p>
<p>就是这样一家中小型的公司，当时来求职面试的很多都是武大华科的学生。不过，他们之中一定有很多人和我一样，就是单纯来刷一波经验，找找信心。</p>
<p>整个过程也就持续了 3 天左右，我就顺利的拿下了玄武科技的 offer。不过，最终没有签约。</p>
<h3> 拿到 Offer</h3>
<p>来武汉之前，我实际上已经在网上投递了 <strong>ThoughtWorks</strong>，并且，作业也已经通过了。</p>
<p>当时，我对 ThoughtWorks 是最有好感的，内心的想法就是：“拿下了 ThoughtWorks，就不再面试其他公司了”。</p>
<p>奈何 ThoughtWorks 的进度太慢，担心之余，才来武汉面试其他公司留个保底。</p>
<p>不过，我最终如愿以偿获得了 ThoughtWorks 的 offer。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/about-the-author/college-life/9ad97dcc5038499b96239dd826c471b7~tplv-k3u1fbpfcp-zoom-1.image.png" alt=""></p>
<p>面试 ThoughtWorks 的过程就不多说了，我在<a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247484842&amp;idx=1&amp;sn=4489dfab0ef2479122b71407855afc71&amp;chksm=cea24a61f9d5c3774a8ed67c5fcc3234cb0741fbe831152986e5d1c8fb4f36a003f4fb2f247e&amp;scene=178&amp;cur_album_id=1323354342556057602#rd" target="_blank" rel="noopener noreferrer">《结束了我短暂的秋招，说点自己的感受》</a>这篇文章中有提到。</p>
<h2> 几点建议</h2>
<p>说几点自己的建议，虽然我不优秀，但毕竟你可以更优秀：</p>
<ol>
<li>确定好自己的方向，搞清你是要考研还是要找工作。如果你要考研的话，好好上每一门可能是考研的科目，平时有时间也要敲代码，最好也能做一个项目，对你复试还有能力提升都有帮助。找工作的话，尽早确定好自己的方向，心里有一个规划，搞清自己的优势和劣势。</li>
<li>尽可能早一点以求职为导向来学习，这样更有针对性，并且可以大概率减己处在迷茫的时间，很大程度上还可以让自己少走很多弯路。</li>
<li>自学很重要，养成自学的习惯，学会学习。</li>
<li>不要觉得逃课就是坏学生。我大学逃了很多课，逃课的大部分时间都是在学自己觉得更重要的东西，逃的大部分也是不那么重要并且不会影响我毕业的课。</li>
<li>大学恋爱还是相对来说很纯粹的，遇到合适的可以尝试去了解一下， 别人不喜欢你的话不要死缠烂打，这种东西强求不来。你不得不承认，你了解一个人欲望还是始于他的长相而并不是有趣的灵魂。</li>
<li>管理自己的身材，没事去跑跑步，别当油腻男。</li>
<li>别太看重绩点。我觉得绩点对于找工作还有考研实际的作用都可以忽略不计，不过不挂科还是比较重要的。但是，绩点确实在奖学金评选和保研名额选取上占有最大的分量。</li>
<li>别太功利性。做事情以及学习知识都不要奢求它能立马带给你什么，坚持和功利往往是成反比的。</li>
<li>......</li>
</ol>
<h2> 后记</h2>
<p>我们在找工作的过程中难免会遇到卡学历的情况，特别是我们这种学校本身就比较一般的。我觉得这真的不可厚非，没有什么不公平，要怪就只能怪自己没有考上好的学校。</p>
<p><strong>考虑到招聘成本和时间，公司一定更愿意在学校本身比较好的人中选拔人才。</strong></p>
<p>我也曾抱怨过自己为什么不在 211 或者 985 的学校。但，其实静下心来想一想，本来考不上 211 或者 985 就是自己的问题，而且在我们计算机这个领域，学历本身就相对于其他专业稍微要更加公平一点。</p>
<p>我身边专科、三本毕业就进大厂的人也比比皆是。我这句话真不是鸡汤，为了鼓励一些学校出身不太好的朋友。</p>
<p><strong>多行动，少抱怨。</strong></p>
]]></content:encoded>
      <enclosure url="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/about-the-author/college-life/41239dd7d18642f7af201292ead94f1a~tplv-k3u1fbpfcp-zoom-1.image.png" type="image/png"/>
    </item>
    <item>
      <title>个人介绍 Q&amp;A</title>
      <link>https://javaguide.cn/about-the-author/</link>
      <guid>https://javaguide.cn/about-the-author/</guid>
      <source url="https://javaguide.cn/rss.xml">个人介绍 Q&amp;A</source>
      <description>这篇文章我会通过 Q&amp;amp;A 的形式简单介绍一下我自己。 我是什么时候毕业的？ 很多老读者应该比较清楚，我是 19 年本科毕业的，刚毕业就去了某家外企“养老”。 我的学校背景是比较差的，高考失利，勉强过了一本线 20 来分，去了荆州的一所很普通的双非一本。不过，还好我没有因为学校而放弃自己，反倒是比身边的同学都要更努力，整个大学还算过的比较充实。 下面这张是当时拍的毕业照（后排最中间的就是我）：</description>
      <category>走近作者</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<p>这篇文章我会通过 Q&amp;A 的形式简单介绍一下我自己。</p>
<h2> 我是什么时候毕业的？</h2>
<p>很多老读者应该比较清楚，我是 19 年本科毕业的，刚毕业就去了某家外企“养老”。</p>
<p>我的学校背景是比较差的，高考失利，勉强过了一本线 20 来分，去了荆州的一所很普通的双非一本。不过，还好我没有因为学校而放弃自己，反倒是比身边的同学都要更努力，整个大学还算过的比较充实。</p>
<p>下面这张是当时拍的毕业照（后排最中间的就是我）：</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/个人介绍.png" alt=""></p>
<h2> 我坚持写了多久博客？</h2>
<p>时间真快啊！我自己是从大二开始写博客的。那时候就是随意地在博客平台上发发自己的学习笔记和自己写的程序。就比如 <a href="https://javaguide.cn/cs-basics/network/%E8%B0%A2%E5%B8%8C%E4%BB%81%E8%80%81%E5%B8%88%E7%9A%84%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%8B%E5%86%85%E5%AE%B9%E6%80%BB%E7%BB%93/" target="_blank" rel="noopener noreferrer">谢希仁老师的《计算机网络》内容总结</a> 这篇文章就是我在大二学习计算机网络这门课的时候对照着教材总结的。</p>
<p>身边也有很多小伙伴经常问我：“我现在写博客还晚么？”</p>
<p>我觉得哈！如果你想做什么事情，尽量少问迟不迟，多问自己值不值得，只要你觉得有意义，就尽快开始做吧！人生很奇妙，我们每一步的重大决定，都会对自己未来的人生轨迹产生影响。是好还是坏，也只有我们自己知道了！</p>
<p>对我自己来说，坚持写博客这一项决定对我人生轨迹产生的影响是非常正面的！所以，我也推荐大家养成坚持写博客的习惯。</p>
<h2> 我在大学期间赚了多少钱？</h2>
<p>在校期间，我还通过办培训班、接私活、技术培训、编程竞赛等方式变现 20w+，成功实现“经济独立”。我用自己赚的钱去了重庆、三亚、恩施、青岛等地旅游，还给家里补贴了很多，减轻了父母的负担。</p>
<p>下面这张是我大一下学期办补习班的时候拍的（离开前的最后一顿饭）：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f36bfd719b9b4463b2f1d3edc51faa97~tplv-k3u1fbpfcp-zoom-1.image" alt="补习班的最后一顿晚餐"></p>
<p>下面这张是我大三去三亚的时候拍的：</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/psc.jpeg" alt=""></p>
<p>其实，我在大学就这么努力地开始赚钱，也主要是因为家庭条件太一般，父母赚钱都太辛苦了！也正是因为我自己迫切地想要减轻父母的负担，所以才会去尝试这么多赚钱的方法。</p>
<p>我发现做咱们程序员这行的，很多人的家庭条件都挺一般的，选择这个行业的很大原因不是因为自己喜欢，而是为了多赚点钱。</p>
<p>如果你也想通过接私活变现的话，可以在我的公众号后台回复“<strong>接私活</strong>”来了解一些我的个人经验分享。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2020-8/1d38ea3b-da2a-41df-9ac4-087356e9b5b4-20200802185910087.png" alt=""></p>
<h2> 为什么自称 Guide哥？</h2>
<p>可能是因为我的项目名字叫做 JavaGuide , 所以导致有很多人称呼我为 <strong>Guide哥</strong>。</p>
<p>后面，为了读者更方便称呼，我就将自己的笔名改成了 <strong>Guide哥</strong>。</p>
<p>我早期写文章用的笔名是 SnailClimb 。很多人不知道这个名字是啥意思，给大家拆解一下就清楚了。SnailClimb=Snail（蜗牛）+Climb(攀登)。我从小就非常喜欢听周杰伦的歌曲，特别是他的《蜗牛》🐌 这首歌曲，另外，当年我高考发挥的算是比较失常，上了大学之后还算是比较“奋青”，所以，我就给自己起的笔名叫做 SnailClimb ，寓意自己要不断向上攀登，嘿嘿😁</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/37599546f3b34b92a32db579a225aa45~tplv-k3u1fbpfcp-watermark.image" alt=""></p>
<h2> 后记</h2>
<p>凡心所向，素履所往，生如逆旅，一苇以航。</p>
<p>生活本就是有苦有甜。共勉！</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/gongzhonghaoxuanchuan.png" alt="JavaGuide 官方公众号"></p>
]]></content:encoded>
      <enclosure url="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/%E4%B8%AA%E4%BA%BA%E4%BB%8B%E7%BB%8D.png" type="image/png"/>
    </item>
    <item>
      <title>计算机基础必读经典书籍</title>
      <link>https://javaguide.cn/books/cs-basics.html</link>
      <guid>https://javaguide.cn/books/cs-basics.html</guid>
      <source url="https://javaguide.cn/rss.xml">计算机基础必读经典书籍</source>
      <description>考虑到很多同学比较喜欢看视频，因此，这部分内容我不光会推荐书籍，还会顺便推荐一些我觉得不错的视频教程和各大高校的 Project。 操作系统 为什么要学习操作系统？</description>
      <category>计算机书籍</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<p>考虑到很多同学比较喜欢看视频，因此，这部分内容我不光会推荐书籍，还会顺便推荐一些我觉得不错的视频教程和各大高校的 Project。</p>
<h2> 操作系统</h2>
<p><strong>为什么要学习操作系统？</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20210406152847824.png" alt=""></p>
]]></content:encoded>
      <enclosure url="https://img-blog.csdnimg.cn/20210406152847824.png" type="image/png"/>
    </item>
    <item>
      <title>技术书籍精选</title>
      <link>https://javaguide.cn/books/</link>
      <guid>https://javaguide.cn/books/</guid>
      <source url="https://javaguide.cn/rss.xml">技术书籍精选</source>
      <description>这是一则或许对你有用的小广告 👉 欢迎准备 Java 面试以及学习 Java 的同学加入我的知识星球，干货很多！收费虽然是白菜价，但星球里的内容或许比你参加上万的培训班质量还要高。 👉 《Java 面试指北》持续更新完善中！这是一份教你如何更高效地准备面试的小册，涵盖常见八股文（系统设计、常见框架、分布式、高并发 ......）、优质面经等内容。</description>
      <category>计算机书籍</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<div class="hint-container tip">
<p class="hint-container-title">这是一则或许对你有用的小广告</p>
<p>👉 欢迎准备 Java 面试以及学习 Java 的同学加入我的<a href="/about-the-author/zhishixingqiu-two-years.html" target="blank">知识星球</a>，干货很多！收费虽然是白菜价，但星球里的内容或许比你参加上万的培训班质量还要高。</p>
<p>👉 <a href="/zhuanlan/java-mian-shi-zhi-bei.html" target="blank">《Java 面试指北》</a>持续更新完善中！这是一份教你如何更高效地准备面试的小册，涵盖常见八股文（系统设计、常见框架、分布式、高并发 ......）、优质面经等内容。</p>
</div>
<p>精选优质计算机书籍。</p>
<p>开源的目的是为了大家能一起完善，如果你觉得内容有任何需要完善/补充的地方，欢迎大家在项目 <a href="https://github.com/CodingDocs/awesome-cs/issues" target="_blank" rel="noopener noreferrer">issues 区</a> 推荐自己认可的技术书籍，让我们共同维护一个优质的技术书籍精选集！</p>
<ul>
<li>Github 地址：<a href="https://github.com/CodingDocs/awesome-cs" target="_blank" rel="noopener noreferrer">https://github.com/CodingDocs/awesome-cs</a></li>
<li>Gitee 地址：<a href="https://gitee.com/SnailClimb/awesome-cs" target="_blank" rel="noopener noreferrer">https://gitee.com/SnailClimb/awesome-cs</a></li>
</ul>
<p>如果内容对你有帮助的话，欢迎给本项目点个 Star。我会用我的业余时间持续完善这份书单，感谢！</p>
<p>本项目推荐的大部分书籍的 PDF 版本我已经整理到了云盘里，你可以在公众号“<strong>Github掘金计划</strong>” 后台回复“<strong>书籍</strong>”获取到。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/booksimage-20220409153638398.png" alt=""></p>
]]></content:encoded>
      <enclosure url="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/booksimage-20220409153638398.png" type="image/png"/>
    </item>
    <item>
      <title>数据库基础知识总结</title>
      <link>https://javaguide.cn/database/basis.html</link>
      <guid>https://javaguide.cn/database/basis.html</guid>
      <source url="https://javaguide.cn/rss.xml">数据库基础知识总结</source>
      <description>数据库知识基础，这部分内容一定要理解记忆。虽然这部分内容只是理论知识，但是非常重要，这是后面学习 MySQL 数据库的基础。PS: 这部分内容由于涉及太多概念性内容，所以参考了维基百科和百度百科相应的介绍。 什么是数据库, 数据库管理系统, 数据库系统, 数据库管理员? 数据库 : 数据库(DataBase 简称 DB)就是信息的集合或者说数据库是由数据库管理系统管理的数据的集合。 数据库管理系统 : 数据库管理系统(Database Management System 简称 DBMS)是一种操纵和管理数据库的大型软件，通常用于建立、使用和维护数据库。 数据库系统 : 数据库系统(Data Base System，简称 DBS)通常由软件、数据库和数据管理员(DBA)组成。 数据库管理员 : 数据库管理员(Database Administrator, 简称 DBA)负责全面管理和控制数据库系统。</description>
      <category>数据库</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<p>数据库知识基础，这部分内容一定要理解记忆。虽然这部分内容只是理论知识，但是非常重要，这是后面学习 MySQL 数据库的基础。PS: 这部分内容由于涉及太多概念性内容，所以参考了维基百科和百度百科相应的介绍。</p>
<h2> 什么是数据库, 数据库管理系统, 数据库系统, 数据库管理员?</h2>
<ul>
<li><strong>数据库</strong> : 数据库(DataBase 简称 DB)就是信息的集合或者说数据库是由数据库管理系统管理的数据的集合。</li>
<li><strong>数据库管理系统</strong> : 数据库管理系统(Database Management System 简称 DBMS)是一种操纵和管理数据库的大型软件，通常用于建立、使用和维护数据库。</li>
<li><strong>数据库系统</strong> : 数据库系统(Data Base System，简称 DBS)通常由软件、数据库和数据管理员(DBA)组成。</li>
<li><strong>数据库管理员</strong> : 数据库管理员(Database Administrator, 简称 DBA)负责全面管理和控制数据库系统。</li>
</ul>
<p>数据库系统基本构成如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/e21120184e63406526a4e873cacd23f2.png" alt="数据库系统基本构成"></p>
<h2> 什么是元组, 码, 候选码, 主码, 外码, 主属性, 非主属性？</h2>
<ul>
<li><strong>元组</strong> ： 元组（tuple）是关系数据库中的基本概念，关系是一张表，表中的每行（即数据库中的每条记录）就是一个元组，每列就是一个属性。 在二维表里，元组也称为行。</li>
<li><strong>码</strong> ：码就是能唯一标识实体的属性，对应表中的列。</li>
<li><strong>候选码</strong> ： 若关系中的某一属性或属性组的值能唯一的标识一个元组，而其任何、子集都不能再标识，则称该属性组为候选码。例如：在学生实体中，“学号”是能唯一的区分学生实体的，同时又假设“姓名”、“班级”的属性组合足以区分学生实体，那么{学号}和{姓名，班级}都是候选码。</li>
<li><strong>主码</strong> : 主码也叫主键。主码是从候选码中选出来的。 一个实体集中只能有一个主码，但可以有多个候选码。</li>
<li><strong>外码</strong> : 外码也叫外键。如果一个关系中的一个属性是另外一个关系中的主码则这个属性为外码。</li>
<li><strong>主属性</strong> ： 候选码中出现过的属性称为主属性。比如关系 工人（工号，身份证号，姓名，性别，部门）. 显然工号和身份证号都能够唯一标示这个关系，所以都是候选码。工号、身份证号这两个属性就是主属性。如果主码是一个属性组，那么属性组中的属性都是主属性。</li>
<li><strong>非主属性：</strong> 不包含在任何一个候选码中的属性称为非主属性。比如在关系——学生（学号，姓名，年龄，性别，班级）中，主码是“学号”，那么其他的“姓名”、“年龄”、“性别”、“班级”就都可以称为非主属性。</li>
</ul>
<h2> 主键和外键有什么区别?</h2>
<ul>
<li><strong>主键(主码)</strong> ：主键用于唯一标识一个元组，不能有重复，不允许为空。一个表只能有一个主键。</li>
<li><strong>外键(外码)</strong> ：外键用来和其他表建立联系用，外键是另一表的主键，外键是可以有重复的，可以是空值。一个表可以有多个外键。</li>
</ul>
<h2> 为什么不推荐使用外键与级联？</h2>
<p>对于外键和级联，阿里巴巴开发手册这样说到：</p>
<blockquote>
<p>【强制】不得使用外键与级联，一切外键概念必须在应用层解决。</p>
<p>说明: 以学生和成绩的关系为例，学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，即为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群; 级联更新是强阻塞，存在数据库更新风暴的风 险; 外键影响数据库的插入速度</p>
</blockquote>
<p>为什么不要用外键呢？大部分人可能会这样回答：</p>
<blockquote>
<ol>
<li><strong>增加了复杂性：</strong> a. 每次做DELETE 或者UPDATE都必须考虑外键约束，会导致开发的时候很痛苦, 测试数据极为不方便; b. 外键的主从关系是定的，假如那天需求有变化，数据库中的这个字段根本不需要和其他表有关联的话就会增加很多麻烦。</li>
<li><strong>增加了额外工作</strong>： 数据库需要增加维护外键的工作，比如当我们做一些涉及外键字段的增，删，更新操作之后，需要触发相关操作去检查，保证数据的的一致性和正确性，这样会不得不消耗资源；（个人觉得这个不是不用外键的原因，因为即使你不使用外键，你在应用层面也还是要保证的。所以，我觉得这个影响可以忽略不计。）</li>
<li><strong>对分库分表不友好</strong> ：因为分库分表下外键是无法生效的。</li>
<li>......</li>
</ol>
</blockquote>
<p>我个人觉得上面这种回答不是特别的全面，只是说了外键存在的一个常见的问题。实际上，我们知道外键也是有很多好处的，比如：</p>
<ol>
<li>保证了数据库数据的一致性和完整性；</li>
<li>级联操作方便，减轻了程序代码量；</li>
<li>......</li>
</ol>
<p>所以说，不要一股脑的就抛弃了外键这个概念，既然它存在就有它存在的道理，如果系统不涉及分库分表，并发量不是很高的情况还是可以考虑使用外键的。</p>
<h2> 什么是 ER 图？</h2>
<blockquote>
<p>我们做一个项目的时候一定要试着画 ER 图来捋清数据库设计，这个也是面试官问你项目的时候经常会被问道的。</p>
</blockquote>
<p><strong>E-R 图</strong> 也称实体-联系图(Entity Relationship Diagram)，提供了表示实体类型、属性和联系的方法，用来描述现实世界的概念模型。 它是描述现实世界关系概念模型的有效方法。 是表示概念关系模型的一种方式。</p>
<p>下图是一个学生选课的 ER 图，每个学生可以选若干门课程，同一门课程也可以被若干人选择，所以它们之间的关系是多对多（M: N）。另外，还有其他两种关系是：1 对 1（1:1）、1 对多（1: N）。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/4717673e36966e0e4b33fccfd753f6ea.png" alt="ER图示例"></p>
<p>我们试着将上面的 ER 图转换成数据库实际的关系模型(实际设计中，我们通常会将任课教师也作为一个实体来处理)：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/5897753dfb301dfa3a814ab06e718a5e.png" alt="关系模型"></p>
<h2> 数据库范式了解吗?</h2>
<p><strong>1NF(第一范式)</strong></p>
<p>属性（对应于表中的字段）不能再被分割，也就是这个字段只能是一个值，不能再分为多个其他的字段了。<strong>1NF 是所有关系型数据库的最基本要求</strong> ，也就是说关系型数据库中创建的表一定满足第一范式。</p>
<p><strong>2NF(第二范式)</strong></p>
<p>2NF 在 1NF 的基础之上，消除了非主属性对于码的部分函数依赖。如下图所示，展示了第一范式到第二范式的过渡。第二范式在第一范式的基础上增加了一个列，这个列称为主键，非主属性都依赖于主键。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/bd1d31be3779342427fc9e462bf7f05c.png" alt="第二范式"></p>
<p>一些重要的概念：</p>
<ul>
<li><strong>函数依赖（functional dependency）</strong> ：若在一张表中，在属性（或属性组）X 的值确定的情况下，必定能确定属性 Y 的值，那么就可以说 Y 函数依赖于 X，写作 X → Y。</li>
<li><strong>部分函数依赖（partial functional dependency）</strong> ：如果 X→Y，并且存在 X 的一个真子集 X0，使得 X0→Y，则称 Y 对 X 部分函数依赖。比如学生基本信息表 R 中（学号，身份证号，姓名）当然学号属性取值是唯一的，在 R 关系中，（学号，身份证号）-&gt;（姓名），（学号）-&gt;（姓名），（身份证号）-&gt;（姓名）；所以姓名部分函数依赖与（学号，身份证号）；</li>
<li><strong>完全函数依赖(Full functional dependency)</strong> ：在一个关系中，若某个非主属性数据项依赖于全部关键字称之为完全函数依赖。比如学生基本信息表 R（学号，班级，姓名）假设不同的班级学号有相同的，班级内学号不能相同，在 R 关系中，（学号，班级）-&gt;（姓名），但是（学号）-&gt;(姓名)不成立，（班级）-&gt;(姓名)不成立，所以姓名完全函数依赖与（学号，班级）；</li>
<li><strong>传递函数依赖</strong> ： 在关系模式 R(U)中，设 X，Y，Z 是 U 的不同的属性子集，如果 X 确定 Y、Y 确定 Z，且有 X 不包含 Y，Y 不确定 X，（X∪Y）∩Z=空集合，则称 Z 传递函数依赖(transitive functional dependency) 于 X。传递函数依赖会导致数据冗余和异常。传递函数依赖的 Y 和 Z 子集往往同属于某一个事物，因此可将其合并放到一个表中。比如在关系 R(学号 , 姓名, 系名，系主任)中，学号 → 系名，系名 → 系主任，所以存在非主属性系主任对于学号的传递函数依赖。。</li>
</ul>
<p><strong>3NF(第三范式)</strong></p>
<p>3NF 在 2NF 的基础之上，消除了非主属性对于码的传递函数依赖 。符合 3NF 要求的数据库设计，<strong>基本</strong>上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。比如在关系 R(学号 , 姓名, 系名，系主任)中，学号 → 系名，系名 → 系主任，所以存在非主属性系主任对于学号的传递函数依赖，所以该表的设计，不符合 3NF 的要求。</p>
<p><strong>总结</strong></p>
<ul>
<li>1NF：属性不可再分。</li>
<li>2NF：1NF 的基础之上，消除了非主属性对于码的部分函数依赖。</li>
<li>3NF：3NF 在 2NF 的基础之上，消除了非主属性对于码的传递函数依赖 。</li>
</ul>
<h2> 什么是存储过程?</h2>
<p>我们可以把存储过程看成是一些 SQL 语句的集合，中间加了点逻辑控制语句。存储过程在业务比较复杂的时候是非常实用的，比如很多时候我们完成一个操作可能需要写一大串 SQL 语句，这时候我们就可以写有一个存储过程，这样也方便了我们下一次的调用。存储过程一旦调试完成通过后就能稳定运行，另外，使用存储过程比单纯 SQL 语句执行要快，因为存储过程是预编译过的。</p>
<p>存储过程在互联网公司应用不多，因为存储过程难以调试和扩展，而且没有移植性，还会消耗数据库资源。</p>
<p>阿里巴巴 Java 开发手册里要求禁止使用存储过程。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/0fa082bc4d4f919065767476a41b2156.png" alt="阿里巴巴Java开发手册: 禁止存储过程"></p>
<h2> drop、delete 与 truncate 区别？</h2>
<h3> 用法不同</h3>
<ul>
<li>drop(丢弃数据): <code>drop table 表名</code> ，直接将表都删除掉，在删除表的时候使用。</li>
<li>truncate (清空数据) : <code>truncate table 表名</code> ，只删除表中的数据，再插入数据的时候自增长 id 又从 1 开始，在清空表中数据的时候使用。</li>
<li>delete（删除数据） : <code>delete from 表名 where 列名=值</code>，删除某一行的数据，如果不加 where 子句和<code>truncate table 表名</code>作用类似。</li>
</ul>
<p>truncate 和不带 where 子句的 delete、以及 drop 都会删除表内的数据，但是 <strong>truncate 和 delete 只删除数据不删除表的结构(定义)，执行 drop 语句，此表的结构也会删除，也就是执行 drop 之后对应的表不复存在。</strong></p>
<h3> 属于不同的数据库语言</h3>
<p>truncate 和 drop 属于 DDL(数据定义语言)语句，操作立即生效，原数据不放到 rollback segment 中，不能回滚，操作不触发 trigger。而 delete 语句是 DML (数据库操作语言)语句，这个操作会放到 rollback segement 中，事务提交之后才生效。</p>
<p><strong>DML 语句和 DDL 语句区别：</strong></p>
<ul>
<li>DML 是数据库操作语言（Data Manipulation Language）的缩写，是指对数据库中表记录的操作，主要包括表记录的插入（insert）、更新（update）、删除（delete）和查询（select），是开发人员日常使用最频繁的操作。</li>
<li>DDL （Data Definition Language）是数据定义语言的缩写，简单来说，就是对数据库内部的对象进行创建、删除、修改的操作语言。它和 DML 语言的最大区别是 DML 只是对表内部数据的操作，而不涉及到表的定义、结构的修改，更不会涉及到其他对象。DDL 语句更多的被数据库管理员（DBA）所使用，一般的开发人员很少使用。</li>
</ul>
<blockquote>
<p>由于<code>select</code>不会对表进行破坏，所以有的地方也会把<code>select</code>单独区分开叫做数据库查询语言DQL（Data Query Language）</p>
</blockquote>
<h3> 执行速度不同</h3>
<p>一般来说：drop &gt; truncate &gt; delete（这个我没有设计测试过）。</p>
<blockquote>
<p><code>delete</code>命令执行的时候会产生数据库的<code>binlog</code>日志，而日志记录是需要消耗时间的，但是也有个好处方便数据回滚恢复。</p>
<p><code>truncate</code>命令执行的时候不会产生数据库日志，因此比<code>delete</code>要快。除此之外，还会把表的自增值重置和索引恢复到初始大小等。</p>
<p><code>drop</code>命令会把表占用的空间全部释放掉。</p>
<p>Tips：你应该更多地关注在使用场景上，而不是执行效率。</p>
</blockquote>
<h2> 数据库设计通常分为哪几步?</h2>
<ol>
<li><strong>需求分析</strong> : 分析用户的需求，包括数据、功能和性能需求。</li>
<li><strong>概念结构设计</strong> : 主要采用 E-R 模型进行设计，包括画 E-R 图。</li>
<li><strong>逻辑结构设计</strong> : 通过将 E-R 图转换成表，实现从 E-R 模型到关系模型的转换。</li>
<li><strong>物理结构设计</strong> : 主要是为所设计的数据库选择合适的存储结构和存取路径。</li>
<li><strong>数据库实施</strong> : 包括编程、测试和试运行</li>
<li><strong>数据库的运行和维护</strong> : 系统的运行与数据库的日常维护。</li>
</ol>
<h2> 参考</h2>
<ul>
<li><a href="https://blog.csdn.net/rl529014/article/details/48391465" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/rl529014/article/details/48391465</a></li>
<li><a href="https://www.zhihu.com/question/24696366/answer/29189700" target="_blank" rel="noopener noreferrer">https://www.zhihu.com/question/24696366/answer/29189700</a></li>
<li><a href="https://blog.csdn.net/bieleyang/article/details/77149954" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/bieleyang/article/details/77149954</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://img-blog.csdnimg.cn/img_convert/e21120184e63406526a4e873cacd23f2.png" type="image/png"/>
    </item>
    <item>
      <title>字符集详解</title>
      <link>https://javaguide.cn/database/character-set.html</link>
      <guid>https://javaguide.cn/database/character-set.html</guid>
      <source url="https://javaguide.cn/rss.xml">字符集详解</source>
      <description>MySQL 字符编码集中有两套 UTF-8 编码实现：utf8 和 utf8mb4。 如果使用 utf8 的话，存储emoji 符号和一些比较复杂的汉字、繁体字就会出错。 为什么会这样呢？这篇文章可以从源头给你解答。 何为字符集？ 字符是各种文字和符号的统称，包括各个国家文字、标点符号、表情、数字等等。 字符集 就是一系列字符的集合。字符集的种类较多，每个字符集可以表示的字符范围通常不同，就比如说有些字符集是无法表示汉字的。</description>
      <category>数据库</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<p>MySQL 字符编码集中有两套 UTF-8 编码实现：<strong><code>utf8</code></strong> 和 <strong><code>utf8mb4</code></strong>。</p>
<p>如果使用 <strong><code>utf8</code></strong>  的话，存储emoji 符号和一些比较复杂的汉字、繁体字就会出错。</p>
<p>为什么会这样呢？这篇文章可以从源头给你解答。</p>
<h2> 何为字符集？</h2>
<p>字符是各种文字和符号的统称，包括各个国家文字、标点符号、表情、数字等等。 <strong>字符集</strong> 就是一系列字符的集合。字符集的种类较多，每个字符集可以表示的字符范围通常不同，就比如说有些字符集是无法表示汉字的。</p>
<p><strong>计算机只能存储二进制的数据，那英文、汉字、表情等字符应该如何存储呢？</strong></p>
<p>我们要将这些字符和二进制的数据一一对应起来，比如说字符“a”对应“01100001”，反之，“01100001”对应 “a”。我们将字符对应二进制数据的过程称为"<strong>字符编码</strong>"，反之，二进制数据解析成字符的过程称为“<strong>字符解码</strong>”。</p>
<h2> 有哪些常见的字符集？</h2>
<p>常见的字符集有 ASCII、GB2312、GBK、UTF-8......。</p>
<p>不同的字符集的主要区别在于：</p>
<ul>
<li>可以表示的字符范围</li>
<li>编码方式</li>
</ul>
<h3> ASCII</h3>
<p><strong>ASCII</strong> (<strong>A</strong>merican <strong>S</strong>tandard <strong>C</strong>ode for <strong>I</strong>nformation <strong>I</strong>nterchange，美国信息交换标准代码) 是一套主要用于现代美国英语的字符集（这也是 ASCII 字符集的局限性所在）。</p>
<p><strong>为什么 ASCII 字符集没有考虑到中文等其他字符呢？</strong> 因为计算机是美国人发明的，当时，计算机的发展还处于比较雏形的时代，还未在其他国家大规模使用。因此，美国发布 ASCII 字符集的时候没有考虑兼容其他国家的语言。</p>
<p>ASCII 字符集至今为止共定义了 128 个字符，其中有 33 个控制字符（比如回车、删除）无法显示。</p>
<p>一个 ASCII 码长度是一个字节也就是 8 个 bit，比如“a”对应的 ASCII 码是“01100001”。不过，最高位是 0 仅仅作为校验位，其余 7 位使用 0 和 1 进行组合，所以，ASCII 字符集可以定义 128（2^7）个字符。</p>
<p>由于，ASCII 码可以表示的字符实在是太少了。后来，人们对其进行了扩展得到了 <strong>ASCII 扩展字符集</strong> 。ASCII 扩展字符集使用 8 位（bits）表示一个字符，所以，ASCII 扩展字符集可以定义 256（2^8）个字符。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/c1c6375d08ca268690cef2b13591a5b4.png" alt="ASCII字符编码"></p>
<h3> GB2312</h3>
<p>我们上面说了，ASCII 字符集是一种现代美国英语适用的字符集。因此，很多国家都捣鼓了一个适合自己国家语言的字符集。</p>
<p>GB2312 字符集是一种对汉字比较友好的字符集，共收录 6700 多个汉字，基本涵盖了绝大部分常用汉字。不过，GB2312 字符集不支持绝大部分的生僻字和繁体字。</p>
<p>对于英语字符，GB2312 编码和 ASCII 码是相同的，1 字节编码即可。对于非英字符，需要 2 字节编码。</p>
<h3> GBK</h3>
<p>GBK 字符集可以看作是 GB2312 字符集的扩展，兼容 GB2312 字符集，共收录了 20000 多个汉字。</p>
<p>GBK 中 K 是汉语拼音 Kuo Zhan（扩展）中的“Kuo”的首字母。</p>
<h3> GB18030</h3>
<p>GB18030 完全兼容 GB2312 和 GBK 字符集，纳入中国国内少数民族的文字，且收录了日韩汉字，是目前为止最全面的汉字字符集，共收录汉字 70000 多个。</p>
<h3> BIG5</h3>
<p>BIG5 主要针对的是繁体中文，收录了 13000 多个汉字。</p>
<h3> Unicode &amp; UTF-8编码</h3>
<p>为了更加适合本国语言，诞生了很多种字符集。</p>
<p>我们上面也说了不同的字符集可以表示的字符范围以及编码规则存在差异。这就导致了一个非常严重的问题：<strong>使用错误的编码方式查看一个包含字符的文件就会产生乱码现象。</strong></p>
<p>就比如说你使用 UTF-8 编码方式打开 GB2312 编码格式的文件就会出现乱码。示例：“牛”这个汉字 GB2312 编码后的十六进制数值为 “C5A3”，而 “C5A3” 用 UTF-8 解码之后得到的却是 “ţ”。</p>
<p>你可以通过这个网站在线进行编码和解码：https://www.haomeili.net/HanZi/ZiFuBianMaZhuanHuan</p>
<p><img src="https://img-blog.csdnimg.cn/836c49b117ee4408871b0020b74c991d.png" alt=""></p>
<p>这样我们就搞懂了乱码的本质： <strong>编码和解码时用了不同或者不兼容的字符集</strong> 。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/a8808cbabeea49caa3af27d314fa3c02-1.jpg" alt=""></p>
<p>为了解决这个问题，人们就想：“如果我们能够有一种字符集将世界上所有的字符都纳入其中就好了！”。</p>
<p>然后，<strong>Unicode</strong> 带着这个使命诞生了。</p>
<p>Unicode 字符集中包含了世界上几乎所有已知的字符。不过，Unicode 字符集并没有规定如何存储这些字符（也就是如何使用二进制数据表示这些字符）。</p>
<p>然后，就有了 <strong>UTF-8</strong>（<strong>8</strong>-bit <strong>U</strong>nicode <strong>T</strong>ransformation <strong>F</strong>ormat）。类似的还有 UTF-16、 UTF-32。</p>
<p>UTF-8 使用 1 到 4 个字节为每个字符编码， UTF-16 使用 2 或 4 个字节为每个字符编码，UTF-32 固定位 4 个字节为每个字符编码。</p>
<p>UTF-8 可以根据不同的符号自动选择编码的长短，像英文字符只需要 1 个字节就够了，这一点 ASCII 字符集一样 。因此，对于英语字符，UTF-8 编码和 ASCII 码是相同的。</p>
<p>UTF-32 的规则最简单，不过缺陷也比较明显，对于英文字母这类字符消耗的空间是 UTF-8 的 4 倍之多。</p>
<p><strong>UTF-8</strong> 是目前使用最广的一种字符编码，。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/1280px-Utf8webgrowth.svg.png" alt=""></p>
<h2> MySQL 字符集</h2>
<p>MySQL 支持很多种字符编码的方式，比如 UTF-8、GB2312、GBK、BIG5。</p>
<p>你可以通过 <code>SHOW CHARSET</code> 命令来查看。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/image-20211008164229671.png" alt=""></p>
<p>通常情况下，我们建议使用 UTF-8 作为默认的字符编码方式。</p>
<p>不过，这里有一个小坑。</p>
<p>MySQL 字符编码集中有两套 UTF-8 编码实现：</p>
<ul>
<li><strong><code>utf8</code></strong> ： <code>utf8</code>编码只支持<code>1-3</code>个字节 。 在 <code>utf8</code> 编码中，中文是占 3 个字节，其他数字、英文、符号占一个字节。但 emoji 符号占 4 个字节，一些较复杂的文字、繁体字也是 4 个字节。</li>
<li><strong><code>utf8mb4</code></strong> ： UTF-8 的完整实现，正版！最多支持使用 4 个字节表示字符，因此，可以用来存储 emoji 符号。</li>
</ul>
<p><strong>为什么有两套 UTF-8 编码实现呢？</strong> 原因如下：</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/image-20211008164542347.png" alt=""></p>
<p>因此，如果你需要存储<code>emoji</code>类型的数据或者一些比较复杂的文字、繁体字到 MySQL 数据库的话，数据库的编码一定要指定为<code>utf8mb4</code> 而不是<code>utf8</code> ，要不然存储的时候就会报错了。</p>
<p>演示一下吧！（环境：MySQL 5.7+）</p>
<p>建表语句如下，我们指定数据库 CHARSET 为 <code>utf8</code> 。</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当我们执行下面的 insert 语句插入数据到数据库时，果然报错！</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>报错信息如下：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> 参考</h2>
<ul>
<li>字符集和字符编码（Charset &amp; Encoding）： https://www.cnblogs.com/skynet/archive/2011/05/03/2035105.html</li>
<li>十分钟搞清字符集和字符编码：http://cenalulu.github.io/linux/character-encoding/</li>
<li>Unicode-维基百科：https://zh.wikipedia.org/wiki/Unicode</li>
<li>GB2312-维基百科：https://zh.wikipedia.org/wiki/GB_2312</li>
<li>UTF-8-维基百科：https://zh.wikipedia.org/wiki/UTF-8</li>
<li>GB18030-维基百科: https://zh.wikipedia.org/wiki/GB_18030</li>
</ul>
]]></content:encoded>
      <enclosure url="https://img-blog.csdnimg.cn/img_convert/c1c6375d08ca268690cef2b13591a5b4.png" type="image/png"/>
    </item>
    <item>
      <title>API 网关详解</title>
      <link>https://javaguide.cn/distributed-system/api-gateway.html</link>
      <guid>https://javaguide.cn/distributed-system/api-gateway.html</guid>
      <source url="https://javaguide.cn/rss.xml">API 网关详解</source>
      <description>什么是网关？有什么用？ 微服务背景下，一个系统被拆分为多个服务，但是像安全认证，流量控制，日志，监控等功能是每个服务都需要的，没有网关的话，我们就需要在每个服务中单独实现，这使得我们做了很多重复的事情并且没有一个全局的视图来统一管理这些功能。</description>
      <category>分布式</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 什么是网关？有什么用？</h2>
<p>微服务背景下，一个系统被拆分为多个服务，但是像安全认证，流量控制，日志，监控等功能是每个服务都需要的，没有网关的话，我们就需要在每个服务中单独实现，这使得我们做了很多重复的事情并且没有一个全局的视图来统一管理这些功能。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/system-design/distributed-system/api-gateway-overview.png" alt="网关示意图"></p>
<p>一般情况下，网关可以为我们提供请求转发、安全认证（身份/权限认证）、流量控制、负载均衡、降级熔断、日志、监控等功能。</p>
<p>上面介绍了这么多功能，实际上，网关主要做了一件事情：<strong>请求过滤</strong> 。</p>
<h2> 有哪些常见的网关系统？</h2>
<h3> Netflix Zuul</h3>
<p>Zuul 是 Netflix 开发的一款提供动态路由、监控、弹性、安全的网关服务。</p>
<p>Zuul 主要通过过滤器（类似于 AOP）来过滤请求，从而实现网关必备的各种功能。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/865991e34f69f8cb345b4aff918e946e.png" alt="Zuul架构"></p>
<p>我们可以自定义过滤器来处理请求，并且，Zuul 生态本身就有很多现成的过滤器供我们使用。就比如限流可以直接用国外朋友写的 <a href="https://github.com/marcosbarbero/spring-cloud-zuul-ratelimit" target="_blank" rel="noopener noreferrer">spring-cloud-zuul-ratelimit</a> (这里只是举例说明，一般是配合 hystrix 来做限流)：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Zuul 1.x 基于同步 IO，性能较差。Zuul 2.x 基于 Netty 实现了异步 IO，性能得到了大幅改进。</p>
<ul>
<li>Github 地址 ： https://github.com/Netflix/zuul</li>
<li>官方 Wiki ： https://github.com/Netflix/zuul/wiki</li>
</ul>
<h3> Spring Cloud Gateway</h3>
<p>SpringCloud Gateway 属于 Spring Cloud 生态系统中的网关，其诞生的目标是为了替代老牌网关 **Zuul **。准确点来说，应该是 Zuul 1.x。SpringCloud Gateway 起步要比 Zuul 2.x 更早。</p>
<p>为了提升网关的性能，SpringCloud Gateway 基于 Spring WebFlux 。Spring WebFlux 使用 Reactor 库来实现响应式编程模型，底层基于 Netty 实现异步 IO。</p>
<p>Spring Cloud Gateway 的目标，不仅提供统一的路由方式，并且基于 Filter 链的方式提供了网关基本的功能，例如：安全，监控/指标，和限流。</p>
<p>Spring Cloud Gateway 和 Zuul 2.x 的差别不大，也是通过过滤器来处理请求。不过，目前更加推荐使用 Spring Cloud Gateway 而非 Zuul，Spring Cloud 生态对其支持更加友好。</p>
<ul>
<li>Github 地址 ： https://github.com/spring-cloud/spring-cloud-gateway</li>
<li>官网 ： https://spring.io/projects/spring-cloud-gateway</li>
</ul>
<h3> Kong</h3>
<p>Kong 是一款基于 <a href="https://github.com/openresty/" target="_blank" rel="noopener noreferrer">OpenResty</a> 的高性能、云原生、可扩展的网关系统。</p>
<blockquote>
<p>OpenResty 是一个基于 Nginx 与 Lua 的高性能 Web 平台，其内部集成了大量精良的 Lua 库、第三方模块以及大多数的依赖项。用于方便地搭建能够处理超高并发、扩展性极高的动态 Web 应用、Web 服务和动态网关。</p>
</blockquote>
<p>Kong 提供了插件机制来扩展其功能。比如、在服务上启用 Zipkin 插件</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>Github 地址： https://github.com/Kong/kong</li>
<li>官网地址 ： https://konghq.com/kong</li>
</ul>
<h3> APISIX</h3>
<p>APISIX 是一款基于 Nginx 和 etcd 的高性能、云原生、可扩展的网关系统。</p>
<blockquote>
<p><em>etcd</em>是使用 Go 语言开发的一个开源的、高可用的分布式 key-value 存储系统，使用 Raft 协议做分布式共识。</p>
</blockquote>
<p>与传统 API 网关相比，APISIX 具有动态路由和插件热加载，特别适合微服务系统下的 API 管理。并且，APISIX 与 SkyWalking（分布式链路追踪系统）、Zipkin（分布式链路追踪系统）、Prometheus（监控系统） 等 DevOps 生态工具对接都十分方便。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/727732fad2e943bdd2c502b83ddb1b89.png" alt="apisix架构图"></p>
<p>作为 NGINX 和 Kong 的替代项目，APISIX 目前已经是 Apache 顶级开源项目，并且是最快毕业的国产开源项目。国内目前已经有很多知名企业（比如金山、有赞、爱奇艺、腾讯、贝壳）使用 APISIX 处理核心的业务流量。</p>
<p>根据官网介绍：“APISIX 已经生产可用，功能、性能、架构全面优于 Kong”。</p>
<ul>
<li>Github 地址 ：https://github.com/apache/apisix</li>
<li>官网地址： https://apisix.apache.org/zh/</li>
</ul>
<p>相关阅读：</p>
<ul>
<li><a href="https://www.apiseven.com/zh/blog/why-we-need-Apache-APISIX" target="_blank" rel="noopener noreferrer">有了 NGINX 和 Kong，为什么还需要 Apache APISIX</a></li>
<li><a href="https://www.apiseven.com/zh/blog" target="_blank" rel="noopener noreferrer">APISIX 技术博客</a></li>
<li><a href="https://www.apiseven.com/zh/usercases" target="_blank" rel="noopener noreferrer">APISIX 用户案例</a></li>
</ul>
<h3> Shenyu</h3>
<p>Shenyu 是一款基于 WebFlux 的可扩展、高性能、响应式网关，Apache 顶级开源项目。</p>
<p><img src="https://img-blog.csdnimg.cn/1104eb413cba468cba4dce119165e84e.png" alt="Shenyu架构"></p>
<p>Shenyu 通过插件扩展功能，插件是 ShenYu 的灵魂，并且插件也是可扩展和热插拔的。不同的插件实现不同的功能。Shenyu 自带了诸如限流、熔断、转发 、重写、重定向、和路由监控等插件。</p>
<ul>
<li>Github 地址： https://github.com/apache/incubator-shenyu</li>
<li>官网地址 ： https://shenyu.apache.org/</li>
</ul>
]]></content:encoded>
      <enclosure url="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/system-design/distributed-system/api-gateway-overview.png" type="image/png"/>
    </item>
    <item>
      <title>分布式配置中心详解(付费)</title>
      <link>https://javaguide.cn/distributed-system/distributed-configuration-center.html</link>
      <guid>https://javaguide.cn/distributed-system/distributed-configuration-center.html</guid>
      <source url="https://javaguide.cn/rss.xml">分布式配置中心详解(付费)</source>
      <description>分布式配置中心 相关的面试题为我的知识星球（点击链接即可查看详细介绍以及加入方法）专属内容，已经整理到了《Java 面试指北》（点击链接即可查看详细介绍以及获取方法）中。</description>
      <category>分布式</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<p><strong>分布式配置中心</strong> 相关的面试题为我的<a href="https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc" target="_blank" rel="noopener noreferrer">知识星球</a>（点击链接即可查看详细介绍以及加入方法）专属内容，已经整理到了<a href="https://www.yuque.com/docs/share/f37fc804-bfe6-4b0d-b373-9c462188fec7" target="_blank" rel="noopener noreferrer">《Java 面试指北》</a>（点击链接即可查看详细介绍以及获取方法）中。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javamianshizhibei/distributed-system.png" alt=""></p>
<p><a href="https://www.yuque.com/docs/share/f37fc804-bfe6-4b0d-b373-9c462188fec7" target="_blank" rel="noopener noreferrer">《Java 面试指北》</a> 的部分内容展示如下，你可以将其看作是 <a href="https://javaguide.cn/#/" target="_blank" rel="noopener noreferrer">JavaGuide</a> 的补充完善，两者可以配合使用。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220304102536445.png" alt=""></p>
<p><a href="https://www.yuque.com/docs/share/f37fc804-bfe6-4b0d-b373-9c462188fec7" target="_blank" rel="noopener noreferrer">《Java 面试指北》</a>只是星球内部众多资料中的一个，星球还有很多其他优质资料比如<a href="https://javaguide.cn/zhuanlan/" target="_blank" rel="noopener noreferrer">专属专栏</a>、Java 编程视频、PDF 资料。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220211231206733.png" alt=""></p>
<p>最近几年，市面上有越来越多的“技术大佬”开始办培训班/训练营，动辄成千上万的学费，却并没有什么干货，单纯的就是割韭菜。</p>
<p>为了帮助更多同学准备 Java 面试以及学习 Java ，我创建了一个纯粹的<a href="https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc" target="_blank" rel="noopener noreferrer">知识星球</a>。虽然收费只有培训班/训练营的百分之一，但是<a href="https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc" target="_blank" rel="noopener noreferrer">知识星球</a>里的内容质量更高，提供的服务也更全面。</p>
<p>欢迎准备 Java 面试以及学习 Java 的同学加入我的<a href="https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc" target="_blank" rel="noopener noreferrer">知识星球</a>，干货非常多，学习氛围非常好！收费虽然是白菜价，但星球里的内容或许比你参加上万的培训班质量还要高。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220311203414600.png" alt=""></p>
<p>下面是星球提供的部分服务（点击下方图片即可获取知识星球的详细介绍）：</p>
<div align="center">
  <a href="https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html">
    <img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/xingqiufuwu.png" style="margin: 0 auto; ">
  </a>
</div>
<p>我有自己的原则，不割韭菜，用心做内容，真心希望帮助到你！</p>
<p>如果你感兴趣的话，不妨花 3 分钟左右看看星球的详细介绍： <a href="https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc" target="_blank" rel="noopener noreferrer">JavaGuide 知识星球详细介绍</a>（文末有优惠券）。</p>
<div align="center">
  <a href="https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html">
    <img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/xingqiuyouhuijuanheyi.png" style="margin: 0 auto; ">
  </a>
</div>
]]></content:encoded>
      <enclosure url="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javamianshizhibei/distributed-system.png" type="image/png"/>
    </item>
    <item>
      <title>分布式 ID 详解</title>
      <link>https://javaguide.cn/distributed-system/distributed-id.html</link>
      <guid>https://javaguide.cn/distributed-system/distributed-id.html</guid>
      <source url="https://javaguide.cn/rss.xml">分布式 ID 详解</source>
      <description>分布式 ID 介绍 什么是 ID？ 日常开发中，我们需要对系统中的各种数据使用 ID 唯一表示，比如用户 ID 对应且仅对应一个人，商品 ID 对应且仅对应一件商品，订单 ID 对应且仅对应一个订单。 我们现实生活中也有各种 ID，比如身份证 ID 对应且仅对应一个人、地址 ID 对应且仅对应 简单来说，ID 就是数据的唯一标识。 什么是分布式 ID？ 分布式 ID 是分布式系统下的 ID。分布式 ID 不存在与现实生活中，属于计算机系统中的一个概念。</description>
      <category>分布式</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 分布式 ID 介绍</h2>
<h3> 什么是 ID？</h3>
<p>日常开发中，我们需要对系统中的各种数据使用 ID 唯一表示，比如用户 ID 对应且仅对应一个人，商品 ID 对应且仅对应一件商品，订单 ID 对应且仅对应一个订单。</p>
<p>我们现实生活中也有各种 ID，比如身份证 ID 对应且仅对应一个人、地址 ID 对应且仅对应</p>
<p>简单来说，<strong>ID 就是数据的唯一标识</strong>。</p>
<h3> 什么是分布式 ID？</h3>
<p>分布式 ID 是分布式系统下的 ID。分布式 ID 不存在与现实生活中，属于计算机系统中的一个概念。</p>
<p>我简单举一个分库分表的例子。</p>
<p>我司的一个项目，使用的是单机 MySQL 。但是，没想到的是，项目上线一个月之后，随着使用人数越来越多，整个系统的数据量将越来越大。单机 MySQL 已经没办法支撑了，需要进行分库分表（推荐 Sharding-JDBC）。</p>
<p>在分库之后， 数据遍布在不同服务器上的数据库，数据库的自增主键已经没办法满足生成的主键唯一了。<strong>我们如何为不同的数据节点生成全局唯一主键呢？</strong></p>
<p>这个时候就需要生成<strong>分布式 ID</strong>了。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/system-design/distributed-system/id-after-the-sub-table-not-conflict.png" alt=""></p>
<h3> 分布式 ID 需要满足哪些要求?</h3>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/system-design/distributed-system/distributed-id-requirements.png" alt=""></p>
<p>分布式 ID 作为分布式系统中必不可少的一环，很多地方都要用到分布式 ID。</p>
<p>一个最基本的分布式 ID 需要满足下面这些要求：</p>
<ul>
<li><strong>全局唯一</strong> ：ID 的全局唯一性肯定是首先要满足的！</li>
<li><strong>高性能</strong> ： 分布式 ID 的生成速度要快，对本地资源消耗要小。</li>
<li><strong>高可用</strong> ：生成分布式 ID 的服务要保证可用性无限接近于 100%。</li>
<li><strong>方便易用</strong> ：拿来即用，使用方便，快速接入！</li>
</ul>
<p>除了这些之外，一个比较好的分布式 ID 还应保证：</p>
<ul>
<li><strong>安全</strong> ：ID 中不包含敏感信息。</li>
<li><strong>有序递增</strong> ：如果要把 ID 存放在数据库的话，ID 的有序性可以提升数据库写入速度。并且，很多时候 ，我们还很有可能会直接通过 ID 来进行排序。</li>
<li><strong>有具体的业务含义</strong> ：生成的 ID 如果能有具体的业务含义，可以让定位问题以及开发更透明化（通过 ID 就能确定是哪个业务）。</li>
<li><strong>独立部署</strong> ：也就是分布式系统单独有一个发号器服务，专门用来生成分布式 ID。这样就生成 ID 的服务可以和业务相关的服务解耦。不过，这样同样带来了网络调用消耗增加的问题。总的来说，如果需要用到分布式 ID 的场景比较多的话，独立部署的发号器服务还是很有必要的。</li>
</ul>
<h2> 分布式 ID 常见解决方案</h2>
<h3> 数据库</h3>
<h4> 数据库主键自增</h4>
<p>这种方式就比较简单直白了，就是通过关系型数据库的自增主键产生来唯一的 ID。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/system-design/distributed-system/the-primary-key-of-the-database-increases-automatically.png" alt="数据库主键自增"></p>
<p>以 MySQL 举例，我们通过下面的方式即可。</p>
<p><strong>1.创建一个数据库表。</strong></p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>stub</code> 字段无意义，只是为了占位，便于我们插入或者修改数据。并且，给 <code>stub</code> 字段创建了唯一索引，保证其唯一性。</p>
<p><strong>2.通过 <code>replace into</code> 来插入数据。</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>插入数据这里，我们没有使用 <code>insert into</code> 而是使用 <code>replace into</code> 来插入数据，具体步骤是这样的：</p>
<p>1)第一步： 尝试把数据插入到表中。</p>
<p>2)第二步： 如果主键或唯一索引字段出现重复数据错误而插入失败时，先从表中删除含有重复关键字值的冲突行，然后再次尝试把数据插入到表中。</p>
<p>这种方式的优缺点也比较明显：</p>
<ul>
<li><strong>优点</strong> ：实现起来比较简单、ID 有序递增、存储消耗空间小</li>
<li><strong>缺点</strong> ： 支持的并发量不大、存在数据库单点问题（可以使用数据库集群解决，不过增加了复杂度）、ID 没有具体业务含义、安全问题（比如根据订单 ID 的递增规律就能推算出每天的订单量，商业机密啊！ ）、每次获取 ID 都要访问一次数据库（增加了对数据库的压力，获取速度也慢）</li>
</ul>
<h4> 数据库号段模式</h4>
<p>数据库主键自增这种模式，每次获取 ID 都要访问一次数据库，ID 需求比较大的时候，肯定是不行的。</p>
<p>如果我们可以批量获取，然后存在在内存里面，需要用到的时候，直接从内存里面拿就舒服了！这也就是我们说的 <strong>基于数据库的号段模式来生成分布式 ID。</strong></p>
<p>数据库的号段模式也是目前比较主流的一种分布式 ID 生成方式。像滴滴开源的<a href="https://github.com/didi/tinyid/wiki/tinyid%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D" target="_blank" rel="noopener noreferrer">Tinyid</a> 就是基于这种方式来做的。不过，TinyId 使用了双号段缓存、增加多 db 支持等方式来进一步优化。</p>
<p>以 MySQL 举例，我们通过下面的方式即可。</p>
<p><strong>1.创建一个数据库表。</strong></p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>current_max_id</code> 字段和<code>step</code>字段主要用于获取批量 ID，获取的批量 id 为： <code>current_max_id ~ current_max_id+step</code>。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/system-design/distributed-system/database-number-segment-mode.png" alt="数据库号段模式"></p>
<p><code>version</code> 字段主要用于解决并发问题（乐观锁）,<code>biz_type</code> 主要用于表示业务类型。</p>
<p><strong>2.先插入一行数据。</strong></p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>3.通过 SELECT 获取指定业务下的批量唯一 ID</strong></p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>结果：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>4.不够用的话，更新之后重新 SELECT 即可。</strong></p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>结果：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>相比于数据库主键自增的方式，<strong>数据库的号段模式对于数据库的访问次数更少，数据库压力更小。</strong></p>
<p>另外，为了避免单点问题，你可以从使用主从模式来提高可用性。</p>
<p><strong>数据库号段模式的优缺点:</strong></p>
<ul>
<li><strong>优点</strong> ：ID 有序递增、存储消耗空间小</li>
<li><strong>缺点</strong> ：存在数据库单点问题（可以使用数据库集群解决，不过增加了复杂度）、ID 没有具体业务含义、安全问题（比如根据订单 ID 的递增规律就能推算出每天的订单量，商业机密啊！ ）</li>
</ul>
<h4> NoSQL</h4>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/system-design/distributed-system/nosql-distributed-id.png" alt=""></p>
<p>一般情况下，NoSQL 方案使用 Redis 多一些。我们通过 Redis 的 <code>incr</code> 命令即可实现对 id 原子顺序递增。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为了提高可用性和并发，我们可以使用 Redis Cluster。Redis Cluster 是 Redis 官方提供的 Redis 集群解决方案（3.0+版本）。</p>
<p>除了 Redis Cluster 之外，你也可以使用开源的 Redis 集群方案<a href="https://github.com/CodisLabs/codis" target="_blank" rel="noopener noreferrer">Codis</a> （大规模集群比如上百个节点的时候比较推荐）。</p>
<p>除了高可用和并发之外，我们知道 Redis 基于内存，我们需要持久化数据，避免重启机器或者机器故障后数据丢失。Redis 支持两种不同的持久化方式：<strong>快照（snapshotting，RDB）</strong>、<strong>只追加文件（append-only file, AOF）</strong>。 并且，Redis 4.0 开始支持 <strong>RDB 和 AOF 的混合持久化</strong>（默认关闭，可以通过配置项 <code>aof-use-rdb-preamble</code> 开启）。</p>
<p>关于 Redis 持久化，我这里就不过多介绍。不了解这部分内容的小伙伴，可以看看 <a href="https://snailclimb.gitee.io/javaguide/#/docs/database/Redis/redis-all" target="_blank" rel="noopener noreferrer">JavaGuide 对于 Redis 知识点的总结</a>。</p>
<p><strong>Redis 方案的优缺点：</strong></p>
<ul>
<li><strong>优点</strong> ： 性能不错并且生成的 ID 是有序递增的</li>
<li><strong>缺点</strong> ： 和数据库主键自增方案的缺点类似</li>
</ul>
<p>除了 Redis 之外，MongoDB ObjectId 经常也会被拿来当做分布式 ID 的解决方案。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/system-design/distributed-system/mongodb9-objectId-distributed-id.png" alt=""></p>
<p>MongoDB ObjectId 一共需要 12 个字节存储：</p>
<ul>
<li>0~3：时间戳</li>
<li>3~6： 代表机器 ID</li>
<li>7~8：机器进程 ID</li>
<li>9~11 ：自增值</li>
</ul>
<p><strong>MongoDB 方案的优缺点：</strong></p>
<ul>
<li><strong>优点</strong> ： 性能不错并且生成的 ID 是有序递增的</li>
<li><strong>缺点</strong> ： 需要解决重复 ID 问题（当机器时间不对的情况下，可能导致会产生重复 ID） 、有安全性问题（ID 生成有规律性）</li>
</ul>
<h3> 算法</h3>
<h4> UUID</h4>
<p>UUID 是 Universally Unique Identifier（通用唯一标识符） 的缩写。UUID 包含 32 个 16 进制数字（8-4-4-4-12）。</p>
<p>JDK 就提供了现成的生成 UUID 的方法，一行代码就行了。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><a href="https://tools.ietf.org/html/rfc4122" target="_blank" rel="noopener noreferrer">RFC 4122</a> 中关于 UUID 的示例是这样的：</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/system-design/distributed-system/rfc-4122-uuid.png" alt=""></p>
<p>我们这里重点关注一下这个 Version(版本)，不同的版本对应的 UUID 的生成规则是不同的。</p>
<p>5 种不同的 Version(版本)值分别对应的含义（参考<a href="https://zh.wikipedia.org/wiki/%E9%80%9A%E7%94%A8%E5%94%AF%E4%B8%80%E8%AF%86%E5%88%AB%E7%A0%81" target="_blank" rel="noopener noreferrer">维基百科对于 UUID 的介绍</a>）：</p>
<ul>
<li><strong>版本 1</strong> : UUID 是根据时间和节点 ID（通常是 MAC 地址）生成；</li>
<li><strong>版本 2</strong> : UUID 是根据标识符（通常是组或用户 ID）、时间和节点 ID 生成；</li>
<li><strong>版本 3、版本 5</strong> : 版本 5 - 确定性 UUID 通过散列（hashing）名字空间（namespace）标识符和名称生成；</li>
<li><strong>版本 4</strong> : UUID 使用<a href="https://zh.wikipedia.org/wiki/%E9%9A%8F%E6%9C%BA%E6%80%A7" target="_blank" rel="noopener noreferrer">随机性</a>或<a href="https://zh.wikipedia.org/wiki/%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%80%A7" target="_blank" rel="noopener noreferrer">伪随机性</a>生成。</li>
</ul>
<p>下面是 Version 1 版本下生成的 UUID 的示例：</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/system-design/distributed-system/version1-uuid.png" alt="Version 1 版本下生成的 UUID 的示例"></p>
<p>JDK 中通过 <code>UUID</code> 的 <code>randomUUID()</code> 方法生成的 UUID 的版本默认为 4。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>另外，Variant(变体)也有 4 种不同的值，这种值分别对应不同的含义。这里就不介绍了，貌似平时也不怎么需要关注。</p>
<p>需要用到的时候，去看看维基百科对于 UUID 的 Variant(变体) 相关的介绍即可。</p>
<p>从上面的介绍中可以看出，UUID 可以保证唯一性，因为其生成规则包括 MAC 地址、时间戳、名字空间（Namespace）、随机或伪随机数、时序等元素，计算机基于这些规则生成的 UUID 是肯定不会重复的。</p>
<p>虽然，UUID 可以做到全局唯一性，但是，我们一般很少会使用它。</p>
<p>比如使用 UUID 作为 MySQL 数据库主键的时候就非常不合适：</p>
<ul>
<li>数据库主键要尽量越短越好，而 UUID 的消耗的存储空间比较大（32 个字符串，128 位）。</li>
<li>UUID 是无顺序的，InnoDB 引擎下，数据库主键的无序性会严重影响数据库性能。</li>
</ul>
<p>最后，我们再简单分析一下 <strong>UUID 的优缺点</strong> （面试的时候可能会被问到的哦！） :</p>
<ul>
<li><strong>优点</strong> ：生成速度比较快、简单易用</li>
<li><strong>缺点</strong> ： 存储消耗空间大（32 个字符串，128 位） 、 不安全（基于 MAC 地址生成 UUID 的算法会造成 MAC 地址泄露)、无序（非自增）、没有具体业务含义、需要解决重复 ID 问题（当机器时间不对的情况下，可能导致会产生重复 ID）</li>
</ul>
<h4> Snowflake(雪花算法)</h4>
<p>Snowflake 是 Twitter 开源的分布式 ID 生成算法。Snowflake 由 64 bit 的二进制数字组成，这 64bit 的二进制被分成了几部分，每一部分存储的数据都有特定的含义：</p>
<ul>
<li><strong>第 0 位</strong>： 符号位（标识正负），始终为 0，没有用，不用管。</li>
<li><strong>第 1~41 位</strong> ：一共 41 位，用来表示时间戳，单位是毫秒，可以支撑 2 ^41 毫秒（约 69 年）</li>
<li><strong>第 42~52 位</strong> ：一共 10 位，一般来说，前 5 位表示机房 ID，后 5 位表示机器 ID（实际项目中可以根据实际情况调整）。这样就可以区分不同集群/机房的节点。</li>
<li><strong>第 53~64 位</strong> ：一共 12 位，用来表示序列号。 序列号为自增值，代表单台机器每毫秒能够产生的最大 ID 数(2^12 = 4096),也就是说单台机器每毫秒最多可以生成 4096 个 唯一 ID。</li>
</ul>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/system-design/distributed-system/snowflake-distributed-id-schematic-diagram.png" alt="Snowflake 示意图"></p>
<p>如果你想要使用 Snowflake 算法的话，一般不需要你自己再造轮子。有很多基于 Snowflake 算法的开源实现比如美团 的 Leaf、百度的 UidGenerator，并且这些开源实现对原有的 Snowflake 算法进行了优化。</p>
<p>另外，在实际项目中，我们一般也会对 Snowflake 算法进行改造，最常见的就是在 Snowflake 算法生成的 ID 中加入业务类型信息。</p>
<p>我们再来看看 Snowflake 算法的优缺点 ：</p>
<ul>
<li><strong>优点</strong> ：生成速度比较快、生成的 ID 有序递增、比较灵活（可以对 Snowflake 算法进行简单的改造比如加入业务 ID）</li>
<li><strong>缺点</strong> ： 需要解决重复 ID 问题（依赖时间，当机器时间不对的情况下，可能导致会产生重复 ID）。</li>
</ul>
<h3> 开源框架</h3>
<h4> UidGenerator(百度)</h4>
<p><a href="https://github.com/baidu/uid-generator" target="_blank" rel="noopener noreferrer">UidGenerator</a> 是百度开源的一款基于 Snowflake(雪花算法)的唯一 ID 生成器。</p>
<p>不过，UidGenerator 对 Snowflake(雪花算法)进行了改进，生成的唯一 ID 组成如下。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/system-design/distributed-system/uidgenerator-distributed-id-schematic-diagram.png" alt=""></p>
<p>可以看出，和原始 Snowflake(雪花算法)生成的唯一 ID 的组成不太一样。并且，上面这些参数我们都可以自定义。</p>
<p>UidGenerator 官方文档中的介绍如下：</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/system-design/distributed-system/uidgenerator-introduction-official-documents.png" alt=""></p>
<p>自 18 年后，UidGenerator 就基本没有再维护了，我这里也不过多介绍。想要进一步了解的朋友，可以看看 <a href="https://github.com/baidu/uid-generator/blob/master/README.zh_cn.md" target="_blank" rel="noopener noreferrer">UidGenerator 的官方介绍</a>。</p>
<h4> Leaf(美团)</h4>
<p><strong><a href="https://github.com/Meituan-Dianping/Leaf" target="_blank" rel="noopener noreferrer">Leaf</a></strong> 是美团开源的一个分布式 ID 解决方案 。这个项目的名字 Leaf（树叶） 起源于德国哲学家、数学家莱布尼茨的一句话： “There are no two identical leaves in the world”（世界上没有两片相同的树叶） 。这名字起得真心挺不错的，有点文艺青年那味了！</p>
<p><img src="https://img-blog.csdnimg.cn/20210422145229617.png" alt=""></p>
<p>Leaf 提供了 <strong>号段模式</strong> 和 <strong>Snowflake(雪花算法)</strong> 这两种模式来生成分布式 ID。并且，它支持双号段，还解决了雪花 ID 系统时钟回拨问题。不过，时钟问题的解决需要弱依赖于 Zookeeper 。</p>
<p>Leaf 的诞生主要是为了解决美团各个业务线生成分布式 ID 的方法多种多样以及不可靠的问题。</p>
<p>Leaf 对原有的号段模式进行改进，比如它这里增加了双号段避免获取 DB 在获取号段的时候阻塞请求获取 ID 的线程。简单来说，就是我一个号段还没用完之前，我自己就主动提前去获取下一个号段（图片来自于美团官方文章：<a href="https://tech.meituan.com/2017/04/21/mt-leaf.html" target="_blank" rel="noopener noreferrer">《Leaf——美团点评分布式 ID 生成系统》</a>）。</p>
<p><img src="https://img-blog.csdnimg.cn/20210422144846724.png" alt=""></p>
<p>根据项目 README 介绍，在 4C8G VM 基础上，通过公司 RPC 方式调用，QPS 压测结果近 5w/s，TP999 1ms。</p>
<h4> Tinyid(滴滴)</h4>
<p><a href="https://github.com/didi/tinyid" target="_blank" rel="noopener noreferrer">Tinyid</a> 是滴滴开源的一款基于数据库号段模式的唯一 ID 生成器。</p>
<p>数据库号段模式的原理我们在上面已经介绍过了。<strong>Tinyid 有哪些亮点呢？</strong></p>
<p>为了搞清楚这个问题，我们先来看看基于数据库号段模式的简单架构方案。（图片来自于 Tinyid 的官方 wiki:<a href="https://github.com/didi/tinyid/wiki/tinyid%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D" target="_blank" rel="noopener noreferrer">《Tinyid 原理介绍》</a>）</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-4afc0e45c0c86ba5ad645d023dce11e53c2.png" alt=""></p>
<p>在这种架构模式下，我们通过 HTTP 请求向发号器服务申请唯一 ID。负载均衡 router 会把我们的请求送往其中的一台 tinyid-server。</p>
<p>这种方案有什么问题呢？在我看来（Tinyid 官方 wiki 也有介绍到），主要由下面这 2 个问题：</p>
<ul>
<li>获取新号段的情况下，程序获取唯一 ID 的速度比较慢。</li>
<li>需要保证 DB 高可用，这个是比较麻烦且耗费资源的。</li>
</ul>
<p>除此之外，HTTP 调用也存在网络开销。</p>
<p>Tinyid 的原理比较简单，其架构如下图所示：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-53f74cd615178046d6c04fe50513fee74ce.png" alt=""></p>
<p>相比于基于数据库号段模式的简单架构方案，Tinyid 方案主要做了下面这些优化：</p>
<ul>
<li><strong>双号段缓存</strong> ：为了避免在获取新号段的情况下，程序获取唯一 ID 的速度比较慢。 Tinyid 中的号段在用到一定程度的时候，就会去异步加载下一个号段，保证内存中始终有可用号段。</li>
<li><strong>增加多 db 支持</strong> ：支持多个 DB，并且，每个 DB 都能生成唯一 ID，提高了可用性。</li>
<li><strong>增加 tinyid-client</strong> ：纯本地操作，无 HTTP 请求消耗，性能和可用性都有很大提升。</li>
</ul>
<p>Tinyid 的优缺点这里就不分析了，结合数据库号段模式的优缺点和 Tinyid 的原理就能知道。</p>
<h2> 总结</h2>
<p>通过这篇文章，我基本上已经把最常见的分布式 ID 生成方案都总结了一波。</p>
<p>除了上面介绍的方式之外，像 ZooKeeper 这类中间件也可以帮助我们生成唯一 ID。<strong>没有银弹，一定要结合实际项目来选择最适合自己的方案。</strong></p>
]]></content:encoded>
      <enclosure url="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/system-design/distributed-system/id-after-the-sub-table-not-conflict.png" type="image/png"/>
    </item>
    <item>
      <title>分布式锁详解</title>
      <link>https://javaguide.cn/distributed-system/distributed-lock.html</link>
      <guid>https://javaguide.cn/distributed-system/distributed-lock.html</guid>
      <source url="https://javaguide.cn/rss.xml">分布式锁详解</source>
      <description>网上有很多分布式锁相关的文章，写了一个相对简洁易懂的版本，针对面试和工作应该够用了。 什么是分布式锁？ 对于单机多线程来说，在 Java 中，我们通常使用 ReetrantLock 类、synchronized 关键字这类 JDK 自带的 本地锁 来控制一个 JVM 进程内的多个线程对本地共享资源的访问。 下面是我对本地锁画的一张示意图。 从图中可以看出，这些线程访问共享资源是互斥的，同一时刻只有一个线程可以获取到本地锁访问共享资源。</description>
      <category>分布式</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<p>网上有很多分布式锁相关的文章，写了一个相对简洁易懂的版本，针对面试和工作应该够用了。</p>
<h2> 什么是分布式锁？</h2>
<p>对于单机多线程来说，在 Java 中，我们通常使用 <code>ReetrantLock</code> 类、<code>synchronized</code> 关键字这类 JDK 自带的 <strong>本地锁</strong> 来控制一个 JVM 进程内的多个线程对本地共享资源的访问。</p>
<p>下面是我对本地锁画的一张示意图。</p>
<p></p>
<p>从图中可以看出，这些线程访问共享资源是互斥的，同一时刻只有一个线程可以获取到本地锁访问共享资源。</p>
<p>分布式系统下，不同的服务/客户端通常运行在独立的 JVM 进程上。如果多个 JVM 进程共享同一份资源的话，使用本地锁就没办法实现资源的互斥访问了。于是，<strong>分布式锁</strong> 就诞生了。</p>
<p>举个例子：系统的订单服务一共部署了 3 份，都对外提供服务。用户下订单之前需要检查库存，为了防止超卖，这里需要加锁以实现对检查库存操作的同步访问。由于订单服务位于不同的 JVM 进程中，本地锁在这种情况下就没办法正常工作了。我们需要用到分布式锁，这样的话，即使多个线程不在同一个 JVM 进程中也能获取到同一把锁，进而实现共享资源的互斥访问。</p>
<p>下面是我对分布式锁画的一张示意图。</p>
<p></p>
<p>从图中可以看出，这些独立的进程中的线程访问共享资源是互斥的，同一时刻只有一个线程可以获取到分布式锁访问共享资源。</p>
<p>一个最基本的分布式锁需要满足：</p>
<ul>
<li><strong>互斥</strong> ：任意一个时刻，锁只能被一个线程持有；</li>
<li><strong>高可用</strong> ：锁服务是高可用的。并且，即使客户端的释放锁的代码逻辑出现问题，锁最终一定还是会被释放，不会影响其他线程对共享资源的访问。</li>
<li><strong>可重入</strong>：一个节点获取了锁之后，还可以再次获取锁。</li>
</ul>
<p>通常情况下，我们一般会选择基于 Redis 或者 ZooKeeper 实现分布式锁，Redis 用的要更多一点，我这里也以 Redis 为例介绍分布式锁的实现。</p>
<h2> 基于 Redis 实现分布式锁</h2>
<h3> 如何基于 Redis 实现一个最简易的分布式锁？</h3>
<p>不论是实现锁还是分布式锁，核心都在于“互斥”。</p>
<p>在 Redis 中， <code>SETNX</code> 命令是可以帮助我们实现互斥。<code>SETNX</code> 即 <strong>SET</strong> if <strong>N</strong>ot e<strong>X</strong>ists (对应 Java 中的 <code>setIfAbsent</code> 方法)，如果 key 不存在的话，才会设置 key 的值。如果 key 已经存在， <code>SETNX</code> 啥也不做。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>释放锁的话，直接通过 <code>DEL</code> 命令删除对应的 key 即可。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>为了误删到其他的锁，这里我们建议使用 Lua 脚本通过 key 对应的 value（唯一值）来判断。</p>
<p>选用 Lua 脚本是为了保证解锁操作的原子性。因为 Redis 在执行 Lua 脚本时，可以以原子性的方式执行，从而保证了锁释放操作的原子性。</p>
<div class="language-lua line-numbers-mode" data-ext="lua"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p></p>
<p>这是一种最简易的 Redis 分布式锁实现，实现方式比较简单，性能也很高效。不过，这种方式实现分布式锁存在一些问题。就比如应用程序遇到一些问题比如释放锁的逻辑突然挂掉，可能会导致锁无法被释放，进而造成共享资源无法再被其他线程/进程访问。</p>
<h3> 为什么要给锁设置一个过期时间？</h3>
<p>为了避免锁无法被释放，我们可以想到的一个解决办法就是：给这个 key（也就是锁） 设置一个过期时间。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li><strong>lockKey</strong> ：加锁的锁名；</li>
<li><strong>uniqueValue</strong> ：能够唯一标示锁的随机字符串；</li>
<li><strong>NX</strong> ：只有当 lockKey 对应的 key 值不存在的时候才能 SET 成功；</li>
<li><strong>EX</strong> ：过期时间设置（秒为单位）EX 3 标示这个锁有一个 3 秒的自动过期时间。与 EX 对应的是 PX（毫秒为单位），这两个都是过期时间设置。</li>
</ul>
<p><strong>一定要保证设置指定 key 的值和过期时间是一个原子操作！！！</strong> 不然的话，依然可能会出现锁无法被释放的问题。</p>
<p>这样确实可以解决问题，不过，这种解决办法同样存在漏洞：<strong>如果操作共享资源的时间大于过期时间，就会出现锁提前过期的问题，进而导致分布式锁直接失效。如果锁的超时时间设置过长，又会影响到性能。</strong></p>
<p>你或许在想： <strong>如果操作共享资源的操作还未完成，锁过期时间能够自己续期就好了！</strong></p>
<h3> 如何实现锁的优雅续期？</h3>
<p>对于 Java 开发的小伙伴来说，已经有了现成的解决方案：<strong><a href="https://github.com/redisson/redisson" target="_blank" rel="noopener noreferrer">Redisson</a></strong> 。其他语言的解决方案，可以在 Redis 官方文档中找到，地址：https://redis.io/topics/distlock 。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/redis-distributed-lock.png" alt="Distributed locks with Redis"></p>
<p>Redisson 是一个开源的 Java 语言 Redis 客户端，提供了很多开箱即用的功能，不仅仅包括多种分布式锁的实现。并且，Redisson 还支持 Redis 单机、Redis Sentinel 、Redis Cluster 等多种部署架构。</p>
<p>Redisson 中的分布式锁自带自动续期机制，使用起来非常简单，原理也比较简单，其提供了一个专门用来监控和续期锁的 <strong>Watch Dog（ 看门狗）</strong>，如果操作共享资源的线程还未执行完成的话，Watch Dog 会不断地延长锁的过期时间，进而保证锁不会因为超时而被释放。</p>
<p></p>
<p>看门狗名字的由来于 <code>getLockWatchdogTimeou()</code> 方法，这个方法返回的是看门狗给锁续期的过期时间，默认为 30 秒（<a href="https://github.com/redisson/redisson/releases/tag/redisson-3.17.6" target="_blank" rel="noopener noreferrer">redisson-3.17.6</a>）。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>renewExpiration()</code> 方法包含了看门狗的主要逻辑：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>默认情况下，每过 10 秒，看门狗就会执行续期操作，将锁的超时时间设置为 30 秒。看门狗续期前也会先判断是否需要执行续期操作，需要才会执行续期，否则取消续期操作。</p>
<p>Watch Dog 通过调用 <code>renewExpirationAsync()</code> 方法实现锁的异步续期：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看出， <code>renewExpirationAsync</code> 方法其实是调用 Lua 脚本实现的续期，这样做主要是为了保证续期操作的原子性。</p>
<p>我这里以 Redisson 的分布式可重入锁 <code>RLock</code> 为例来说明如何使用 Redisson 实现分布式锁：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>只有未指定锁超时时间，才会使用到 Watch Dog 自动续期机制。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>如果使用 Redis 来实现分布式锁的话，还是比较推荐直接基于 Redisson 来做的。</p>
<h3> Redis 如何解决集群情况下分布式锁的可靠性？</h3>
<p>为了避免单点故障，生产环境下的 Redis 服务通常是集群化部署的。</p>
<p>Redis 集群下，上面介绍到的分布式锁的实现会存在一些问题。由于 Redis 集群数据同步到各个节点时是异步的，如果在 Redis 主节点获取到锁后，在没有同步到其他节点时，Redis 主节点宕机了，此时新的 Redis 主节点依然可以获取锁，所以多个应用服务就可以同时获取到锁。</p>
<p>针对这个问题，Redis 之父 antirez 设计了 <a href="https://redis.io/topics/distlock" target="_blank" rel="noopener noreferrer">Redlock 算法</a> 来解决。</p>
<p></p>
<p>Redlock 算法的思想是让客户端向 Redis 集群中的多个独立的 Redis 实例依次请求申请加锁，如果客户端能够和半数以上的实例成功地完成加锁操作，那么我们就认为，客户端成功地获得分布式锁，否则加锁失败。</p>
<p>即使部分 Redis 节点出现问题，只要保证 Redis 集群中有半数以上的 Redis 节点可用，分布式锁服务就是正常的。</p>
<p>Redlock 是直接操作 Redis 节点的，并不是通过 Redis 集群操作的，这样才可以避免 Redis 集群主从切换导致的锁丢失问题。</p>
<p>Redlock 实现比较复杂，性能比较差，发生时钟变迁的情况下还存在安全性隐患。《数据密集型应用系统设计》一书的作者 Martin Kleppmann 曾经专门发文（<a href="https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html" target="_blank" rel="noopener noreferrer">How to do distributed locking - Martin Kleppmann - 2016</a>）怼过 Redlock，他认为这是一个很差的分布式锁实现。感兴趣的朋友可以看看<a href="https://mp.weixin.qq.com/s?__biz=Mzg3NjU3NTkwMQ==&amp;mid=2247505097&amp;idx=1&amp;sn=5c03cb769c4458350f4d4a321ad51f5a&amp;source=41#wechat_redirect" target="_blank" rel="noopener noreferrer">Redis 锁从面试连环炮聊到神仙打架</a>这篇文章，有详细介绍到 antirez 和 Martin Kleppmann 关于 Redlock 的激烈辩论。</p>
<p>实际项目中不建议使用 Redlock 算法，成本和收益不成正比。</p>
<p>如果不是非要实现绝对可靠的分布式锁的话，其实单机版 Redis 就完全够了，实现简单，性能也非常高。如果你必须要实现一个绝对可靠的分布式锁的话，可以基于 Zookeeper 来做，只是性能会差一些。</p>
]]></content:encoded>
    </item>
    <item>
      <title>分布式事务详解(付费)</title>
      <link>https://javaguide.cn/distributed-system/distributed-transaction.html</link>
      <guid>https://javaguide.cn/distributed-system/distributed-transaction.html</guid>
      <source url="https://javaguide.cn/rss.xml">分布式事务详解(付费)</source>
      <description>分布式事务 相关的面试题为我的知识星球（点击链接即可查看详细介绍以及加入方法）专属内容，已经整理到了《Java 面试指北》（点击链接即可查看详细介绍以及获取方法）中。</description>
      <category>分布式</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<p><strong>分布式事务</strong> 相关的面试题为我的<a href="https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc" target="_blank" rel="noopener noreferrer">知识星球</a>（点击链接即可查看详细介绍以及加入方法）专属内容，已经整理到了<a href="https://www.yuque.com/docs/share/f37fc804-bfe6-4b0d-b373-9c462188fec7" target="_blank" rel="noopener noreferrer">《Java 面试指北》</a>（点击链接即可查看详细介绍以及获取方法）中。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javamianshizhibei/distributed-system.png" alt=""></p>
<p><a href="https://www.yuque.com/docs/share/f37fc804-bfe6-4b0d-b373-9c462188fec7" target="_blank" rel="noopener noreferrer">《Java 面试指北》</a> 的部分内容展示如下，你可以将其看作是 <a href="https://javaguide.cn/#/" target="_blank" rel="noopener noreferrer">JavaGuide</a> 的补充完善，两者可以配合使用。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220304102536445.png" alt=""></p>
<p><a href="https://www.yuque.com/docs/share/f37fc804-bfe6-4b0d-b373-9c462188fec7" target="_blank" rel="noopener noreferrer">《Java 面试指北》</a>只是星球内部众多资料中的一个，星球还有很多其他优质资料比如<a href="https://javaguide.cn/zhuanlan/" target="_blank" rel="noopener noreferrer">专属专栏</a>、Java 编程视频、PDF 资料。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220211231206733.png" alt=""></p>
<p>最近几年，市面上有越来越多的“技术大佬”开始办培训班/训练营，动辄成千上万的学费，却并没有什么干货，单纯的就是割韭菜。</p>
<p>为了帮助更多同学准备 Java 面试以及学习 Java ，我创建了一个纯粹的<a href="https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc" target="_blank" rel="noopener noreferrer">知识星球</a>。虽然收费只有培训班/训练营的百分之一，但是<a href="https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc" target="_blank" rel="noopener noreferrer">知识星球</a>里的内容质量更高，提供的服务也更全面。</p>
<p>欢迎准备 Java 面试以及学习 Java 的同学加入我的<a href="https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc" target="_blank" rel="noopener noreferrer">知识星球</a>，干货非常多，学习氛围非常好！收费虽然是白菜价，但星球里的内容或许比你参加上万的培训班质量还要高。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220311203414600.png" alt=""></p>
<p>下面是星球提供的部分服务（点击下方图片即可获取知识星球的详细介绍）：</p>
<div align="center">
  <a href="https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html">
    <img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/xingqiufuwu.png" style="margin: 0 auto; ">
  </a>
</div>
<p>我有自己的原则，不割韭菜，用心做内容，真心希望帮助到你！</p>
<p>如果你感兴趣的话，不妨花 3 分钟左右看看星球的详细介绍： <a href="https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc" target="_blank" rel="noopener noreferrer">JavaGuide 知识星球详细介绍</a>（文末有优惠券）。</p>
<div align="center">
  <a href="https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html">
    <img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/xingqiuyouhuijuanheyi.png" style="margin: 0 auto; ">
  </a>
</div>
]]></content:encoded>
      <enclosure url="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javamianshizhibei/distributed-system.png" type="image/png"/>
    </item>
    <item>
      <title>CDN（内容分发网络）详解</title>
      <link>https://javaguide.cn/high-performance/cdn.html</link>
      <guid>https://javaguide.cn/high-performance/cdn.html</guid>
      <source url="https://javaguide.cn/rss.xml">CDN（内容分发网络）详解</source>
      <description>什么是 CDN ？ CDN 全称是 Content Delivery Network/Content Distribution Network，翻译过的意思是 内容分发网络 。 我们可以将内容分发网络拆开来看： 内容 ：指的是静态资源比如图片、视频、文档、JS、CSS、HTML。 分发网络 ：指的是将这些静态资源分发到位于多个不同的地理位置机房中的服务器上，这样，就可以实现静态资源的就近访问比如北京的用户直接访问北京机房的数据。</description>
      <category>高性能</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 什么是 CDN ？</h2>
<p><strong>CDN</strong> 全称是 Content Delivery Network/Content Distribution Network，翻译过的意思是 <strong>内容分发网络</strong> 。</p>
<p>我们可以将内容分发网络拆开来看：</p>
<ul>
<li>内容 ：指的是静态资源比如图片、视频、文档、JS、CSS、HTML。</li>
<li>分发网络 ：指的是将这些静态资源分发到位于多个不同的地理位置机房中的服务器上，这样，就可以实现静态资源的就近访问比如北京的用户直接访问北京机房的数据。</li>
</ul>
<p>所以，简单来说，<strong>CDN 就是将静态资源分发到多个不同的地方以实现就近访问，进而加快静态资源的访问速度，减轻服务器以及带宽的负担。</strong></p>
<p>类似于京东建立的庞大的仓储运输体系，京东物流在全国拥有非常多的仓库，仓储网络几乎覆盖全国所有区县。这样的话，用户下单的第一时间，商品就从距离用户最近的仓库，直接发往对应的配送站，再由京东小哥送到你家。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/high-performance/cdn/jingdong-wuliu-cangpei.png" alt="京东仓配系统"></p>
<p>你可以将 CDN 看作是服务上一层的特殊缓存服务，分布在全国各地，主要用来处理静态资源的请求。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/high-performance/cdn/cdn-101.png" alt="CDN 简易示意图"></p>
<p>我们经常拿全站加速和内容分发网络做对比，不要把两者搞混了！全站加速（不同云服务商叫法不同，腾讯云叫 ECDN、阿里云叫 DCDN）既可以加速静态资源又可以加速动态资源，内容分发网络（CDN）主要针对的是 <strong>静态资源</strong> 。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/high-performance/cdn/cdn-aliyun-dcdn.png" alt="阿里云文档：https://help.aliyun.com/document_detail/64836.html"></p>
<p>绝大部分公司都会在项目开发中交使用 CDN 服务，但很少会有自建 CDN 服务的公司。基于成本、稳定性和易用性考虑，建议直接选择专业的云厂商（比如阿里云、腾讯云、华为云、青云）或者 CDN 厂商（比如网宿、蓝汛）提供的开箱即用的 CDN 服务。</p>
<p>很多朋友可能要问了：<strong>既然是就近访问，为什么不直接将服务部署在多个不同的地方呢？</strong></p>
<ul>
<li>成本太高，需要部署多份相同的服务。</li>
<li>静态资源通常占用空间比较大且经常会被访问到，如果直接使用服务器或者缓存来处理静态资源请求的话，对系统资源消耗非常大，可能会影响到系统其他服务的正常运行。</li>
</ul>
<p>同一个服务在在多个不同的地方部署多份（比如同城灾备、异地灾备、同城多活、异地多活）是为了实现系统的高可用而不是就近访问。</p>
<h2> CDN 工作原理是什么？</h2>
<p>搞懂下面 3 个问题也就搞懂了 CDN 的工作原理：</p>
<ol>
<li>静态资源是如何被缓存到 CDN 节点中的？</li>
<li>如何找到最合适的 CDN 节点？</li>
<li>如何防止静态资源被盗用？</li>
</ol>
<h3> 静态资源是如何被缓存到 CDN 节点中的？</h3>
<p>你可以通过预热的方式将源站的资源同步到 CDN 的节点中。这样的话，用户首次请求资源可以直接从 CDN 节点中取，无需回源。这样可以降低源站压力，提升用户体验。</p>
<p>如果不预热的话，你访问的资源可能不再 CDN 节点中，这个时候 CDN 节点将请求源站获取资源，这个过程是大家经常说的 <strong>回源</strong>。</p>
<p><strong>命中率</strong> 和 <strong>回源率</strong> 是衡量 CDN 服务质量两个重要指标。命中率越高越好，回源率越低越好。</p>
<p>如果资源有更新的话，你也可以对其 <strong>刷新</strong> ，删除 CDN 节点上缓存的资源，当用户访问对应的资源时直接回源获取最新的资源，并重新缓存。</p>
<h3> 如何找到最合适的 CDN 节点？</h3>
<p>GSLB （Global Server Load Balance，全局负载均衡）是 CDN 的大脑，负责多个CDN节点之间相互协作，最常用的是基于 DNS 的 GSLB。</p>
<p>CDN 会通过 GSLB 找到最合适的 CDN 节点，更具体点来说是下面这样的：</p>
<ol>
<li>浏览器向 DNS 服务器发送域名请求；</li>
<li>DNS 服务器向根据 CNAME( Canonical Name ) 别名记录向 GSLB 发送请求；</li>
<li>GSLB 返回性能最好（通常距离请求地址最近）的 CDN 节点（边缘服务器，真正缓存内容的地方）的地址给浏览器；</li>
<li>浏览器直接访问指定的 CDN 节点。</li>
</ol>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/high-performance/cdn/cdn-overview.png" alt="CDN 原理示意图"></p>
<p>为了方便理解，上图其实做了一点简化。GSLB 内部可以看作是 CDN 专用 DNS 服务器和负载均衡系统组合。CDN 专用 DNS 服务器会返回负载均衡系统 IP 地址给浏览器，浏览器使用 IP 地址请求负载均衡系统进而找到对应的 CDN 节点。</p>
<p><strong>GSLB 是如何选择出最合适的 CDN 节点呢？</strong> GSLB 会根据请求的 IP 地址、CDN 节点状态（比如负载情况、性能、响应时间、带宽）等指标来综合判断具体返回哪一个 CDN 节点的地址。</p>
<h3> 如何防止资源被盗刷？</h3>
<p>如果我们的资源被其他用户或者网站非法盗刷的话，将会是一笔不小的开支。</p>
<p>解决这个问题最常用最简单的办法设置 <strong>Referer 防盗链</strong>，具体来说就是根据 HTTP 请求的头信息里面的 Referer 字段对请求进行限制。我们可以通过 Referer 字段获取到当前请求页面的来源页面的网站地址，这样我们就能确定请求是否来自合法的网站。</p>
<p>CDN 服务提供商几乎都提供了这种比较基础的防盗链机制。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/high-performance/cdn/cnd-tencent-cloud-anti-theft.png" alt="腾讯云 CDN Referer 防盗链配置"></p>
<p>不过，如果站点的防盗链配置允许 Referer 为空的话，通过隐藏 Referer，可以直接绕开防盗链。</p>
<p>通常情况下，我们会配合其他机制来确保静态资源被盗用，一种常用的机制是 <strong>时间戳防盗链</strong> 。相比之下，<strong>时间戳防盗链</strong> 的安全性更强一些。时间戳防盗链加密的 URL 具有时效性，过期之后就无法再被允许访问。</p>
<p>时间戳防盗链的 URL 通常会有两个参数一个是签名字符串，一个是过期时间。签名字符串一般是通过对用户设定的加密字符串、请求路径、过期时间通过  MD5 哈希算法取哈希的方式获得。</p>
<p>时间戳防盗链 URL示例：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li><code>wsSecret</code> ：签名字符串。</li>
<li><code>wsTime</code>: 过期时间。</li>
</ul>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/high-performance/cdn/timestamp-anti-theft.png" alt=""></p>
<p>时间戳防盗链的实现也比较简单，并且可靠性较高，推荐使用。并且，绝大部分 CDN 服务提供商都提供了开箱即用的时间戳防盗链机制。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/high-performance/cdn/qiniuyun-timestamp-anti-theft.png" alt="七牛云时间戳防盗链配置"></p>
<p>除了 Referer 防盗链和时间戳防盗链之外，你还可以 IP 黑白名单配置、IP 访问限频配置等机制来防盗刷。</p>
<h2> 总结</h2>
<ul>
<li>CDN 就是将静态资源分发到多个不同的地方以实现就近访问，进而加快静态资源的访问速度，减轻服务器以及带宽的负担。</li>
<li>基于成本、稳定性和易用性考虑，建议直接选择专业的云厂商（比如阿里云、腾讯云、华为云、青云）或者 CDN 厂商（比如网宿、蓝汛）提供的开箱即用的 CDN 服务。</li>
<li>GSLB （Global Server Load Balance，全局负载均衡）是 CDN 的大脑，负责多个 CDN 节点之间相互协作，最常用的是基于 DNS 的 GSLB。CDN 会通过 GSLB 找到最合适的 CDN 节点。</li>
<li>为了防止静态资源被盗用，我们可以利用 <strong>Referer 防盗链</strong> + <strong>时间戳防盗链</strong> 。</li>
</ul>
<h2> 参考</h2>
<ul>
<li>时间戳防盗链 - 七牛云 CDN：https://developer.qiniu.com/fusion/kb/1670/timestamp-hotlinking-prevention</li>
<li>CDN是个啥玩意？一文说个明白：https://mp.weixin.qq.com/s/Pp0C8ALUXsmYCUkM5QnkQw</li>
<li>《透视 HTTP 协议》- 37 | CDN：加速我们的网络服务：http://gk.link/a/11yOG</li>
</ul>
]]></content:encoded>
      <enclosure url="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/high-performance/cdn/jingdong-wuliu-cangpei.png" type="image/png"/>
    </item>
    <item>
      <title>负载均衡详解（付费）</title>
      <link>https://javaguide.cn/high-performance/load-balancing.html</link>
      <guid>https://javaguide.cn/high-performance/load-balancing.html</guid>
      <source url="https://javaguide.cn/rss.xml">负载均衡详解（付费）</source>
      <description>负载均衡 相关的面试题为我的知识星球（点击链接即可查看详细介绍以及加入方法）专属内容，已经整理到了《Java 面试指北》（点击链接即可查看详细介绍以及获取方法）中。</description>
      <category>高性能</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<p><strong>负载均衡</strong> 相关的面试题为我的<a href="https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc" target="_blank" rel="noopener noreferrer">知识星球</a>（点击链接即可查看详细介绍以及加入方法）专属内容，已经整理到了<a href="https://www.yuque.com/docs/share/f37fc804-bfe6-4b0d-b373-9c462188fec7" target="_blank" rel="noopener noreferrer">《Java 面试指北》</a>（点击链接即可查看详细介绍以及获取方法）中。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javamianshizhibei/sql-optimization.png" alt=""></p>
<p><a href="https://www.yuque.com/docs/share/f37fc804-bfe6-4b0d-b373-9c462188fec7" target="_blank" rel="noopener noreferrer">《Java 面试指北》</a> 的部分内容展示如下，你可以将其看作是 <a href="https://javaguide.cn/#/" target="_blank" rel="noopener noreferrer">JavaGuide</a> 的补充完善，两者可以配合使用。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220304102536445.png" alt=""></p>
<p><a href="https://www.yuque.com/docs/share/f37fc804-bfe6-4b0d-b373-9c462188fec7" target="_blank" rel="noopener noreferrer">《Java 面试指北》</a>只是星球内部众多资料中的一个，星球还有很多其他优质资料比如<a href="https://javaguide.cn/zhuanlan/" target="_blank" rel="noopener noreferrer">专属专栏</a>、Java 编程视频、PDF 资料。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220211231206733.png" alt=""></p>
<p>最近几年，市面上有越来越多的“技术大佬”开始办培训班/训练营，动辄成千上万的学费，却并没有什么干货，单纯的就是割韭菜。</p>
<p>为了帮助更多同学准备 Java 面试以及学习 Java ，我创建了一个纯粹的<a href="https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc" target="_blank" rel="noopener noreferrer">知识星球</a>。虽然收费只有培训班/训练营的百分之一，但是<a href="https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc" target="_blank" rel="noopener noreferrer">知识星球</a>里的内容质量更高，提供的服务也更全面。</p>
<p>欢迎准备 Java 面试以及学习 Java 的同学加入我的<a href="https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc" target="_blank" rel="noopener noreferrer">知识星球</a>，干货非常多，学习氛围非常好！收费虽然是白菜价，但星球里的内容或许比你参加上万的培训班质量还要高。</p>
<p>下面是星球提供的部分服务（点击下方图片即可获取知识星球的详细介绍）：</p>
<div align="center">
  <a href="https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html">
    <img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/xingqiufuwu.png" style="margin: 0 auto; ">
  </a>
</div>
<p>我有自己的原则，不割韭菜，用心做内容，真心希望帮助到你！</p>
<p>如果你感兴趣的话，不妨花 3 分钟左右看看星球的详细介绍： <a href="https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc" target="_blank" rel="noopener noreferrer">JavaGuide 知识星球详细介绍</a>（文末有优惠券）。</p>
<div align="center">
  <a href="https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html">
    <img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/xingqiuyouhuijuanheyi.png" style="margin: 0 auto; ">
  </a>
</div>
]]></content:encoded>
      <enclosure url="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javamianshizhibei/sql-optimization.png" type="image/png"/>
    </item>
    <item>
      <title>读写分离和分库分表详解</title>
      <link>https://javaguide.cn/high-performance/read-and-write-separation-and-library-subtable.html</link>
      <guid>https://javaguide.cn/high-performance/read-and-write-separation-and-library-subtable.html</guid>
      <source url="https://javaguide.cn/rss.xml">读写分离和分库分表详解</source>
      <description>读写分离 什么是读写分离？ 见名思意，根据读写分离的名字，我们就可以知道：读写分离主要是为了将对数据库的读写操作分散到不同的数据库节点上。 这样的话，就能够小幅提升写性能，大幅提升读性能。 我简单画了一张图来帮助不太清楚读写分离的小伙伴理解。</description>
      <category>高性能</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 读写分离</h2>
<h3> 什么是读写分离？</h3>
<p>见名思意，根据读写分离的名字，我们就可以知道：<strong>读写分离主要是为了将对数据库的读写操作分散到不同的数据库节点上。</strong> 这样的话，就能够小幅提升写性能，大幅提升读性能。</p>
<p>我简单画了一张图来帮助不太清楚读写分离的小伙伴理解。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/high-performance/read-and-write-separation-and-library-subtable/read-and-write-separation.png" alt="读写分离示意图"></p>
<p>一般情况下，我们都会选择一主多从，也就是一台主数据库负责写，其他的从数据库负责读。主库和从库之间会进行数据同步，以保证从库中数据的准确性。这样的架构实现起来比较简单，并且也符合系统的写少读多的特点。</p>
<h3> 读写分离会带来什么问题？如何解决？</h3>
<p>读写分离对于提升数据库的并发非常有效，但是，同时也会引来一个问题：主库和从库的数据存在延迟，比如你写完主库之后，主库的数据同步到从库是需要时间的，这个时间差就导致了主库和从库的数据不一致性问题。这也就是我们经常说的 <strong>主从同步延迟</strong> 。</p>
<p>主从同步延迟问题的解决，没有特别好的一种方案（可能是我太菜了，欢迎评论区补充）。你可以根据自己的业务场景，参考一下下面几种解决办法。</p>
<p><strong>1.强制将读请求路由到主库处理。</strong></p>
<p>既然你从库的数据过期了，那我就直接从主库读取嘛！这种方案虽然会增加主库的压力，但是，实现起来比较简单，也是我了解到的使用最多的一种方式。</p>
<p>比如 <code>Sharding-JDBC</code> 就是采用的这种方案。通过使用 Sharding-JDBC 的 <code>HintManager</code> 分片键值管理器，我们可以强制使用主库。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于这种方案，你可以将那些必须获取最新数据的读请求都交给主库处理。</p>
<p><strong>2.延迟读取。</strong></p>
<p>还有一些朋友肯定会想既然主从同步存在延迟，那我就在延迟之后读取啊，比如主从同步延迟 0.5s,那我就 1s 之后再读取数据。这样多方便啊！方便是方便，但是也很扯淡。</p>
<p>不过，如果你是这样设计业务流程就会好很多：对于一些对数据比较敏感的场景，你可以在完成写请求之后，避免立即进行请求操作。比如你支付成功之后，跳转到一个支付成功的页面，当你点击返回之后才返回自己的账户。</p>
<p>另外，<a href="https://time.geekbang.org/column/intro/100020801?code=ieY8HeRSlDsFbuRtggbBQGxdTh-1jMASqEIeqzHAKrI%3D" target="_blank" rel="noopener noreferrer">《MySQL 实战 45 讲》</a>这个专栏中的<a href="https://time.geekbang.org/column/article/77636" target="_blank" rel="noopener noreferrer">《读写分离有哪些坑？》</a>这篇文章还介绍了很多其他比较实际的解决办法，感兴趣的小伙伴可以自行研究一下。</p>
<h3> 如何实现读写分离？</h3>
<p>不论是使用哪一种读写分离具体的实现方案，想要实现读写分离一般包含如下几步：</p>
<ol>
<li>部署多台数据库，选择其中的一台作为主数据库，其他的一台或者多台作为从数据库。</li>
<li>保证主数据库和从数据库之间的数据是实时同步的，这个过程也就是我们常说的<strong>主从复制</strong>。</li>
<li>系统将写请求交给主数据库处理，读请求交给从数据库处理。</li>
</ol>
<p>落实到项目本身的话，常用的方式有两种：</p>
<p><strong>1.代理方式</strong></p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/high-performance/read-and-write-separation-and-library-subtable/read-and-write-separation-proxy.png" alt="代理方式实现读写分离"></p>
<p>我们可以在应用和数据中间加了一个代理层。应用程序所有的数据请求都交给代理层处理，代理层负责分离读写请求，将它们路由到对应的数据库中。</p>
<p>提供类似功能的中间件有 <strong>MySQL Router</strong>（官方）、<strong>Atlas</strong>（基于 MySQL Proxy）、<strong>Maxscale</strong>、<strong>MyCat</strong>。</p>
<p><strong>2.组件方式</strong></p>
<p>在这种方式中，我们可以通过引入第三方组件来帮助我们读写请求。</p>
<p>这也是我比较推荐的一种方式。这种方式目前在各种互联网公司中用的最多的，相关的实际的案例也非常多。如果你要采用这种方式的话，推荐使用 <code>sharding-jdbc</code> ，直接引入 jar 包即可使用，非常方便。同时，也节省了很多运维的成本。</p>
<p>你可以在 shardingsphere 官方找到 <a href="https://shardingsphere.apache.org/document/legacy/3.x/document/cn/manual/sharding-jdbc/usage/read-write-splitting/" target="_blank" rel="noopener noreferrer">sharding-jdbc 关于读写分离的操作</a>。</p>
<h3> 主从复制原理是什么？</h3>
<p>MySQL binlog(binary log 即二进制日志文件) 主要记录了 MySQL 数据库中数据的所有变化(数据库执行的所有 DDL 和 DML 语句)。因此，我们根据主库的 MySQL binlog 日志就能够将主库的数据同步到从库中。</p>
<p>更具体和详细的过程是这个样子的（图片来自于：<a href="https://www.toptal.com/mysql/mysql-master-slave-replication-tutorial" target="_blank" rel="noopener noreferrer">《MySQL Master-Slave Replication on the Same Machine》</a>）：</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/java-guide-blog/78816271d3ab52424bfd5ad3086c1a0f.png" alt="MySQL主从复制"></p>
<ol>
<li>主库将数据库中数据的变化写入到 binlog</li>
<li>从库连接主库</li>
<li>从库会创建一个 I/O 线程向主库请求更新的 binlog</li>
<li>主库会创建一个 binlog dump 线程来发送 binlog ，从库中的 I/O 线程负责接收</li>
<li>从库的 I/O 线程将接收的 binlog 写入到 relay log 中。</li>
<li>从库的 SQL 线程读取 relay log 同步数据本地（也就是再执行一遍 SQL ）。</li>
</ol>
<p>怎么样？看了我对主从复制这个过程的讲解，你应该搞明白了吧!</p>
<p>你一般看到 binlog 就要想到主从复制。当然，除了主从复制之外，binlog 还能帮助我们实现数据恢复。</p>
<p>🌈 拓展一下：</p>
<p>不知道大家有没有使用过阿里开源的一个叫做 canal 的工具。这个工具可以帮助我们实现 MySQL 和其他数据源比如 Elasticsearch 或者另外一台 MySQL 数据库之间的数据同步。很显然，这个工具的底层原理肯定也是依赖 binlog。canal 的原理就是模拟 MySQL 主从复制的过程，解析 binlog 将数据同步到其他的数据源。</p>
<p>另外，像咱们常用的分布式缓存组件 Redis 也是通过主从复制实现的读写分离。</p>
<p>🌕 简单总结一下：</p>
<p><strong>MySQL 主从复制是依赖于 binlog 。另外，常见的一些同步 MySQL 数据到其他数据源的工具（比如 canal）的底层一般也是依赖 binlog 。</strong></p>
<h2> 分库分表</h2>
<p>读写分离主要应对的是数据库读并发，没有解决数据库存储问题。试想一下：<strong>如果 MySQL 一张表的数据量过大怎么办?</strong></p>
<p>换言之，<strong>我们该如何解决 MySQL 的存储压力呢？</strong></p>
<p>答案之一就是 <strong>分库分表</strong>。</p>
<h3> 什么是分库？</h3>
<p><strong>分库</strong> 就是将数据库中的数据分散到不同的数据库上，可以垂直分库，也可以水平分库。</p>
<p><strong>垂直分库</strong> 就是把单一数据库按照业务进行划分，不同的业务使用不同的数据库，进而将一个数据库的压力分担到多个数据库。</p>
<p>举个例子：说你将数据库中的用户表、订单表和商品表分别单独拆分为用户数据库、订单数据库和商品数据库。</p>
<p></p>
<p><strong>水平分库</strong> 是把同一个表按一定规则拆分到不同的数据库中，每个库可以位于不同的服务器上，这样就实现了水平扩展，解决了单表的存储和性能瓶颈的问题。</p>
<p>举个例子：订单表数据量太大，你对订单表进行了水平切分（水平分表），然后将切分后的 2 张订单表分别放在两个不同的数据库。</p>
<p></p>
<h3> 什么是分表？</h3>
<p><strong>分表</strong> 就是对单表的数据进行拆分，可以是垂直拆分，也可以是水平拆分。</p>
<p><strong>垂直分表</strong> 是对数据表列的拆分，把一张列比较多的表拆分为多张表。</p>
<p>举个例子：我们可以将用户信息表中的一些列单独抽出来作为一个表。</p>
<p><strong>水平分表</strong> 是对数据表行的拆分，把一张行比较多的表拆分为多张表，可以解决单一表数据量过大的问题。</p>
<p>举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。</p>
<p>水平拆分只能解决单表数据量大的问题，为了提升性能，我们通常会选择将拆分后的多张表放在不同的数据库中。也就是说，水平分表通常和水平分库同时出现。</p>
<p></p>
<h3> 什么情况下需要分库分表？</h3>
<p>遇到下面几种场景可以考虑分库分表：</p>
<ul>
<li>单表的数据达到千万级别以上，数据库读写速度比较缓慢。</li>
<li>数据库中的数据占用的空间越来越大，备份时间越来越长。</li>
<li>应用的并发量太大。</li>
</ul>
<h3> 常见的分片算法有哪些？</h3>
<p>分片算法主要解决了数据被水平分片之后，数据究竟该存放在哪个表的问题。</p>
<ul>
<li><strong>哈希分片</strong> ：求指定 key（比如 id） 的哈希，然后根据哈希值确定数据应被放置在哪个表中。哈希分片比较适合随机读写的场景，不太适合经常需要范围查询的场景。</li>
<li><strong>范围分片</strong> ：按照特性的范围区间（比如时间区间、ID区间）来分配数据，比如 将 <code>id</code> 为 <code>1~299999</code> 的记录分到第一个库， <code>300000~599999</code> 的分到第二个库。范围分片适合需要经常进行范围查找的场景，不太适合随机读写的场景（数据未被分散，容易出现热点数据的问题）。</li>
<li><strong>地理位置分片</strong> ：很多 NewSQL 数据库都支持地理位置分片算法，也就是根据地理位置（如城市、地域）来分配数据。</li>
<li><strong>融合算法</strong> ：灵活组合多种分片算法，比如将哈希分片和范围分片组合。</li>
<li>......</li>
</ul>
<h3> 分库分表会带来什么问题呢？</h3>
<p>记住，你在公司做的任何技术决策，不光是要考虑这个技术能不能满足我们的要求，是否适合当前业务场景，还要重点考虑其带来的成本。</p>
<p>引入分库分表之后，会给系统带来什么挑战呢？</p>
<ul>
<li><strong>join 操作</strong> ： 同一个数据库中的表分布在了不同的数据库中，导致无法使用 join 操作。这样就导致我们需要手动进行数据的封装，比如你在一个数据库中查询到一个数据之后，再根据这个数据去另外一个数据库中找对应的数据。</li>
<li><strong>事务问题</strong> ：同一个数据库中的表分布在了不同的数据库中，如果单个操作涉及到多个数据库，那么数据库自带的事务就无法满足我们的要求了。</li>
<li><strong>分布式 id</strong> ：分库之后， 数据遍布在不同服务器上的数据库，数据库的自增主键已经没办法满足生成的主键唯一了。我们如何为不同的数据节点生成全局唯一主键呢？这个时候，我们就需要为我们的系统引入分布式 id 了。</li>
<li>......</li>
</ul>
<p>另外，引入分库分表之后，一般需要 DBA 的参与，同时还需要更多的数据库服务器，这些都属于成本。</p>
<h3> 分库分表有没有什么比较推荐的方案？</h3>
<p>ShardingSphere 项目（包括 Sharding-JDBC、Sharding-Proxy 和 Sharding-Sidecar）是当当捐入 Apache 的，目前主要由京东数科的一些巨佬维护。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/60649996bfc69acb1953063dddf0c2e6.png" alt=""></p>
<p>ShardingSphere 绝对可以说是当前分库分表的首选！ShardingSphere 的功能完善，除了支持读写分离和分库分表，还提供分布式事务、数据库治理等功能。</p>
<p>另外，ShardingSphere 的生态体系完善，社区活跃，文档完善，更新和发布比较频繁。</p>
<p>艿艿之前写了一篇分库分表的实战文章，各位朋友可以看看：<a href="https://mp.weixin.qq.com/s/A2MYOFT7SP-7kGOon8qJaw" target="_blank" rel="noopener noreferrer">《芋道 Spring Boot 分库分表入门》</a> 。</p>
<h3> 分库分表后，数据怎么迁移呢？</h3>
<p>分库分表之后，我们如何将老库（单库单表）的数据迁移到新库（分库分表后的数据库系统）呢？</p>
<p>比较简单同时也是非常常用的方案就是<strong>停机迁移</strong>，写个脚本老库的数据写到新库中。比如你在凌晨 2 点，系统使用的人数非常少的时候，挂一个公告说系统要维护升级预计 1 小时。然后，你写一个脚本将老库的数据都同步到新库中。</p>
<p>如果你不想停机迁移数据的话，也可以考虑<strong>双写方案</strong>。双写方案是针对那种不能停机迁移的场景，实现起来要稍微麻烦一些。具体原理是这样的：</p>
<ul>
<li>我们对老库的更新操作（增删改），同时也要写入新库（双写）。如果操作的数据不存在于新库的话，需要插入到新库中。 这样就能保证，咱们新库里的数据是最新的。</li>
<li>在迁移过程，双写只会让被更新操作过的老库中的数据同步到新库，我们还需要自己写脚本将老库中的数据和新库的数据做比对。如果新库中没有，那咱们就把数据插入到新库。如果新库有，旧库没有，就把新库对应的数据删除（冗余数据清理）。</li>
<li>重复上一步的操作，直到老库和新库的数据一致为止。</li>
</ul>
<p>想要在项目中实施双写还是比较麻烦的，很容易会出现问题。我们可以借助上面提到的数据库同步工具 Canal 做增量数据迁移（还是依赖 binlog，开发和维护成本较低）。</p>
<h2> 总结</h2>
<ul>
<li>读写分离主要是为了将对数据库的读写操作分散到不同的数据库节点上。 这样的话，就能够小幅提升写性能，大幅提升读性能。</li>
<li>读写分离基于主从复制，MySQL 主从复制是依赖于 binlog 。</li>
<li><strong>分库</strong> 就是将数据库中的数据分散到不同的数据库上。<strong>分表</strong> 就是对单表的数据进行拆分，可以是垂直拆分，也可以是水平拆分。</li>
<li>引入分库分表之后，需要系统解决事务、分布式 id、无法 join 操作问题。</li>
<li>ShardingSphere 绝对可以说是当前分库分表的首选！ShardingSphere 的功能完善，除了支持读写分离和分库分表，还提供分布式事务、数据库治理等功能。另外，ShardingSphere 的生态体系完善，社区活跃，文档完善，更新和发布比较频繁。</li>
</ul>
]]></content:encoded>
      <enclosure url="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/high-performance/read-and-write-separation-and-library-subtable/read-and-write-separation.png" type="image/png"/>
    </item>
    <item>
      <title>常见 SQL 优化手段总结（付费）</title>
      <link>https://javaguide.cn/high-performance/sql-optimization.html</link>
      <guid>https://javaguide.cn/high-performance/sql-optimization.html</guid>
      <source url="https://javaguide.cn/rss.xml">常见 SQL 优化手段总结（付费）</source>
      <description>常见 SQL 优化手段总结 为我的知识星球（点击链接即可查看详细介绍以及加入方法）专属内容，已经整理到了《Java 面试指北》（点击链接即可查看详细介绍以及获取方法）中。</description>
      <category>高性能</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<p><strong>常见 SQL 优化手段总结</strong> 为我的<a href="https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc" target="_blank" rel="noopener noreferrer">知识星球</a>（点击链接即可查看详细介绍以及加入方法）专属内容，已经整理到了<a href="https://www.yuque.com/docs/share/f37fc804-bfe6-4b0d-b373-9c462188fec7" target="_blank" rel="noopener noreferrer">《Java 面试指北》</a>（点击链接即可查看详细介绍以及获取方法）中。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javamianshizhibei/sql-optimization.png" alt=""></p>
<p><a href="https://www.yuque.com/docs/share/f37fc804-bfe6-4b0d-b373-9c462188fec7" target="_blank" rel="noopener noreferrer">《Java 面试指北》</a> 的部分内容展示如下，你可以将其看作是 <a href="https://javaguide.cn/#/" target="_blank" rel="noopener noreferrer">JavaGuide</a> 的补充完善，两者可以配合使用。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220304102536445.png" alt=""></p>
<p><a href="https://www.yuque.com/docs/share/f37fc804-bfe6-4b0d-b373-9c462188fec7" target="_blank" rel="noopener noreferrer">《Java 面试指北》</a>只是星球内部众多资料中的一个，星球还有很多其他优质资料比如<a href="https://javaguide.cn/zhuanlan/" target="_blank" rel="noopener noreferrer">专属专栏</a>、Java 编程视频、PDF 资料。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220211231206733.png" alt=""></p>
<p>最近几年，市面上有越来越多的“技术大佬”开始办培训班/训练营，动辄成千上万的学费，却并没有什么干货，单纯的就是割韭菜。</p>
<p>为了帮助更多同学准备 Java 面试以及学习 Java ，我创建了一个纯粹的<a href="https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc" target="_blank" rel="noopener noreferrer">知识星球</a>。虽然收费只有培训班/训练营的百分之一，但是<a href="https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc" target="_blank" rel="noopener noreferrer">知识星球</a>里的内容质量更高，提供的服务也更全面。</p>
<p>欢迎准备 Java 面试以及学习 Java 的同学加入我的<a href="https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc" target="_blank" rel="noopener noreferrer">知识星球</a>，干货非常多，学习氛围非常好！收费虽然是白菜价，但星球里的内容或许比你参加上万的培训班质量还要高。</p>
<p>下面是星球提供的部分服务（点击下方图片即可获取知识星球的详细介绍）：</p>
<div align="center">
  <a href="https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html">
    <img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/xingqiufuwu.png" style="margin: 0 auto; ">
  </a>
</div>
<p>我有自己的原则，不割韭菜，用心做内容，真心希望帮助到你！</p>
<p>如果你感兴趣的话，不妨花 3 分钟左右看看星球的详细介绍： <a href="https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc" target="_blank" rel="noopener noreferrer">JavaGuide 知识星球详细介绍</a>（文末有优惠券）。</p>
<div align="center">
  <a href="https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html">
    <img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/xingqiuyouhuijuanheyi.png" style="margin: 0 auto; ">
  </a>
</div>
]]></content:encoded>
      <enclosure url="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javamianshizhibei/sql-optimization.png" type="image/png"/>
    </item>
    <item>
      <title>降级&amp;熔断详解(付费)</title>
      <link>https://javaguide.cn/high-availability/fallback_circuit-breaker.html</link>
      <guid>https://javaguide.cn/high-availability/fallback_circuit-breaker.html</guid>
      <source url="https://javaguide.cn/rss.xml">降级&amp;熔断详解(付费)</source>
      <description>降级&amp;amp;熔断 相关的面试题为我的知识星球（点击链接即可查看详细介绍以及加入方法）专属内容，已经整理到了《Java 面试指北》（点击链接即可查看详细介绍以及获取方法）中。</description>
      <category>高可用</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<p><strong>降级&amp;熔断</strong> 相关的面试题为我的<a href="https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc" target="_blank" rel="noopener noreferrer">知识星球</a>（点击链接即可查看详细介绍以及加入方法）专属内容，已经整理到了<a href="https://www.yuque.com/docs/share/f37fc804-bfe6-4b0d-b373-9c462188fec7" target="_blank" rel="noopener noreferrer">《Java 面试指北》</a>（点击链接即可查看详细介绍以及获取方法）中。</p>
<p><a href="https://www.yuque.com/docs/share/f37fc804-bfe6-4b0d-b373-9c462188fec7" target="_blank" rel="noopener noreferrer">《Java 面试指北》</a> 的部分内容展示如下，你可以将其看作是 <a href="https://javaguide.cn/#/" target="_blank" rel="noopener noreferrer">JavaGuide</a> 的补充完善，两者可以配合使用。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220304102536445.png" alt=""></p>
<p><a href="https://www.yuque.com/docs/share/f37fc804-bfe6-4b0d-b373-9c462188fec7" target="_blank" rel="noopener noreferrer">《Java 面试指北》</a>只是星球内部众多资料中的一个，星球还有很多其他优质资料比如<a href="https://javaguide.cn/zhuanlan/" target="_blank" rel="noopener noreferrer">专属专栏</a>、Java 编程视频、PDF 资料。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220211231206733.png" alt=""></p>
<p>最近几年，市面上有越来越多的“技术大佬”开始办培训班/训练营，动辄成千上万的学费，却并没有什么干货，单纯的就是割韭菜。</p>
<p>为了帮助更多同学准备 Java 面试以及学习 Java ，我创建了一个纯粹的<a href="https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc" target="_blank" rel="noopener noreferrer">知识星球</a>。虽然收费只有培训班/训练营的百分之一，但是<a href="https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc" target="_blank" rel="noopener noreferrer">知识星球</a>里的内容质量更高，提供的服务也更全面。</p>
<p>欢迎准备 Java 面试以及学习 Java 的同学加入我的<a href="https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc" target="_blank" rel="noopener noreferrer">知识星球</a>，干货非常多，学习氛围非常好！收费虽然是白菜价，但星球里的内容或许比你参加上万的培训班质量还要高。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220311203414600.png" alt=""></p>
<p>下面是星球提供的部分服务（点击下方图片即可获取知识星球的详细介绍）：</p>
<div align="center">
  <a href="https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html">
    <img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/xingqiufuwu.png" style="margin: 0 auto; ">
  </a>
</div>
<p>我有自己的原则，不割韭菜，用心做内容，真心希望帮助到你！</p>
<p>如果你感兴趣的话，不妨花 3 分钟左右看看星球的详细介绍： <a href="https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc" target="_blank" rel="noopener noreferrer">JavaGuide 知识星球详细介绍</a>（文末有优惠券）。</p>
<div align="center">
  <a href="https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html">
    <img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/xingqiuyouhuijuanheyi.png" style="margin: 0 auto; ">
  </a>
</div>
]]></content:encoded>
      <enclosure url="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220304102536445.png" type="image/png"/>
    </item>
    <item>
      <title>高可用系统设计指南</title>
      <link>https://javaguide.cn/high-availability/high-availability-system-design.html</link>
      <guid>https://javaguide.cn/high-availability/high-availability-system-design.html</guid>
      <source url="https://javaguide.cn/rss.xml">高可用系统设计指南</source>
      <description>什么是高可用？可用性的判断标准是啥？ 高可用描述的是一个系统在大部分时间都是可用的，可以为我们提供服务的。高可用代表系统即使在发生硬件故障或者系统升级的时候，服务仍然是可用的。 一般情况下，我们使用多少个 9 来评判一个系统的可用性，比如 99.9999% 就是代表该系统在所有的运行时间中只有 0.0001% 的时间是不可用的，这样的系统就是非常非常高可用的了！当然，也会有系统如果可用性不太好的话，可能连 9 都上不了。 除此之外，系统的可用性还可以用某功能的失败次数与总的请求次数之比来衡量，比如对网站请求 1000 次，其中有 10 次请求失败，那么可用性就是 99%。</description>
      <category>高可用</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 什么是高可用？可用性的判断标准是啥？</h2>
<p>高可用描述的是一个系统在大部分时间都是可用的，可以为我们提供服务的。高可用代表系统即使在发生硬件故障或者系统升级的时候，服务仍然是可用的。</p>
<p>一般情况下，我们使用多少个 9 来评判一个系统的可用性，比如 99.9999% 就是代表该系统在所有的运行时间中只有 0.0001% 的时间是不可用的，这样的系统就是非常非常高可用的了！当然，也会有系统如果可用性不太好的话，可能连 9 都上不了。</p>
<p>除此之外，系统的可用性还可以用某功能的失败次数与总的请求次数之比来衡量，比如对网站请求 1000 次，其中有 10 次请求失败，那么可用性就是 99%。</p>
<h2> 哪些情况会导致系统不可用？</h2>
<ol>
<li>黑客攻击；</li>
<li>硬件故障，比如服务器坏掉。</li>
<li>并发量/用户请求量激增导致整个服务宕掉或者部分服务不可用。</li>
<li>代码中的坏味道导致内存泄漏或者其他问题导致程序挂掉。</li>
<li>网站架构某个重要的角色比如 Nginx 或者数据库突然不可用。</li>
<li>自然灾害或者人为破坏。</li>
<li>......</li>
</ol>
<h2> 有哪些提高系统可用性的方法？</h2>
<h3> 注重代码质量，测试严格把关</h3>
<p>我觉得这个是最最最重要的，代码质量有问题比如比较常见的内存泄漏、循环依赖都是对系统可用性极大的损害。大家都喜欢谈限流、降级、熔断，但是我觉得从代码质量这个源头把关是首先要做好的一件很重要的事情。如何提高代码质量？比较实际可用的就是 CodeReview，不要在乎每天多花的那 1 个小时左右的时间，作用可大着呢！</p>
<p>另外，安利几个对提高代码质量有实际效果的神器：</p>
<ul>
<li><a href="https://www.sonarqube.org/" target="_blank" rel="noopener noreferrer">Sonarqube</a>；</li>
<li>Alibaba 开源的 Java 诊断工具 <a href="https://arthas.aliyun.com/doc/" target="_blank" rel="noopener noreferrer">Arthas</a>；</li>
<li><a href="https://github.com/alibaba/p3c" target="_blank" rel="noopener noreferrer">阿里巴巴 Java 代码规范</a>（Alibaba Java Code Guidelines）；</li>
<li>IDEA 自带的代码分析等工具。</li>
</ul>
<h3> 使用集群，减少单点故障</h3>
<p>先拿常用的 Redis 举个例子！我们如何保证我们的 Redis 缓存高可用呢？答案就是使用集群，避免单点故障。当我们使用一个 Redis 实例作为缓存的时候，这个 Redis 实例挂了之后，整个缓存服务可能就挂了。使用了集群之后，即使一台 Redis 实例挂了，不到一秒就会有另外一台 Redis 实例顶上。</p>
<h3> 限流</h3>
<p>流量控制（flow control），其原理是监控应用流量的 QPS 或并发线程数等指标，当达到指定的阈值时对流量进行控制，以避免被瞬时的流量高峰冲垮，从而保障应用的高可用性。——来自 <a href="https://github.com/alibaba/Sentinel" title="Sentinel" target="_blank" rel="noopener noreferrer">alibaba-Sentinel</a> 的 wiki。</p>
<h3> 超时和重试机制设置</h3>
<p>一旦用户请求超过某个时间的得不到响应，就抛出异常。这个是非常重要的，很多线上系统故障都是因为没有进行超时设置或者超时设置的方式不对导致的。我们在读取第三方服务的时候，尤其适合设置超时和重试机制。一般我们使用一些 RPC 框架的时候，这些框架都自带的超时重试的配置。如果不进行超时设置可能会导致请求响应速度慢，甚至导致请求堆积进而让系统无法再处理请求。重试的次数一般设为 3 次，再多次的重试没有好处，反而会加重服务器压力（部分场景使用失败重试机制会不太适合）。</p>
<h3> 熔断机制</h3>
<p>超时和重试机制设置之外，熔断机制也是很重要的。 熔断机制说的是系统自动收集所依赖服务的资源使用情况和性能指标，当所依赖的服务恶化或者调用失败次数达到某个阈值的时候就迅速失败，让当前系统立即切换依赖其他备用服务。 比较常用的流量控制和熔断降级框架是 Netflix 的 Hystrix 和 alibaba 的 Sentinel。</p>
<h3> 异步调用</h3>
<p>异步调用的话我们不需要关心最后的结果，这样我们就可以用户请求完成之后就立即返回结果，具体处理我们可以后续再做，秒杀场景用这个还是蛮多的。但是，使用异步之后我们可能需要 <strong>适当修改业务流程进行配合</strong>，比如<strong>用户在提交订单之后，不能立即返回用户订单提交成功，需要在消息队列的订单消费者进程真正处理完该订单之后，甚至出库后，再通过电子邮件或短信通知用户订单成功</strong>。除了可以在程序中实现异步之外，我们常常还使用消息队列，消息队列可以通过异步处理提高系统性能（削峰、减少响应所需时间）并且可以降低系统耦合性。</p>
<h3> 使用缓存</h3>
<p>如果我们的系统属于并发量比较高的话，如果我们单纯使用数据库的话，当大量请求直接落到数据库可能数据库就会直接挂掉。使用缓存缓存热点数据，因为缓存存储在内存中，所以速度相当地快！</p>
<h3> 其他</h3>
<ul>
<li><strong>核心应用和服务优先使用更好的硬件</strong></li>
<li><strong>监控系统资源使用情况增加报警设置。</strong></li>
<li><strong>注意备份，必要时候回滚。</strong></li>
<li><strong>灰度发布：</strong> 将服务器集群分成若干部分，每天只发布一部分机器，观察运行稳定没有故障，第二天继续发布一部分机器，持续几天才把整个集群全部发布完毕，期间如果发现问题，只需要回滚已发布的一部分服务器即可</li>
<li><strong>定期检查/更换硬件：</strong> 如果不是购买的云服务的话，定期还是需要对硬件进行一波检查的，对于一些需要更换或者升级的硬件，要及时更换或者升级。</li>
<li>.....</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>服务限流详解</title>
      <link>https://javaguide.cn/high-availability/limit-request.html</link>
      <guid>https://javaguide.cn/high-availability/limit-request.html</guid>
      <source url="https://javaguide.cn/rss.xml">服务限流详解</source>
      <description>针对软件系统来说，限流就是对请求的速率进行限制，避免瞬时的大量请求击垮软件系统。毕竟，软件系统的处理能力是有限的。如果说超过了其处理能力的范围，软件系统可能直接就挂掉了。 限流可能会导致用户的请求无法被正确处理，不过，这往往也是权衡了软件系统的稳定性之后得到的最优解。 现实生活中，处处都有限流的实际应用，就比如排队买票是为了避免大量用户涌入购票而导致售票员无法处理。</description>
      <category>高可用</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<p>针对软件系统来说，限流就是对请求的速率进行限制，避免瞬时的大量请求击垮软件系统。毕竟，软件系统的处理能力是有限的。如果说超过了其处理能力的范围，软件系统可能直接就挂掉了。</p>
<p>限流可能会导致用户的请求无法被正确处理，不过，这往往也是权衡了软件系统的稳定性之后得到的最优解。</p>
<p>现实生活中，处处都有限流的实际应用，就比如排队买票是为了避免大量用户涌入购票而导致售票员无法处理。</p>
<p><img src="https://img-blog.csdnimg.cn/f9f17071fc4d489d85d2a234fb298df1.png" alt="排队示意图"></p>
<h2> 常见限流算法有哪些？</h2>
<p>简单介绍 4 种非常好理解并且容易实现的限流算法！</p>
<blockquote>
<p>图片来源于 InfoQ 的一篇文章<a href="https://www.infoq.cn/article/Qg2tX8fyw5Vt-f3HH673" target="_blank" rel="noopener noreferrer">《分布式服务限流实战，已经为你排好坑了》</a>。</p>
</blockquote>
<h3> 固定窗口计数器算法</h3>
<p>固定窗口其实就是时间窗口。<strong>固定窗口计数器算法</strong> 规定了我们单位时间处理的请求数量。</p>
<p>假如我们规定系统中某个接口 1 分钟只能访问 33 次的话，使用固定窗口计数器算法的实现思路如下：</p>
<ul>
<li>给定一个变量 <code>counter</code> 来记录当前接口处理的请求数量，初始值为 0（代表接口当前 1 分钟内还未处理请求）。</li>
<li>1 分钟之内每处理一个请求之后就将 <code>counter+1</code> ，当 <code>counter=33</code> 之后（也就是说在这 1 分钟内接口已经被访问 33 次的话），后续的请求就会被全部拒绝。</li>
<li>等到 1 分钟结束后，将 <code>counter</code> 重置 0，重新开始计数。</li>
</ul>
<p><strong>这种限流算法无法保证限流速率，因而无法保证突然激增的流量。</strong></p>
<p>就比如说我们限制某个接口 1 分钟只能访问 1000 次，该接口的 QPS 为 500，前 55s 这个接口 1 个请求没有接收，后 1s 突然接收了 1000 个请求。然后，在当前场景下，这 1000 个请求在 1s 内是没办法被处理的，系统直接就被瞬时的大量请求给击垮了。</p>
<p><img src="https://static001.infoq.cn/resource/image/8d/15/8ded7a2b90e1482093f92fff555b3615.png" alt="固定窗口计数器算法"></p>
<h3> 滑动窗口计数器算法</h3>
<p><strong>滑动窗口计数器算法</strong> 算的上是固定窗口计数器算法的升级版。</p>
<p>滑动窗口计数器算法相比于固定窗口计数器算法的优化在于：<strong>它把时间以一定比例分片</strong> 。</p>
<p>例如我们的接口限流每分钟处理 60 个请求，我们可以把 1 分钟分为 60 个窗口。每隔 1 秒移动一次，每个窗口一秒只能处理 不大于 <code>60(请求数)/60（窗口数）</code> 的请求， 如果当前窗口的请求计数总和超过了限制的数量的话就不再处理其他请求。</p>
<p>很显然， <strong>当滑动窗口的格子划分的越多，滑动窗口的滚动就越平滑，限流的统计就会越精确。</strong></p>
<p><img src="https://static001.infoq.cn/resource/image/ae/15/ae4d3cd14efb8dc7046d691c90264715.png" alt="滑动窗口计数器算法"></p>
<h3> 漏桶算法</h3>
<p>我们可以把发请求的动作比作成注水到桶中，我们处理请求的过程可以比喻为漏桶漏水。我们往桶中以任意速率流入水，以一定速率流出水。当水超过桶流量则丢弃，因为桶容量是不变的，保证了整体的速率。</p>
<p>如果想要实现这个算法的话也很简单，准备一个队列用来保存请求，然后我们定期从队列中拿请求来执行就好了（和消息队列削峰/限流的思想是一样的）。</p>
<p><img src="https://static001.infoq.cn/resource/image/75/03/75938d1010138ce66e38c6ed0392f103.png" alt="漏桶算法"></p>
<h3> 令牌桶算法</h3>
<p>令牌桶算法也比较简单。和漏桶算法算法一样，我们的主角还是桶（这限流算法和桶过不去啊）。不过现在桶里装的是令牌了，请求在被处理之前需要拿到一个令牌，请求处理完毕之后将这个令牌丢弃（删除）。我们根据限流大小，按照一定的速率往桶里添加令牌。如果桶装满了，就不能继续往里面继续添加令牌了。</p>
<p><img src="https://static001.infoq.cn/resource/image/ec/93/eca0e5eaa35dac938c673fecf2ec9a93.png" alt="令牌桶算法"></p>
<h2> 单机限流怎么做？</h2>
<p>单机限流针对的是单体架构应用。</p>
<p>单机限流可以直接使用 Google Guava 自带的限流工具类 <code>RateLimiter</code> 。 <code>RateLimiter</code> 基于令牌桶算法，可以应对突发流量。</p>
<blockquote>
<p>Guava 地址：https://github.com/google/guava</p>
</blockquote>
<p>除了最基本的令牌桶算法(平滑突发限流)实现之外，Guava 的<code>RateLimiter</code>还提供了 <strong>平滑预热限流</strong> 的算法实现。</p>
<p>平滑突发限流就是按照指定的速率放令牌到桶里，而平滑预热限流会有一段预热时间，预热时间之内，速率会逐渐提升到配置的速率。</p>
<p>我们下面通过两个简单的小例子来详细了解吧！</p>
<p>我们直接在项目中引入 Guava 相关的依赖即可使用。</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面是一个简单的 Guava 平滑突发限流的 Demo。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面是一个简单的 Guava 平滑预热限流的 Demo。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>另外，<strong>Bucket4j</strong> 是一个非常不错的基于令牌/漏桶算法的限流库。</p>
<blockquote>
<p>Bucket4j 地址：https://github.com/vladimir-bukhtoyarov/bucket4j</p>
</blockquote>
<p>相对于，Guava 的限流工具类来说，Bucket4j 提供的限流功能更加全面。不仅支持单机限流和分布式限流，还可以集成监控，搭配 Prometheus 和 Grafana 使用。</p>
<p>不过，毕竟 Guava 也只是一个功能全面的工具类库，其提供的开箱即用的限流功能在很多单机场景下还是比较实用的。</p>
<p>Spring Cloud Gateway 中自带的单机限流的早期版本就是基于 Bucket4j 实现的。后来，替换成了 <strong>Resilience4j</strong>。</p>
<p>Resilience4j 是一个轻量级的容错组件，其灵感来自于 Hystrix。自<a href="https://github.com/Netflix/Hystrix/commit/a7df971cbaddd8c5e976b3cc5f14013fe6ad00e6" target="_blank" rel="noopener noreferrer">Netflix 宣布不再积极开发 Hystrix</a> 之后，Spring 官方和 Netflix 都更推荐使用 Resilience4j 来做限流熔断。</p>
<blockquote>
<p>Resilience4j 地址: https://github.com/resilience4j/resilience4j</p>
</blockquote>
<p>一般情况下，为了保证系统的高可用，项目的限流和熔断都是要一起做的。</p>
<p>Resilience4j 不仅提供限流，还提供了熔断、负载保护、自动重试等保障系统高可用开箱即用的功能。并且，Resilience4j 的生态也更好，很多网关都使用 Resilience4j 来做限流熔断的。</p>
<p>因此，在绝大部分场景下 Resilience4j 或许会是更好的选择。如果是一些比较简单的限流场景的话，Guava 或者 Bucket4j 也是不错的选择。</p>
<h2> 分布式限流怎么做？</h2>
<p>分布式限流针对的分布式/微服务应用架构应用，在这种架构下，单机限流就不适用了，因为会存在多种服务，并且一种服务也可能会被部署多份。</p>
<p>分布式限流常见的方案：</p>
<ul>
<li><strong>借助中间件架限流</strong> ：可以借助 Sentinel 或者使用 Redis 来自己实现对应的限流逻辑。</li>
<li><strong>网关层限流</strong> ：比较常用的一种方案，直接在网关层把限流给安排上了。不过，通常网关层限流通常也需要借助到中间件/框架。就比如 Spring Cloud Gateway 的分布式限流实现<code>RedisRateLimiter</code>就是基于 Redis+Lua 来实现的，再比如 Spring Cloud Gateway 还可以整合 Sentinel 来做限流。</li>
</ul>
<p>如果你要基于 Redis 来手动实现限流逻辑的话，建议配合 Lua 脚本来做。</p>
<p><strong>为什么建议 Redis+Lua 的方式？</strong> 主要有两点原因：</p>
<ul>
<li><strong>减少了网络开销</strong> ：我们可以利用 Lua 脚本来批量执行多条 Redis 命令，这些 Redis 命令会被提交到 Redis 服务器一次性执行完成，大幅减小了网络开销。</li>
<li><strong>原子性</strong> ：一段 Lua 脚本可以视作一条命令执行，一段 Lua 脚本执行过程中不会有其他脚本或 Redis 命令同时执行，保证了操作不会被其他指令插入或打扰。</li>
</ul>
<p>我这里就不放具体的限流脚本代码了，网上也有很多现成的优秀的限流脚本供你参考，就比如 Apache 网关项目 ShenYu 的 RateLimiter 限流插件就基于 Redis + Lua 实现了令牌桶算法/并发令牌桶算法、漏桶算法、滑动窗口算法。</p>
<blockquote>
<p>ShenYu 地址: https://github.com/apache/incubator-shenyu</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/e1e2a75f489e4854990dabe3b6cec522.png" alt=""></p>
<h2> 相关阅读</h2>
<ul>
<li>服务治理之轻量级熔断框架 Resilience4j ：https://xie.infoq.cn/article/14786e571c1a4143ad1ef8f19</li>
<li>超详细的 Guava RateLimiter 限流原理解析：https://cloud.tencent.com/developer/article/1408819</li>
<li>实战 Spring Cloud Gateway 之限流篇 👍：https://www.aneasystone.com/archives/2020/08/spring-cloud-gateway-current-limiting.html</li>
</ul>
]]></content:encoded>
      <enclosure url="https://img-blog.csdnimg.cn/f9f17071fc4d489d85d2a234fb298df1.png" type="image/png"/>
    </item>
    <item>
      <title>性能测试入门</title>
      <link>https://javaguide.cn/high-availability/performance-test.html</link>
      <guid>https://javaguide.cn/high-availability/performance-test.html</guid>
      <source url="https://javaguide.cn/rss.xml">性能测试入门</source>
      <description>性能测试入门 性能测试一般情况下都是由测试这个职位去做的，那还需要我们开发学这个干嘛呢？了解性能测试的指标、分类以及工具等知识有助于我们更好地去写出性能更好的程序，另外作为开发这个角色，如果你会性能测试的话，相信也会为你的履历加分不少。 这篇文章是我会结合自己的实际经历以及在测试这里取的经所得，除此之外，我还借鉴了一些优秀书籍，希望对你有帮助。 本文思维导图：</description>
      <category>高可用</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 性能测试入门</h1>
<p>性能测试一般情况下都是由测试这个职位去做的，那还需要我们开发学这个干嘛呢？了解性能测试的指标、分类以及工具等知识有助于我们更好地去写出性能更好的程序，另外作为开发这个角色，如果你会性能测试的话，相信也会为你的履历加分不少。</p>
<p>这篇文章是我会结合自己的实际经历以及在测试这里取的经所得，除此之外，我还借鉴了一些优秀书籍，希望对你有帮助。</p>
<p>本文思维导图：</p>
<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/网站性能测试.png" style="zoom:50%;">
<h2> 一 不同角色看网站性能</h2>
<h3> 1.1 用户</h3>
<p>当用户打开一个网站的时候，最关注的是什么？当然是网站响应速度的快慢。比如我们点击了淘宝的主页，淘宝需要多久将首页的内容呈现在我的面前，我点击了提交订单按钮需要多久返回结果等等。</p>
<p>所以，用户在体验我们系统的时候往往根据你的响应速度的快慢来评判你的网站的性能。</p>
<h3> 1.2 开发人员</h3>
<p>用户与开发人员都关注速度，这个速度实际上就是我们的系统<strong>处理用户请求的速度</strong>。</p>
<p>开发人员一般情况下很难直观的去评判自己网站的性能，我们往往会根据网站当前的架构以及基础设施情况给一个大概的值,比如：</p>
<ol>
<li>项目架构是分布式的吗？</li>
<li>用到了缓存和消息队列没有？</li>
<li>高并发的业务有没有特殊处理？</li>
<li>数据库设计是否合理？</li>
<li>系统用到的算法是否还需要优化？</li>
<li>系统是否存在内存泄露的问题？</li>
<li>项目使用的 Redis 缓存多大？服务器性能如何？用的是机械硬盘还是固态硬盘？</li>
<li>......</li>
</ol>
<h3> 1.3 测试人员</h3>
<p>测试人员一般会根据性能测试工具来测试，然后一般会做出一个表格。这个表格可能会涵盖下面这些重要的内容：</p>
<ol>
<li>响应时间；</li>
<li>请求成功率；</li>
<li>吞吐量；</li>
<li>......</li>
</ol>
<h3> 1.4 运维人员</h3>
<p>运维人员会倾向于根据基础设施和资源的利用率来判断网站的性能，比如我们的服务器资源使用是否合理、数据库资源是否存在滥用的情况、当然，这是传统的运维人员，现在 Devpos 火起来后，单纯干运维的很少了。我们这里暂且还保留有这个角色。</p>
<h2> 二 性能测试需要注意的点</h2>
<p>几乎没有文章在讲性能测试的时候提到这个问题，大家都会讲如何去性能测试，有哪些性能测试指标这些东西。</p>
<h3> 2.1 了解系统的业务场景</h3>
<p><strong>性能测试之前更需要你了解当前的系统的业务场景。</strong> 对系统业务了解的不够深刻，我们很容易犯测试方向偏执的错误，从而导致我们忽略了对系统某些更需要性能测试的地方进行测试。比如我们的系统可以为用户提供发送邮件的功能，用户配置成功邮箱后只需输入相应的邮箱之后就能发送，系统每天大概能处理上万次发邮件的请求。很多人看到这个可能就直接开始使用相关工具测试邮箱发送接口，但是，发送邮件这个场景可能不是当前系统的性能瓶颈，这么多人用我们的系统发邮件， 还可能有很多人一起发邮件，单单这个场景就这么人用，那用户管理可能才是性能瓶颈吧！</p>
<h3> 2.2 历史数据非常有用</h3>
<p>当前系统所留下的历史数据非常重要，一般情况下，我们可以通过相应的些历史数据初步判定这个系统哪些接口调用的比较多、哪些 service 承受的压力最大，这样的话，我们就可以针对这些地方进行更细致的性能测试与分析。</p>
<p>另外，这些地方也就像这个系统的一个短板一样，优化好了这些地方会为我们的系统带来质的提升。</p>
<h3> 三 性能测试的指标</h3>
<h3> 3.1 响应时间</h3>
<p><strong>响应时间就是用户发出请求到用户收到系统处理结果所需要的时间。</strong> 重要吗？实在太重要！</p>
<p>比较出名的 2-5-8 原则是这样描述的：通常来说，2到5秒，页面体验会比较好，5到8秒还可以接受，8秒以上基本就很难接受了。另外，据统计当网站慢一秒就会流失十分之一的客户。</p>
<p>但是，在某些场景下我们也并不需要太看重 2-5-8 原则 ，比如我觉得系统导出导入大数据量这种就不需要，系统生成系统报告这种也不需要。</p>
<h3> 3.2 并发数</h3>
<p><strong>并发数是系统能同时处理请求的数目即同时提交请求的用户数目。</strong></p>
<p>不得不说，高并发是现在后端架构中非常非常火热的一个词了，这个与当前的互联网环境以及中国整体的互联网用户量都有很大关系。一般情况下，你的系统并发量越大，说明你的产品做的就越大。但是，并不是每个系统都需要达到像淘宝、12306 这种亿级并发量的。</p>
<h3> 3.3 吞吐量</h3>
<p>吞吐量指的是系统单位时间内系统处理的请求数量。衡量吞吐量有几个重要的参数：QPS（TPS）、并发数、响应时间。</p>
<ol>
<li>QPS（Query Per Second）：服务器每秒可以执行的查询次数；</li>
<li>TPS（Transaction Per Second）：服务器每秒处理的事务数（这里的一个事务可以理解为客户发出请求到收到服务器的过程）；</li>
<li>并发数；系统能同时处理请求的数目即同时提交请求的用户数目。</li>
<li>响应时间： 一般取多次请求的平均响应时间</li>
</ol>
<p>理清他们的概念，就很容易搞清楚他们之间的关系了。</p>
<ul>
<li><strong>QPS（TPS）</strong> = 并发数/平均响应时间</li>
<li><strong>并发数</strong> = QPS*平均响应时间</li>
</ul>
<p>书中是这样描述 QPS 和 TPS 的区别的。</p>
<blockquote>
<p>QPS vs TPS：QPS 基本类似于 TPS，但是不同的是，对于一个页面的一次访问，形成一个TPS；但一次页面请求，可能产生多次对服务器的请求，服务器对这些请求，就可计入“QPS”之中。如，访问一个页面会请求服务器2次，一次访问，产生一个“T”，产生2个“Q”。</p>
</blockquote>
<h3> 3.4 性能计数器</h3>
<p><strong>性能计数器是描述服务器或者操作系统的一些数据指标如内存使用、CPU使用、磁盘与网络I/O等情况。</strong></p>
<h3> 四 几种常见的性能测试</h3>
<h3> 性能测试</h3>
<p>性能测试方法是通过测试工具模拟用户请求系统，目的主要是为了测试系统的性能是否满足要求。通俗地说，这种方法就是要在特定的运行条件下验证系统的能力状态。</p>
<p>性能测试是你在对系统性能已经有了解的前提之后进行的，并且有明确的性能指标。</p>
<h3> 负载测试</h3>
<p>对被测试的系统继续加大请求压力，直到服务器的某个资源已经达到饱和了，比如系统的缓存已经不够用了或者系统的响应时间已经不满足要求了。</p>
<p>负载测试说白点就是测试系统的上限。</p>
<h3> 压力测试</h3>
<p>不去管系统资源的使用情况，对系统继续加大请求压力，直到服务器崩溃无法再继续提供服务。</p>
<h3> 稳定性测试</h3>
<p>模拟真实场景，给系统一定压力，看看业务是否能稳定运行。</p>
<h2> 五 常用性能测试工具</h2>
<p>这里就不多扩展了，有时间的话会单独拎一个熟悉的说一下。</p>
<h3> 5.1 后端常用</h3>
<p>没记错的话，除了 LoadRunner 其他几款性能测试工具都是开源免费的。</p>
<ol>
<li>Jmeter ：Apache JMeter 是 JAVA 开发的性能测试工具。</li>
<li>LoadRunner：一款商业的性能测试工具。</li>
<li>Galtling ：一款基于Scala 开发的高性能服务器性能测试工具。</li>
<li>ab ：全称为 Apache Bench 。Apache 旗下的一款测试工具，非常实用。</li>
</ol>
<h3> 5.2 前端常用</h3>
<ol>
<li>Fiddler：抓包工具，它可以修改请求的数据，甚至可以修改服务器返回的数据，功能非常强大，是Web 调试的利器。</li>
<li>HttpWatch: 可用于录制HTTP请求信息的工具。</li>
</ol>
<h2> 六 常见的性能优化策略</h2>
<p>性能优化之前我们需要对请求经历的各个环节进行分析，排查出可能出现性能瓶颈的地方，定位问题。</p>
<p>下面是一些性能优化时，我经常拿来自问的一些问题：</p>
<ol>
<li>系统是否需要缓存？</li>
<li>系统架构本身是不是就有问题？</li>
<li>系统是否存在死锁的地方？</li>
<li>系统是否存在内存泄漏？（Java 的自动回收内存虽然很方便，但是，有时候代码写的不好真的会造成内存泄漏）</li>
<li>数据库索引使用是否合理？</li>
<li>......</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>冗余设计详解</title>
      <link>https://javaguide.cn/high-availability/redundancy.html</link>
      <guid>https://javaguide.cn/high-availability/redundancy.html</guid>
      <source url="https://javaguide.cn/rss.xml">冗余设计详解</source>
      <description>冗余设计是保证系统和数据高可用的最常的手段。 对于服务来说，冗余的思想就是相同的服务部署多份，如果正在使用的服务突然挂掉的话，系统可以很快切换到备份服务上，大大减少系统的不可用时间，提高系统的可用性。 对于数据来说，冗余的思想就是相同的数据备份多份，这样就可以很简单地提高数据的安全性。 实际上，日常生活中就有非常多的冗余思想的应用。 拿我自己来说，我对于重要文件的保存方法就是冗余思想的应用。我日常所使用的重要文件都会同步一份在 Github 以及个人云盘上，这样就可以保证即使电脑硬盘损坏，我也可以通过 Github 或者个人云盘找回自己的重要文件。</description>
      <category>高可用</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<p>冗余设计是保证系统和数据高可用的最常的手段。</p>
<p>对于服务来说，冗余的思想就是相同的服务部署多份，如果正在使用的服务突然挂掉的话，系统可以很快切换到备份服务上，大大减少系统的不可用时间，提高系统的可用性。</p>
<p>对于数据来说，冗余的思想就是相同的数据备份多份，这样就可以很简单地提高数据的安全性。</p>
<p>实际上，日常生活中就有非常多的冗余思想的应用。</p>
<p>拿我自己来说，我对于重要文件的保存方法就是冗余思想的应用。我日常所使用的重要文件都会同步一份在 Github 以及个人云盘上，这样就可以保证即使电脑硬盘损坏，我也可以通过 Github 或者个人云盘找回自己的重要文件。</p>
<p>高可用集群（High Availability Cluster，简称 HA Cluster）、同城灾备、异地灾备、同城多活和异地多活是冗余思想在高可用系统设计中最典型的应用。</p>
<ul>
<li><strong>高可用集群</strong> : 同一份服务部署两份或者多份，当正在使用的服务突然挂掉的话，可以切换到另外一台服务，从而保证服务的高可用。</li>
<li><strong>同城灾备</strong> ：一整个集群可以部署在同一个机房，而同城灾备中相同服务部署在同一个城市的不同机房中。并且，备用服务不处理请求。这样可以避免机房出现意外情况比如停电、火灾。</li>
<li><strong>异地灾备</strong> ：类似于同城灾备，不同的是，相同服务部署在异地（通常距离较远，甚至是在不同的城市或者国家）的不同机房中</li>
<li><strong>同城多活</strong> ：类似于同城灾备，但备用服务可以处理请求，这样可以充分利用系统资源，提高系统的并发。</li>
<li><strong>异地多活</strong> : 将服务部署在异地的不同机房中，并且，它们可以同时对外提供服务。</li>
</ul>
<p>高可用集群单纯是服务的冗余，并没有强调地域。同城灾备、异地灾备、同城多活和异地多活实现了地域上的冗余。</p>
<p>同城和异地的主要区别在于机房之间的距离。异地通常距离较远，甚至是在不同的城市或者国家。</p>
<p>和传统的灾备设计相比，同城多活和异地多活最明显的改变在于“多活”，即所有站点都是同时在对外提供服务的。异地多活是为了应对突发状况比如火灾、地震等自然或者人为灾害。</p>
<p>光做好冗余还不够，必须要配合上 <strong>故障转移</strong> 才可以！ 所谓故障转移，简单来说就是实现不可用服务快速且自动地切换到可用服务，整个过程不需要人为干涉。</p>
<p>举个例子：哨兵模式的 Redis 集群中，如果 Sentinel（哨兵） 检测到 master 节点出现故障的话， 它就会帮助我们实现故障转移，自动将某一台 slave 升级为 master，确保整个 Redis 系统的可用性。整个过程完全自动，不需要人工介入。我在<a href="https://www.yuque.com/docs/share/f37fc804-bfe6-4b0d-b373-9c462188fec7" target="_blank" rel="noopener noreferrer">《Java 面试指北》</a>的「技术面试题篇」中的数据库部分详细介绍了 Redis 集群相关的知识点&amp;面试题，感兴趣的小伙伴可以看看。</p>
<p>再举个例子：Nginx 可以结合 Keepalived 来实现高可用。如果 Nginx 主服务器宕机的话，Keepalived 可以自动进行故障转移，备用 Nginx 主服务器升级为主服务。并且，这个切换对外是透明的，因为使用的虚拟 IP，虚拟 IP 不会改变。我在<a href="https://www.yuque.com/docs/share/f37fc804-bfe6-4b0d-b373-9c462188fec7" target="_blank" rel="noopener noreferrer">《Java 面试指北》</a>的「技术面试题篇」中的「服务器」部分详细介绍了 Nginx 相关的知识点&amp;面试题，感兴趣的小伙伴可以看看。</p>
<p>异地多活架构实施起来非常难，需要考虑的因素非常多。本人不才，实际项目中并没有实践过异地多活架构，我对其了解还停留在书本知识。</p>
<p>如果你想要深入学习异地多活相关的知识，我这里推荐几篇我觉得还不错的文章：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/T6mMDdtTfBuIiEowCpqu6Q" target="_blank" rel="noopener noreferrer">搞懂异地多活，看这篇就够了- 水滴与银弹 - 2021</a></li>
<li><a href="https://mp.weixin.qq.com/s/hMD-IS__4JE5_nQhYPYSTg" target="_blank" rel="noopener noreferrer">四步构建异地多活</a></li>
<li><a href="http://gk.link/a/10pKZ" target="_blank" rel="noopener noreferrer">《从零开始学架构》— 28 | 业务高可用的保障：异地多活架构</a></li>
</ul>
<p>不过，这些文章大多也都是在介绍概念知识。目前，网上还缺少真正介绍具体要如何去实践落地异地多活架构的资料。</p>
]]></content:encoded>
    </item>
    <item>
      <title>超时&amp;重试详解</title>
      <link>https://javaguide.cn/high-availability/timeout-and-retry.html</link>
      <guid>https://javaguide.cn/high-availability/timeout-and-retry.html</guid>
      <source url="https://javaguide.cn/rss.xml">超时&amp;重试详解</source>
      <description>由于网络问题、系统或者服务内部的 Bug、服务器宕机、操作系统崩溃等问题的不确定性，我们的系统或者服务永远不可能保证时刻都是可用的状态。 为了最大限度的减小系统或者服务出现故障之后带来的影响，我们需要用到的 超时（Timeout） 和 重试（Retry） 机制。 想要把超时和重试机制讲清楚其实很简单，因为它俩本身就不是什么高深的概念。 虽然超时和重试机制的思想很简单，但是它俩是真的非常实用。你平时接触到的绝大部分涉及到远程调用的系统或者服务都会应用超时和重试机制。尤其是对于微服务系统来说，正确设置超时和重试非常重要。单体服务通常只涉及数据库、缓存、第三方 API、中间件等的网络调用，而微服务系统内部各个服务之间还存在着网络调用。</description>
      <category>高可用</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<p>由于网络问题、系统或者服务内部的 Bug、服务器宕机、操作系统崩溃等问题的不确定性，我们的系统或者服务永远不可能保证时刻都是可用的状态。</p>
<p>为了最大限度的减小系统或者服务出现故障之后带来的影响，我们需要用到的 <strong>超时（Timeout）</strong> 和 <strong>重试（Retry）</strong> 机制。</p>
<p>想要把超时和重试机制讲清楚其实很简单，因为它俩本身就不是什么高深的概念。</p>
<p>虽然超时和重试机制的思想很简单，但是它俩是真的非常实用。你平时接触到的绝大部分涉及到远程调用的系统或者服务都会应用超时和重试机制。尤其是对于微服务系统来说，正确设置超时和重试非常重要。单体服务通常只涉及数据库、缓存、第三方 API、中间件等的网络调用，而微服务系统内部各个服务之间还存在着网络调用。</p>
<h2> 超时机制</h2>
<h3> 什么是超时机制？</h3>
<p>超时机制说的是当一个请求超过指定的时间（比如 1s）还没有被处理的话，这个请求就会直接被取消并抛出指定的异常或者错误（比如 <code>504 Gateway Timeout</code>）。</p>
<p>我们平时接触到的超时可以简单分为下面 2 种：</p>
<ul>
<li><strong>连接超时（ConnectTimeout）</strong> ：客户端与服务端建立连接的最长等待时间。</li>
<li><strong>读取超时（ReadTimeout）</strong> ：客户端和服务端已经建立连接，客户端等待服务端处理完请求的最长时间。实际项目中，我们关注比较多的还是读取超时。</li>
</ul>
<p>一些连接池客户端框架中可能还会有获取连接超时和空闲连接清理超时。</p>
<p>如果没有设置超时的话，就可能会导致服务端连接数爆炸和大量请求堆积的问题。</p>
<p>这些堆积的连接和请求会消耗系统资源，影响新收到的请求的处理。严重的情况下，甚至会拖垮整个系统或者服务。</p>
<p>我之前在实际项目就遇到过类似的问题，整个网站无法正常处理请求，服务器负载直接快被拉满。后面发现原因是项目超时设置错误加上客户端请求处理异常，导致服务端连接数直接接近 40w+，这么多堆积的连接直接把系统干趴了。</p>
<h3> 超时时间应该如何设置？</h3>
<p>超时到底设置多长时间是一个难题！超时值设置太高或者太低都有风险。如果设置太高的话，会降低超时机制的有效性，比如你设置超时为 10s 的话，那设置超时就没啥意义了，系统依然可能会出现大量慢请求堆积的问题。如果设置太低的话，就可能会导致在系统或者服务在某些处理请求速度变慢的情况下（比如请求突然增多），大量请求重试（超时通常会结合重试）继续加重系统或者服务的压力，进而导致整个系统或者服务被拖垮的问题。</p>
<p>通常情况下，我们建议读取超时设置为 <strong>1500ms</strong> ,这是一个比较普适的值。如果你的系统或者服务对于延迟比较敏感的话，那读取超时值可以适当在 <strong>1500ms</strong> 的基础上进行缩短。反之，读取超时值也可以在 <strong>1500ms</strong> 的基础上进行加长，不过，尽量还是不要超过 <strong>1500ms</strong> 。连接超时可以适当设置长一些，建议在 <strong>1000ms ~ 5000ms</strong> 之内。</p>
<p>没有银弹！超时值具体该设置多大，还是要根据实际项目的需求和情况慢慢调整优化得到。</p>
<p>更上一层，参考<a href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html" target="_blank" rel="noopener noreferrer">美团的Java线程池参数动态配置</a>思想，我们也可以将超时弄成可配置化的参数而不是固定的，比较简单的一种办法就是将超时的值放在配置中心中。这样的话，我们就可以根据系统或者服务的状态动态调整超时值了。</p>
<h2> 重试机制</h2>
<h3> 什么是重试机制？</h3>
<p>重试机制一般配合超时机制一起使用，指的是多次发送相同的请求来避免瞬态故障和偶然性故障。</p>
<p>瞬态故障可以简单理解为某一瞬间系统偶然出现的故障，并不会持久。偶然性故障可以理解为哪些在某些情况下偶尔出现的故障，频率通常较低。</p>
<p>重试的核心思想是通过消耗服务器的资源来尽可能获得请求更大概率被成功处理。由于瞬态故障和偶然性故障是很少发生的，因此，重试对于服务器的资源消耗几乎是可以被忽略的。</p>
<h3> 重试的次数如何设置？</h3>
<p>重试的次数不宜过多，否则依然会对系统负载造成比较大的压力。</p>
<p>重试的次数通常建议设为 3 次。并且，我们通常还会设置重试的间隔，比如说我们要重试 3 次的话，第 1 次请求失败后，等待 1 秒再进行重试，第 2 次请求失败后，等待 2 秒再进行重试，第 3 次请求失败后，等待 3 秒再进行重试。</p>
<h3> 重试幂等</h3>
<p>超时和重试机制在实际项目中使用的话，需要注意保证同一个请求没有被多次执行。</p>
<p>什么情况下会出现一个请求被多次执行呢？客户端等待服务端完成请求完成超时但此时服务端已经执行了请求，只是由于短暂的网络波动导致响应在发送给客户端的过程中延迟了。</p>
<p>举个例子：用户支付购买某个课程，结果用户支付的请求由于重试的问题导致用户购买同一门课程支付了两次。对于这种情况，我们在执行用户购买课程的请求的时候需要判断一下用户是否已经购买过。这样的话，就不会因为重试的问题导致重复购买了。</p>
<h2> 参考</h2>
<ul>
<li>微服务之间调用超时的设置治理：https://www.infoq.cn/article/eyrslar53l6hjm5yjgyx</li>
<li>超时、重试和抖动回退：https://aws.amazon.com/cn/builders-library/timeouts-retries-and-backoff-with-jitter/</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>技术文章精选</title>
      <link>https://javaguide.cn/high-quality-technical-articles/</link>
      <guid>https://javaguide.cn/high-quality-technical-articles/</guid>
      <source url="https://javaguide.cn/rss.xml">技术文章精选</source>
      <description>技术文章精选 这是一则或许对你有用的小广告 👉 欢迎准备 Java 面试以及学习 Java 的同学加入我的知识星球，干货很多！收费虽然是白菜价，但星球里的内容或许比你参加上万的培训班质量还要高。 👉 《Java 面试指北》持续更新完善中！这是一份教你如何更高效地准备面试的小册，涵盖常见八股文（系统设计、常见框架、分布式、高并发 ......）、优质面经等内容。</description>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 技术文章精选</h1>
<div class="hint-container tip">
<p class="hint-container-title">这是一则或许对你有用的小广告</p>
<p>👉 欢迎准备 Java 面试以及学习 Java 的同学加入我的<a href="/about-the-author/zhishixingqiu-two-years.html" target="blank">知识星球</a>，干货很多！收费虽然是白菜价，但星球里的内容或许比你参加上万的培训班质量还要高。</p>
<p>👉 <a href="/zhuanlan/java-mian-shi-zhi-bei.html" target="blank">《Java 面试指北》</a>持续更新完善中！这是一份教你如何更高效地准备面试的小册，涵盖常见八股文（系统设计、常见框架、分布式、高并发 ......）、优质面经等内容。</p>
</div>
<h2> 练级攻略</h2>
<ul>
<li><a href="/high-quality-technical-articles/advanced-programmer/seven-tips-for-becoming-an-advanced-programmer.html" target="blank">给想成长为高级别开发同学的七条建议</a></li>
<li><a href="/high-quality-technical-articles/advanced-programmer/20-bad-habits-of-bad-programmers.html" target="blank">糟糕程序员的 20 个坏习惯</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>优质面经汇总(付费)</title>
      <link>https://javaguide.cn/interview-preparation/interview-experience.html</link>
      <guid>https://javaguide.cn/interview-preparation/interview-experience.html</guid>
      <source url="https://javaguide.cn/rss.xml">优质面经汇总(付费)</source>
      <description>古人云:“他山之石，可以攻玉” 。善于学习借鉴别人的面试的成功经验或者失败的教训，可以让自己少走许多弯路。 在 《Java 面试指北》 的 「面经篇」 ，我分享了 15+ 篇高质量的 Java 后端面经，有校招的，也有社招的，有大厂的，也有中小厂的。 如果你是非科班的同学，也能在这些文章中找到对应的非科班的同学写的面经。</description>
      <category>知识星球</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<p>古人云:“<strong>他山之石，可以攻玉</strong>” 。善于学习借鉴别人的面试的成功经验或者失败的教训，可以让自己少走许多弯路。</p>
<p>在 <strong><a href="/zhuanlan/java-mian-shi-zhi-bei.html" target="blank">《Java 面试指北》</a></strong> 的 <strong>「面经篇」</strong> ，我分享了 15+ 篇高质量的 Java 后端面经，有校招的，也有社招的，有大厂的，也有中小厂的。</p>
<p>如果你是非科班的同学，也能在这些文章中找到对应的非科班的同学写的面经。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/githubjuejinjihua/thinkimage-20220612185810480.png" alt=""></p>
<p>并且，<a href="https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc" target="_blank" rel="noopener noreferrer">知识星球</a>还有专门分享面经和面试题的专题，里面会分享很多优质的面经和面试题。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220304120018731.png" alt=""></p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220628101743381.png" alt=""></p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220628101805897.png" alt=""></p>
<p>欢迎准备 Java 面试以及学习 Java 的同学加入我的<a href="https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc" target="_blank" rel="noopener noreferrer">知识星球</a>，干货非常多，学习氛围非常好！收费虽然是白菜价，但星球里的内容或许比你参加上万的培训班质量还要高。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220311203414600.png" alt=""></p>
<p>下面是星球提供的部分服务（点击下方图片即可获取知识星球的详细介绍）：</p>
<div align="center">
  <a href="https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html">
    <img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/xingqiufuwu.png" style="margin: 0 auto; ">
  </a>
</div>
<p>我有自己的原则，不割韭菜，用心做内容，真心希望帮助到你！</p>
<p>如果你感兴趣的话，不妨花 3 分钟左右看看星球的详细介绍： <a href="https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc" target="_blank" rel="noopener noreferrer">JavaGuide 知识星球详细介绍</a>（文末有优惠券）。</p>
<div align="center">
  <a href="https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html">
    <img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/xingqiuyouhuijuanheyi.png" style="margin: 0 auto; ">
  </a>
</div>
]]></content:encoded>
      <enclosure url="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/githubjuejinjihua/thinkimage-20220612185810480.png" type="image/png"/>
    </item>
    <item>
      <title>项目经验指南</title>
      <link>https://javaguide.cn/interview-preparation/project-experience-guide.html</link>
      <guid>https://javaguide.cn/interview-preparation/project-experience-guide.html</guid>
      <source url="https://javaguide.cn/rss.xml">项目经验指南</source>
      <description>没有项目经验怎么办? 没有项目经验是大部分应届生会碰到的一个问题。甚至说，有很多有工作经验的程序员，对自己在公司做的项目不满意，也想找一个比较有技术含量的项目来做。 说几种我觉得比较靠谱的获取项目经验的方式，希望能够对你有启发。 实战项目视频/专栏 在网上找一个符合自己能力与找工作需求的实战项目视频或者专栏，跟着老师一起做。 你可以通过慕课网、哔哩哔哩、拉勾、极客时间、培训机构（比如黑马、尚硅谷）等渠道获取到适合自己的实战项目视频/专栏。</description>
      <category>面试准备</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 没有项目经验怎么办?</h2>
<p>没有项目经验是大部分应届生会碰到的一个问题。甚至说，有很多有工作经验的程序员，对自己在公司做的项目不满意，也想找一个比较有技术含量的项目来做。</p>
<p>说几种我觉得比较靠谱的获取项目经验的方式，希望能够对你有启发。</p>
<h3> 实战项目视频/专栏</h3>
<p>在网上找一个符合自己能力与找工作需求的实战项目视频或者专栏，跟着老师一起做。</p>
<p>你可以通过慕课网、哔哩哔哩、拉勾、极客时间、培训机构（比如黑马、尚硅谷）等渠道获取到适合自己的实战项目视频/专栏。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javamianshizhibei/mukewangzhiazhanke.png" alt="慕课网实战课"></p>
<p>尽量选择一个适合自己的项目，没必要必须做分布式/微服务项目，对于绝大部分同学来说，能把一个单机项目做好就已经很不错了。</p>
<p>我面试过很多求职者，简历上看着有微服务的项目经验，结果随便问两个问题就知道根本不是自己做的或者说做的时候压根没认真思考。这种情况会给我留下非常不好的印象。</p>
<p>我在 <strong><a href="/zhuanlan/java-mian-shi-zhi-bei.html" target="blank">《Java 面试指北》</a></strong> 的「面试准备篇」中也说过：</p>
<blockquote>
<p>个人认为也没必要非要去做微服务或者分布式项目，不一定对你面试有利。微服务或者分布式项目涉及的知识点太多，一般人很难吃透。并且，这类项目其实对于校招生来说稍微有一点超标了。即使你做出来，很多面试官也会认为不是你独立完成的。</p>
<p>其实，你能把一个单体项目做到极致也很好，对于个人能力提升不比做微服务或者分布式项目差。如何做到极致？代码质量这里就不提了，更重要的是你要尽量让自己的项目有一些亮点（比如你是如何提升项目性能的、如何解决项目中存在的一个痛点的），项目经历取得的成果尽量要量化一下比如我使用 xxx 技术解决了 xxx 问题，系统 qps 从 xxx 提高到了 xxx。</p>
</blockquote>
<p>跟着老师做的过程中，你一定要有自己的思考，不要浅尝辄止。对于很多知识点，别人的讲解可能只是满足项目就够了，你自己想多点知识的话，对于重要的知识点就要自己学会去深入学习。</p>
<h3> 实战类开源项目</h3>
<p>Github 或者码云上面有很多实战类别项目，你可以选择一个来研究，为了让自己对这个项目更加理解，在理解原有代码的基础上，你可以对原有项目进行改进或者增加功能。</p>
<p>你可以参考 <a href="https://javaguide.cn/open-source-project/practical-project.html" title="Java 优质开源实战项目" target="_blank" rel="noopener noreferrer">Java 优质开源实战项目</a> 上面推荐的实战类开源项目，质量都很高，项目类型也比较全面，涵盖博客/论坛系统、考试/刷题系统、商城系统、权限管理系统、快速开发脚手架以及各种轮子。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javamianshizhibei/javaguide-practical-project.png" alt="Java 优质开源实战项目"></p>
<p>一定要记住： <strong>不光要做，还要改进，改善。不论是实战项目视频或者专栏还是实战类开源项目，都一定会有很多可以完善改进的地方。</strong></p>
<h3> 从头开始做</h3>
<p>自己动手去做一个自己想完成的东西，遇到不会的东西就临时去学，现学现卖。</p>
<p>这个要求比较高，我建议你已经有了一个项目经验之后，再采用这个方法。如果你没有做过项目的话，还是老老实实采用上面两个方法比较好。</p>
<h3> 参加各种大公司组织的各种大赛</h3>
<p>如果参加这种赛事能获奖的话，项目含金量非常高。即使没获奖也没啥，也可以写简历上。</p>
<p><img src="https://img-blog.csdnimg.cn/7767035c52854759adf8cff5be8a2a3d.png" alt="阿里云天池大赛"></p>
<h3> 参与实际项目</h3>
<p>通常情况下，你有如下途径接触到企业实际项目的开发：</p>
<ol>
<li>老师接的项目；</li>
<li>自己接的私活；</li>
<li>实习/工作接触到的项目；</li>
</ol>
<p>老师接的项目和自己接的私活通常都是一些偏业务的项目，很少会涉及到性能优化。这种情况下，你可以考虑对项目进行改进，别怕花时间，某个时间用心做好一件事情就好比如你对项目的数据模型进行改进、引入缓存提高访问速度等等。</p>
<p>实习/工作接触到的项目类似，如果遇到一些偏业务的项目，也是要自己私下对项目进行改进优化。</p>
<p>尽量是真的对项目进行了优化，这本身也是对个人能力的提升。如果你实在是没时间去实践的话，也没关系，吃透这个项目优化手段就好，把一些面试可能会遇到的问题提前准备一下。</p>
<h2> 有没有还不错的项目推荐？</h2>
<p><strong><a href="/zhuanlan/java-mian-shi-zhi-bei.html" target="blank">《Java 面试指北》</a></strong> 的「面试准备篇」中有一篇文章专门整理了一些比较高质量的实战项目，非常适合用来学习或者作为项目经验。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javamianshizhibei/project-experience-guide.png" alt=""></p>
<p>这篇文章一共推荐了 15+ 个实战项目，有业务类的，也有轮子类的，有开源项目、也有视频教程。对于参加校招的小伙伴，我更建议做一个业务类项目加上一个轮子类的项目。</p>
<h2> 我跟着视频做的项目会被面试官嫌弃不？</h2>
<p>很多应届生都是跟着视频做的项目，这个大部分面试官都心知肚明。</p>
<p>不排除确实有些面试官不吃这一套，这个也看人。不过我相信大多数面试官都是能理解的，毕竟你在学校的时候实际上是没有什么获得实际项目经验的途径的。</p>
<p>大部分应届生的项目经验都是自己在网上找的或者像你一样买的付费课程跟着做的，极少部分是比较真实的项目。 从你能想着做一个实战项目来说，我觉得初衷是好的，确实也能真正学到东西。 但是，究竟有多少是自己掌握了很重要。看视频最忌讳的是被动接受，自己多改进一下，多思考一下！就算是你跟着视频做的项目，也是可以优化的！</p>
<p><strong>如果你想真正学到东西的话，建议不光要把项目单纯完成跑起来，还要去自己尝试着优化！</strong></p>
<p>简单说几个比较容易的优化点：</p>
<ol>
<li><strong>全局异常处理</strong> ：很多项目这方面都做的不是很好，可以参考我的这篇文章：<a href="https://mp.weixin.qq.com/s/Y4Q4yWRqKG_lw0GLUsY2qw" target="_blank" rel="noopener noreferrer">《使用枚举简单封装一个优雅的 Spring Boot 全局异常处理！》</a> 来做优化。</li>
<li><strong>项目的技术选型优化</strong> ：比如使用 Guava 做本地缓存的地方可以换成 <strong>Caffeine</strong> 。Caffeine 的各方面的表现要更加好！再比如 Controller 层是否放了太多的业务逻辑。</li>
<li><strong>数据库方面</strong> ：数据库设计可否优化？索引是否使用使用正确？SQL 语句是否可以优化？是否需要进行读写分离？</li>
<li><strong>缓存</strong> ：项目有没有哪些数据是经常被访问的？是否引入缓存来提高响应速度？</li>
<li><strong>安全</strong> ： 项目是否存在安全问题？</li>
<li>......</li>
</ol>
<p>另外，我在星球分享过常见的性能优化方向实践案例，涉及到多线程、异步、索引、缓存等方向，强烈推荐你看看：https://t.zsxq.com/06EqfeMZZ 。</p>
<p>最后，<strong>再给大家推荐一个 IDEA 优化代码的小技巧，超级实用！</strong></p>
<p>分析你的代码：右键项目-&gt; Analyze-&gt;Inspect Code</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-651672bce128025a135c1536cd5dc00532e.png" alt=""></p>
<p>扫描完成之后，IDEA 会给出一些可能存在的代码坏味道比如命名问题。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-05c83b319941995b07c8020fddc57f26037.png" alt=""></p>
<p>并且，你还可以自定义检查规则。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-6b618ad3bad0bc3f76e6066d90c8cd2f255.png" alt=""></p>
]]></content:encoded>
      <enclosure url="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javamianshizhibei/mukewangzhiazhanke.png" type="image/png"/>
    </item>
    <item>
      <title>常见面试题自测(付费)</title>
      <link>https://javaguide.cn/interview-preparation/self-test-of-common-interview-questions.html</link>
      <guid>https://javaguide.cn/interview-preparation/self-test-of-common-interview-questions.html</guid>
      <source url="https://javaguide.cn/rss.xml">常见面试题自测(付费)</source>
      <description>面试之前，强烈建议大家多拿常见的面试题来进行自测，检查一下自己的掌握情况，这是一种非常实用的备战技术面试的小技巧。 在 《Java 面试指北》 的 「技术面试题自测篇」 ，我总结了 Java 面试中最重要的知识点的最常见的面试题并按照面试提问的方式展现出来。</description>
      <category>知识星球</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<p>面试之前，强烈建议大家多拿常见的面试题来进行自测，检查一下自己的掌握情况，这是一种非常实用的备战技术面试的小技巧。</p>
<p>在 <strong><a href="/zhuanlan/java-mian-shi-zhi-bei.html" target="blank">《Java 面试指北》</a></strong> 的 <strong>「技术面试题自测篇」</strong> ，我总结了 Java 面试中最重要的知识点的最常见的面试题并按照面试提问的方式展现出来。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220628102643202.png" alt=""></p>
<p>每一道用于自测的面试题我都会给出重要程度，方便大家在时间比较紧张的时候根据自身情况来选择性自测。并且，我还会给出提示，方便你回忆起对应的知识点。</p>
<p>在面试中如果你实在没有头绪的话，一个好的面试官也是会给你提示的。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220628102848236.png" alt=""></p>
<p>欢迎准备 Java 面试以及学习 Java 的同学加入我的<a href="https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc" target="_blank" rel="noopener noreferrer">知识星球</a>，干货非常多，学习氛围非常好！收费虽然是白菜价，但星球里的内容或许比你参加上万的培训班质量还要高。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220311203414600.png" alt=""></p>
<p>下面是星球提供的部分服务（点击下方图片即可获取知识星球的详细介绍）：</p>
<div align="center">
  <a href="https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html">
    <img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/xingqiufuwu.png" style="margin: 0 auto; ">
  </a>
</div>
<p>我有自己的原则，不割韭菜，用心做内容，真心希望帮助到你！</p>
<p>如果你感兴趣的话，不妨花 3 分钟左右看看星球的详细介绍： <a href="https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc" target="_blank" rel="noopener noreferrer">JavaGuide 知识星球详细介绍</a>（文末有优惠券）。</p>
<div align="center">
  <a href="https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html">
    <img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/xingqiuyouhuijuanheyi.png" style="margin: 0 auto; ">
  </a>
</div>
]]></content:encoded>
      <enclosure url="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220628102643202.png" type="image/png"/>
    </item>
    <item>
      <title>手把手教你如何准备面试</title>
      <link>https://javaguide.cn/interview-preparation/teach-you-how-to-prepare-for-the-interview-hand-in-hand.html</link>
      <guid>https://javaguide.cn/interview-preparation/teach-you-how-to-prepare-for-the-interview-hand-in-hand.html</guid>
      <source url="https://javaguide.cn/rss.xml">手把手教你如何准备面试</source>
      <description>友情提示 本文节选自 《Java 面试指北》。这是一份教你如何更高效地准备面试的小册，涵盖常见八股文（系统设计、常见框架、分布式、高并发 ......）、优质面经等内容。 你的身边一定有很多编程比你厉害但是找的工作并没有你好的朋友！技术面试不同于编程，编程厉害不代表技术面试就一定能过。</description>
      <category>知识星球</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<div class="hint-container tip">
<p class="hint-container-title">友情提示</p>
<p>本文节选自 <strong><a href="/zhuanlan/java-mian-shi-zhi-bei.html" target="blank">《Java 面试指北》</a></strong>。这是一份教你如何更高效地准备面试的小册，涵盖常见八股文（系统设计、常见框架、分布式、高并发 ......）、优质面经等内容。</p>
</div>
<p>你的身边一定有很多编程比你厉害但是找的工作并没有你好的朋友！<strong>技术面试不同于编程，编程厉害不代表技术面试就一定能过。</strong></p>
<p>现在你去面个试，不认真准备一下，那简直就是往枪口上撞。我们大部分都只是普通人，没有发过顶级周刊或者获得过顶级大赛奖项。在这样一个技术面试氛围下，我们需要花费很多精力来准备面试，来提高自己的技术能力。“<a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247491596&amp;idx=1&amp;sn=36fbf80922f71c200990de11514955f7&amp;chksm=cea1afc7f9d626d1c70d5e54505495ac499ce6eb5e05ba4f4bb079a8563a84e27f17ceff38af&amp;token=353590436&amp;lang=zh_CN&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">面试造火箭，工作拧螺丝钉</a>” 就是目前的一个常态，预计未来很长很长一段时间也还是会是这样。</p>
<p>准备面试不等于耍小聪明或者死记硬背面试题。 <strong>一定不要对面试抱有侥幸心理。打铁还需自身硬！</strong> 千万不要觉得自己看几篇面经，看几篇面试题解析就能通过面试了。一定要静下心来深入学习！</p>
<p>这篇我会从宏观面出发简单聊聊如何准备 Java 面试，让你少走弯路！</p>
<h2> 尽早以求职为导向来学习</h2>
<p>我是比较建议还在学校的同学尽可能早一点以求职为导向来学习的。</p>
<p><strong>这样更有针对性，并且可以大概率减少自己处在迷茫的时间，很大程度上还可以让自己少走很多弯路。</strong></p>
<p>但是！不要把“以求职为导向学习”理解为“我就不用学课堂上那些计算机基础课程了”！</p>
<p>我在之前的很多次分享中都强调过：<strong>一定要用心学习计算机基础知识！操作系统、计算机组成原理、计算机网络真的不是没有实际用处的学科！！！</strong></p>
<p>你会发现大厂面试你会用到，以后工作之后你也会用到。我分别列举 2 个例子吧！</p>
<ul>
<li><strong>面试中</strong> ：像字节、腾讯这些大厂的技术面试以及几乎所有公司的笔试都会考操作系统相关的问题。</li>
<li><strong>工作中</strong> ：在实际使用缓存的时候，你会发现在操作系统中可以找到很多缓存思想的影子。比如 CPU Cache 缓存的是内存数据用于解决 CPU 处理速度和内存不匹配的问题，内存缓存的是硬盘数据用于解决硬盘访问速度过慢的问题。再比如操作系统在页表方案基础之上引入了快表来加速虚拟地址到物理地址的转换。我们可以把快表理解为一种特殊的高速缓冲存储器（Cache）。</li>
</ul>
<p><strong>如何求职为导向学习呢？</strong> 简答来说就是：根据招聘要求整理一份目标岗位的技能清单，然后按照技能清单去学习和提升。</p>
<ol>
<li>你首先搞清楚自己要找什么工作</li>
<li>然后根据招聘岗位的要求梳理一份技能清单</li>
<li>根据技能清单写好最终的简历</li>
<li>最后再按照建立的要求去学习和提升。</li>
</ol>
<p>这其实也是 <strong>以终为始</strong> 思想的运用。</p>
<p><strong>何为以终为始？</strong> 简单来说，以终为始就是我们可以站在结果来考虑问题，从结果出发，根据结果来确定自己要做的事情。</p>
<p>你会发现，其实几乎任何领域都可以用到 <strong>以终为始</strong> 的思想。</p>
<h2> 了解投递简历的黄金时间</h2>
<p>面试之前，你肯定是先要搞清楚春招和秋招的具体时间的。</p>
<p>正所谓金三银四，金九银十，错过了这个时间，很多公司都没有 HC 了。</p>
<p><strong>秋招一般 7 月份就开始了，大概一直持续到 9 月底。</strong></p>
<p><strong>春招一般 3 月份就开始了，大概一直持续到 4 月底。</strong></p>
<p>很多公司（尤其大厂）到了 9 月中旬(秋招)/3 月中旬（春招），很可能就会没有 HC 了。面试的话一般都是至少是 3 轮起步，一些大厂比如阿里、字节可能会有 5 轮面试。<strong>面试失败话的不要紧，某一面表现差的话也不要紧，调整好心态。又不是单一选择对吧？你能投这么多企业呢! 调整心态。</strong> 今年面试的话，因为疫情原因，有些公司还是可能会还是集中在线上进行面试。然后，还是因为疫情的影响，可能会比往年更难找工作（对大厂影响较小）。</p>
<h2> 知道如何获取招聘信息</h2>
<p><strong>1、目标企业的官网/公众号</strong></p>
<p>最及时最权威的获取秋招信息的途径。</p>
<p><strong>2、招聘网站</strong></p>
<p><a href="https://www.zhipin.com/" target="_blank" rel="noopener noreferrer">BOSS 直聘</a>、<a href="https://www.zhaopin.com/" target="_blank" rel="noopener noreferrer">智联招聘</a>、<a href="https://www.lagou.com/" target="_blank" rel="noopener noreferrer">拉勾招聘</a>......。</p>
<p><strong>3、牛客网</strong></p>
<p>每年秋招/春招，都会有大批量的公司会到牛客网发布招聘信息，并且还会有大量的公司员工来到这里发内推的帖子。</p>
<p>地址：https://www.nowcoder.com/jobs/recommend/campus 。</p>
<p><strong>4、超级简历</strong></p>
<p>超级简历目前整合了各大企业的校园招聘入口，地址：https://www.wondercv.com/jobs/。</p>
<p>如果你是校招的话，点击“校招网申”就可以直接跳转到各大企业的校园招聘入口的整合页面了。</p>
<p><img src="https://img-blog.csdnimg.cn/20210412110352612.png" alt=""></p>
<p><strong>5、认识的朋友</strong></p>
<p>如果你有认识的朋友在目标企业工作的话，你也可以找他们了解秋招信息，并且可以让他们帮你内推。</p>
<p><strong>6、宣讲会现场</strong></p>
<p>Guide 当时也参加了几场宣讲会。不过，我是在荆州上学，那边没什么比较好的学校，一般没有公司去开宣讲会。所以，我当时是直接跑到武汉来了，参加了武汉理工大学以及华中科技大学的几场宣讲会。总体感觉还是很不错的！</p>
<p><strong>7、其他</strong></p>
<p>校园就业信息网、学校论坛、班级 or 年级 QQ 群</p>
<h2> 多花点时间完善简历</h2>
<p>一定一定一定要重视简历啊！朋友们！至少要花 2~3 天时间来专门完善自己的简历。</p>
<p>最近看了很多份简历，满意的很少，我简单拿出一份来说分析一下（欢迎在评论区补充）。</p>
<p><strong>1.个人介绍没太多实用的信息。</strong></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/0f02df1ce7f54aa0a8e0c5b2d23da6e9.webp?x-oss-process=image/format,png" alt=""></p>
<p>技术博客、Github 以及在校获奖经历的话，能写就尽量写在这里。 你可以参考下面 👇 的模板进行修改：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/b9ca9f520865006ae984301f77256f12.webp?x-oss-process=image/format,png" alt=""></p>
<p><strong>2.项目经历过于简单，完全没有质量可言</strong></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/0bc891e84c8229c498a1f2b870639196.webp?x-oss-process=image/format,png" alt=""></p>
<p>每一个项目经历真的就一两句话可以描述了么？还是自己不想写？还是说不是自己做的，不敢多写。</p>
<p>如果有项目的话，技术面试第一步，面试官一般都是让你自己介绍一下你的项目。你可以从下面几个方向来考虑：</p>
<ol>
<li>你对项目整体设计的一个感受（面试官可能会让你画系统的架构图）</li>
<li>你在这个项目中你负责了什么、做了什么、担任了什么角色。</li>
<li>从这个项目中你学会了那些东西，使用到了那些技术，学会了那些新技术的使用。</li>
<li>你在这个项目中是否解决过什么问题？怎么解决的？收获了什么？</li>
<li>你的项目用到了哪些技术？这些技术你吃透了没有？举个例子，你的项目经历使用了 Seata 来做分布式事务，那 Seata 相关的问题你要提前准备一下吧，比如说 Seata 支持哪些配置中心、Seata 的事务分组是怎么做的、Seata 支持哪些事务模式，怎么选择？</li>
<li>你在这个项目中犯过的错误，最后是怎么弥补的？</li>
</ol>
<p><strong>3.计算机二级这个证书对于计算机专业完全不用写了，没有含金量的。</strong></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/ddd2eaea3ae16c94491ae203f579c72b.webp?x-oss-process=image/format,png" alt=""></p>
<p><strong>4.技能介绍问题太大。</strong></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/93da1096fb02e19071ba13b4f6a7471c.png" alt=""></p>
<ul>
<li>技术名词最好规范大小写比较好，比如 java-&gt;Java ，spring boot -&gt; Spring Boot 。这个虽然有些面试官不会介意，但是很多面试官都会在意这个细节的。</li>
<li>技能介绍太杂，没有亮点。不需要全才，某个领域做得好就行了！</li>
<li>对 Java 后台开发的部分技能比如 Spring Boot 的熟悉度仅仅为了解，无法满足企业的要求。</li>
</ul>
<h2> 岗位匹配度很重要</h2>
<p>校招通常会对你的项目经历的研究方向比较宽容，即使你的项目经历和对应公司的具体业务没有关系，影响其实也并不大。</p>
<p>社招的话就不一样了，毕竟公司是要招聘可以直接来干活的人，你有相关的经验，公司会比较省事。社招通常会比较重视你的过往工作经历以及项目经历，HR 在筛选简历的时候会根据这两方面信息来判断你是否满足他们的招聘要求。就比如说你投递电商公司，而你之前的并没有和电商相关的工作经历以及项目经历，那 HR 在筛简历的时候很可能会直接把你 Pass 掉。</p>
<p>不过，这个也并不绝对，也有一些公司在招聘的时候更看重的是你的过往经历，较少地关注岗位匹配度，优秀公司的工作经历以及有亮点的项目经验都是加分项。这类公司相信你既然在某个领域（比如电商、支付）已经做的不错了，那应该也可以在另外一个领域（比如流媒体平台、社交软件）很快成为专家。这个领域指的不是技术领域，更多的是业务方向。横跨技术领域（比如后端转算法、后端转大数据）找工作，你又没有相关的经验，几乎是没办法找到的。即使找到了，也大概率会面临 HR 压薪资的问题。</p>
<h2> 提前准备技术面试和手撕算法</h2>
<p>面试之前一定要提前准备一下常见的面试题：</p>
<ul>
<li>自己面试中可能涉及哪些知识点、那些知识点是重点。</li>
<li>面试中哪些问题会被经常问到、面试中自己改如何回答。(强烈不推荐死记硬背，第一：通过背这种方式你能记住多少？能记住多久？第二：背题的方式的学习很难坚持下去！)</li>
</ul>
<p>这块内容只会介绍面试大概会涉及到哪方面的知识点，具体这些知识点涵盖哪些问题，后面的文章有介绍到。</p>
<p><strong>Java</strong> :</p>
<ul>
<li>Java 基础</li>
<li>Java 集合</li>
<li>Java 并发</li>
<li>JVM</li>
</ul>
<p><strong>计算机基础</strong> ：</p>
<ul>
<li>算法</li>
<li>数据结构</li>
<li>计算机网络</li>
<li>操作系统</li>
</ul>
<p><strong>数据库</strong> ：</p>
<ul>
<li>MySQL</li>
<li>Redis</li>
</ul>
<p><strong>常用框架</strong> ：</p>
<ul>
<li>Spring</li>
<li>SpringBoot</li>
<li>MyBatis</li>
<li>Netty</li>
<li>Zookeeper</li>
<li>Dubbo</li>
</ul>
<p><strong>分布式</strong> :</p>
<ul>
<li>CAP 理论 和 BASE 理论、Paxos 算法和 Raft 算法</li>
<li>RPC</li>
<li>分布式事务</li>
<li>分布式 ID</li>
</ul>
<p><strong>高并发</strong> ：</p>
<ul>
<li>消息队列</li>
<li>读写分离&amp;分库分表</li>
<li>负载均衡</li>
</ul>
<p><strong>高可用</strong> ：</p>
<ul>
<li>限流</li>
<li>降级</li>
<li>熔断</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210414112925296.png" alt=""></p>
<p>不同类型的公司对于技能的要求侧重点是不同的比如腾讯、字节可能更重视计算机基础比如网络、操作系统这方面的内容。阿里、美团这种可能更重视你的项目经历、实战能力。</p>
<p>关于如何准备算法面试请看《Java 面试指北》的「面试准备篇」中对应的文章。</p>
<h2> 提前准备自我介绍</h2>
<p>自我介绍一般是你和面试官的第一次面对面正式交流，换位思考一下，假如你是面试官的话，你想听到被你面试的人如何介绍自己呢？一定不是客套地说说自己喜欢编程、平时花了很多时间来学习、自己的兴趣爱好是打球吧？</p>
<p>我觉得一个好的自我介绍至少应该包含这几点要素：</p>
<ul>
<li>用简洁的话说清楚自己主要的技术栈于擅长的领域；</li>
<li>把重点放在自己在行的地方以及自己的优势之处；</li>
<li>重点突出自己的能力比如自己的定位的 bug 的能力特别厉害；</li>
</ul>
<p>简单来说就是用简洁的语言突出自己的亮点，也就是推销自己嘛！</p>
<ul>
<li>如果你去过大公司实习，那对应的实习经历就是你的亮点。</li>
<li>如果你参加过技术竞赛，那竞赛经历就是你的亮点。</li>
<li>如果你大学就接触过企业级项目的开发，实战经验比较多，那这些项目经历就是你的亮点。</li>
<li>......</li>
</ul>
<p>从社招和校招两个角度来举例子吧！我下面的两个例子仅供参考，自我介绍并不需要死记硬背，记住要说的要点，面试的时候根据公司的情况临场发挥也是没问题的。另外，网上一般建议的是准备好两份自我介绍：一份对 hr 说的，主要讲能突出自己的经历，会的编程技术一语带过；另一份对技术面试官说的，主要讲自己会的技术细节和项目经验。</p>
<p><strong>社招：</strong></p>
<blockquote>
<p>面试官，您好！我叫独秀儿。我目前有 1 年半的工作经验，熟练使用 Spring、MyBatis 等框架、了解 Java 底层原理比如 JVM 调优并且有着丰富的分布式开发经验。离开上一家公司是因为我想在技术上得到更多的锻炼。在上一个公司我参与了一个分布式电子交易系统的开发，负责搭建了整个项目的基础架构并且通过分库分表解决了原始数据库以及一些相关表过于庞大的问题，目前这个网站最高支持 10 万人同时访问。工作之余，我利用自己的业余时间写了一个简单的 RPC 框架，这个框架用到了 Netty 进行网络通信， 目前我已经将这个项目开源，在 Github 上收获了 2k 的 Star! 说到业余爱好的话，我比较喜欢通过博客整理分享自己所学知识，现在已经是多个博客平台的认证作者。 生活中我是一个比较积极乐观的人，一般会通过运动打球的方式来放松。我一直都非常想加入贵公司，我觉得贵公司的文化和技术氛围我都非常喜欢，期待能与你共事！</p>
</blockquote>
<p><strong>校招：</strong></p>
<blockquote>
<p>面试官，您好！我叫秀儿。大学时间我主要利用课外时间学习了 Java 以及 Spring、MyBatis 等框架 。在校期间参与过一个考试系统的开发，这个系统的主要用了 Spring、MyBatis 和 shiro 这三种框架。我在其中主要担任后端开发，主要负责了权限管理功能模块的搭建。另外，我在大学的时候参加过一次软件编程大赛，我和我的团队做的在线订餐系统成功获得了第二名的成绩。我还利用自己的业余时间写了一个简单的 RPC 框架，这个框架用到了 Netty 进行网络通信， 目前我已经将这个项目开源，在 Github 上收获了 2k 的 Star! 说到业余爱好的话，我比较喜欢通过博客整理分享自己所学知识，现在已经是多个博客平台的认证作者。 生活中我是一个比较积极乐观的人，一般会通过运动打球的方式来放松。我一直都非常想加入贵公司，我觉得贵公司的文化和技术氛围我都非常喜欢，期待能与你共事！</p>
</blockquote>
<h2> 减少抱怨</h2>
<p>就像现在的技术面试一样，大家都说内卷了，抱怨现在的面试真特么难。然而，单纯抱怨有用么？你对其他求职者说：“大家都不要刷 Leetcode 了啊！都不要再准备高并发、高可用的面试题了啊！现在都这么卷了！”</p>
<p>会有人听你的么？<strong>你不准备面试，但是其他人会准备面试啊！那你是不是傻啊？还是真的厉害到不需要准备面试呢？</strong></p>
<p>因此，准备 Java 面试的第一步，我们一定要尽量减少抱怨。抱怨的声音多了之后，会十分影响自己，会让自己变得十分焦虑。</p>
<h2> 面试之后及时复盘</h2>
<p>如果失败，不要灰心；如果通过，切勿狂喜。面试和工作实际上是两回事，可能很多面试未通过的人，工作能力比你强的多，反之亦然。</p>
<p>面试就像是一场全新的征程，失败和胜利都是平常之事。所以，劝各位不要因为面试失败而灰心、丧失斗志。也不要因为面试通过而沾沾自喜，等待你的将是更美好的未来，继续加油！</p>
<h2> 总结</h2>
<p>这篇文章内容有点多，如果这篇文章只能让你记住 4 句话，那请记住下面这 4 句：</p>
<ol>
<li>一定要提前准备面试！技术面试不同于编程，编程厉害不代表技术面试就一定能过。</li>
<li>一定不要对面试抱有侥幸心理。打铁还需自身硬！千万不要觉得自己看几篇面经，看几篇面试题解析就能通过面试了。一定要静下心来深入学习！</li>
<li>建议大学生尽可能早一点以求职为导向来学习的。这样更有针对性，并且可以大概率减少自己处在迷茫的时间，很大程度上还可以让自己少走很多弯路。 但是，不要把“以求职为导向学习”理解为“我就不用学课堂上那些计算机基础课程了”！</li>
<li>手撕算法是当下技术面试的标配，尽早准备！</li>
</ol>
]]></content:encoded>
      <enclosure url="https://img-blog.csdnimg.cn/20210412110352612.png" type="image/png"/>
    </item>
    <item>
      <title>贡献指南</title>
      <link>https://javaguide.cn/javaguide/contribution-guideline.html</link>
      <guid>https://javaguide.cn/javaguide/contribution-guideline.html</guid>
      <source url="https://javaguide.cn/rss.xml">贡献指南</source>
      <description>欢迎参与 JavaGuide 的维护工作，这是一件非常有意义的事情。详细信息请看：JavaGuide 贡献指南 。 你可以从下面几个方向来做贡献： 笔记内容大多是手敲，所以难免会有笔误，你可以帮我找错别字。 很多知识点我可能没有涉及到，所以你可以对其他知识点进行补充。 现有的知识点难免存在不完善或者错误，所以你可以对已有知识点进行修改/补充。</description>
      <category>走近项目</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<p>欢迎参与 JavaGuide 的维护工作，这是一件非常有意义的事情。详细信息请看：<a href="https://zhuanlan.zhihu.com/p/464832264" target="_blank" rel="noopener noreferrer">JavaGuide 贡献指南</a> 。</p>
<p>你可以从下面几个方向来做贡献：</p>
<ul>
<li>笔记内容大多是手敲，所以难免会有笔误，你可以帮我找错别字。</li>
<li>很多知识点我可能没有涉及到，所以你可以对其他知识点进行补充。</li>
<li>现有的知识点难免存在不完善或者错误，所以你可以对已有知识点进行修改/补充。</li>
</ul>
<p>一定一定一定要注意 <strong>排版规范</strong> ：</p>
<ul>
<li><a href="https://github.com/sparanoid/chinese-copywriting-guidelines" target="_blank" rel="noopener noreferrer">中文文案排版指北 - Github</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/20506092" target="_blank" rel="noopener noreferrer">写给大家看的中文排版指南 - 知乎</a></li>
<li><a href="https://dawner.top/posts/chinese-copywriting-rules/" target="_blank" rel="noopener noreferrer">中文文案排版细则 - Dawner</a></li>
<li><a href="https://github.com/yikeke/zh-style-guide/" target="_blank" rel="noopener noreferrer">中文技术文档写作风格指南</a></li>
</ul>
<p>如果要提 issue/question 的话，强烈推荐阅读下面这些资料：</p>
<ul>
<li><a href="https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way" target="_blank" rel="noopener noreferrer">《提问的智慧》</a></li>
<li><a href="https://github.com/seajs/seajs/issues/545" target="_blank" rel="noopener noreferrer">《如何向开源社区提问题》</a></li>
<li><a href="http://www.chiark.greenend.org.uk/~sgtatham/bugs-cn.html" target="_blank" rel="noopener noreferrer">《如何有效地报告 Bug》</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/25795393" target="_blank" rel="noopener noreferrer">《如何向开源项目提交无法解答的问题》</a>。</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>常见问题</title>
      <link>https://javaguide.cn/javaguide/faq.html</link>
      <guid>https://javaguide.cn/javaguide/faq.html</guid>
      <source url="https://javaguide.cn/rss.xml">常见问题</source>
      <description>JavaGuide 有没有 PDF 版本？ 由于 JavaGuide 内容在持续完善，所以并没有一个完全与之同步的 PDF 版本提供。如果你想要 PDF 版本的话，可以考虑 《JavaGuide 面试突击版》 ，这是对 JavaGuide 内容的浓缩总结。 《JavaGuide 面试突击版》在我的公众号后台回复“PDF”即可获取，免费的。除了 《JavaGuide 面试突击版》之外，还会免费送你多本优质面试 PDF 手册。</description>
      <category>走近项目</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<h2> JavaGuide 有没有 PDF 版本？</h2>
<p>由于 JavaGuide 内容在持续完善，所以并没有一个完全与之同步的 PDF 版本提供。如果你想要 PDF 版本的话，可以考虑 <strong>《JavaGuide 面试突击版》</strong> ，这是对 JavaGuide 内容的浓缩总结。</p>
<p>《JavaGuide 面试突击版》在我的公众号后台回复“<strong>PDF</strong>”即可获取，免费的。除了 《JavaGuide 面试突击版》之外，还会免费送你多本优质面试 PDF 手册。</p>
<div align="center">
    <img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/gongzhonghaoxuanchuan.png" style="margin: 0 auto;">
</div>
<h2> 如何看待 JavaGuide 的 star 数量很多？</h2>
<p><a href="https://github.com/Snailclimb" target="_blank" rel="noopener noreferrer">JavaGuide</a> 目前已经是 Java 领域 star 数量最多的几个项目之一，登顶过很多次 Github Trending。</p>
<p>不过，这个真心没啥好嘚瑟的。因为，教程类的含金量其实是比较低的，star 数量比较多主要也是因为受众面比较广，大家觉得不错，点个 star 就相当于收藏了。很多特别优秀的框架，star 数量可能只有几 K。所以，单纯看 star 数量没啥意思，就当看个笑话吧！</p>
<p>维护这个项目的过程中，也被某些人 diss 过：“md 项目，没啥含金量，给国人丢脸！”。</p>
<p>对于说这类话的人，我觉得对我没啥影响，就持续完善，把 JavaGuide 做的更好吧！其实，国外的很多项目也是纯 MD 啊！就比如外国的朋友发起的 awesome 系列、求职面试系列。无需多说，行动自证！凎！</p>
<p>开源非常重要的一点就是协作。如果你开源了一个项目之后，就不再维护，别人给你提交 issue/pr，你都不处理，那开源也没啥意义了！</p>
<h2> JavaGuide 会不会推出纸质书籍？</h2>
<p>可以给出一个比较明确的答案：<strong>暂时没有考虑出书</strong> 。</p>
<p>JavaGuide 这个项目诞生一年左右就有出版社的老师联系我了，由于自知个人能力尚需沉淀，我都婉拒了。这几年的话，由于项目还是有一点知名度的，找我出书的出版社老师更多了，也都被我一一婉拒了。</p>
<p><strong>出书既能博名又能赚点钱，我为啥不考虑出书呢？</strong></p>
<ul>
<li>JavaGuide 的很多内容我还不是很满意，也一直在维护中，细心的小伙伴看我的提交记录就明白了。</li>
<li>开源版本更容易维护和修改，也能让更多人更方便地参与到项目的建设中，这也是我最初做这个项目的初衷。</li>
<li>我觉得出书是一件神圣的事情，自认能力还不够。</li>
<li>个人精力有限，不光有本职工作，还弄了一个<a href="https://sourl.cn/psyWaE" target="_blank" rel="noopener noreferrer">知识星球</a>赚点外快，还要维护完善 JavaGuide。</li>
<li>......</li>
</ul>
<p>这几年一直在默默完善，真心希望 JavaGuide 越来越好，帮助到更多朋友！也欢迎大家参与进来！</p>
]]></content:encoded>
    </item>
    <item>
      <title>网站历史</title>
      <link>https://javaguide.cn/javaguide/history.html</link>
      <guid>https://javaguide.cn/javaguide/history.html</guid>
      <source url="https://javaguide.cn/rss.xml">网站历史</source>
      <description>由于项目内容一直持续在更新迭代，所以，这里就不记录项目内容的具体更新情况了。 你可以通过 RSS 订阅获取网站的最新更新，你还可以通过 https://javaguide.cn/article/获取到网站最新更新的文章。</description>
      <category>走近项目</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<p>由于项目内容一直持续在更新迭代，所以，这里就不记录项目内容的具体更新情况了。</p>
<p>你可以通过 <a href="https://javaguide.cn/feed.json" target="_blank" rel="noopener noreferrer">RSS 订阅</a>获取网站的最新更新，你还可以通过 <a href="https://javaguide.cn/article/" target="_blank" rel="noopener noreferrer">https://javaguide.cn/article/</a>获取到网站最新更新的文章。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguideimage-20220614172338606.png" alt=""></p>
<p>这里只记录一些比较重要的一些节点：</p>
<ul>
<li><a href="https://github.com/Snailclimb/JavaGuide/commit/83efb36fb56d197f2c4b471084b884c6a4f23e37" target="_blank" rel="noopener noreferrer">2022-06-13</a>：完善网站排版以及样式。</li>
<li><a href="https://github.com/Snailclimb/JavaGuide/commit/618477f96c4a976cfe5a3bba2f646c0d20e3137e" target="_blank" rel="noopener noreferrer">2022-04-09</a>：添加<a href="https://javaguide.cn/books/" target="_blank" rel="noopener noreferrer">技术书籍精选</a>。</li>
<li><a href="https://github.com/Snailclimb/JavaGuide/commit/5c45af9c7a7cff0d3bc905b09b3bc42f2ee8a88a" target="_blank" rel="noopener noreferrer">2021-03-13</a> ：添加<a href="https://javaguide.cn/open-source-project/" target="_blank" rel="noopener noreferrer">开源项目精选</a>。</li>
<li><a href="https://github.com/Snailclimb/JavaGuide/commit/827996e7722fd51718863d4bee156a8c6c759ff5" target="_blank" rel="noopener noreferrer">2021-03-03</a> : 移除了开发工具的部分内容。</li>
<li><a href="https://github.com/Snailclimb/JavaGuide/commit/5a5f8ccb3bfb8d6ba8ac41295f1a1e4555395260" target="_blank" rel="noopener noreferrer">2021-03-03</a> ： vuepress-theme-hope 主题更新升级（比较重要的一次主题更新，从 1.x 版本升级到 2.x 版本，网站性能提升）。</li>
<li><a href="https://github.com/Snailclimb/JavaGuide/commit/dc45389934b7763f4f9789168f71c72ef303d3c4" target="_blank" rel="noopener noreferrer">2021-11-09</a> : 基于 vuepress 重构整个项目，提升阅读体验。</li>
</ul>
]]></content:encoded>
      <enclosure url="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguideimage-20220614172338606.png" type="image/png"/>
    </item>
    <item>
      <title>项目介绍</title>
      <link>https://javaguide.cn/javaguide/intro.html</link>
      <guid>https://javaguide.cn/javaguide/intro.html</guid>
      <source url="https://javaguide.cn/rss.xml">项目介绍</source>
      <description>在大三准备面试的时候，我开源了 JavaGuide 。我把自己准备面试过程中的一些总结都毫不保留地通过 JavaGuide 分享了出来。 开源 JavaGuide 初始想法源于自己的个人那一段比较迷茫的学习经历。主要目的是为了通过这个开源平台来帮助一些在学习 Java 或者面试过程中遇到问题的小伙伴。 对于 Java 初学者来说： 本文档倾向于给你提供一个比较详细的学习路径，让你对于 Java 整体的知识体系有一个初步认识。另外，本文的一些文章也是你学习和复习 Java 知识不错的实践； 对于非 Java 初学者来说： 本文档更适合回顾知识，准备面试，搞清面试应该把重心放在那些问题上。要搞清楚这个道理：提前知道那些面试常见，不是为了背下来应付面试，而是为了让你可以更有针对的学习重点。</description>
      <category>走近项目</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<p>在大三准备面试的时候，我开源了 JavaGuide 。我把自己准备面试过程中的一些总结都毫不保留地通过 JavaGuide 分享了出来。</p>
<p>开源 JavaGuide 初始想法源于自己的个人那一段比较迷茫的学习经历。主要目的是为了通过这个开源平台来帮助一些在学习 Java 或者面试过程中遇到问题的小伙伴。</p>
<ul>
<li><strong>对于 Java 初学者来说：</strong> 本文档倾向于给你提供一个比较详细的学习路径，让你对于 Java 整体的知识体系有一个初步认识。另外，本文的一些文章也是你学习和复习 Java 知识不错的实践；</li>
<li><strong>对于非 Java 初学者来说：</strong> 本文档更适合回顾知识，准备面试，搞清面试应该把重心放在那些问题上。要搞清楚这个道理：提前知道那些面试常见，不是为了背下来应付面试，而是为了让你可以更有针对的学习重点。</li>
</ul>
<p>相比于其他通过 JavaGuide 学到东西或者说助力获得 offer 的朋友来说 ， JavaGuide 对我的意义更加重大。不夸张的说，有时候真的感觉像是自己的孩子一点一点长大一样，我一直用心呵护着它。虽然，我花了很长时间来维护它，但是，我觉得非常值得！非常有意义！</p>
<p>希望大家对面试不要抱有侥幸的心理，打铁还需自身硬！ 我希望这个文档是为你学习 Java 指明方向，而不是用来应付面试用的。加油！奥利给！</p>
<h2> 项目说明</h2>
<ul>
<li><a href="https://javaguide.cn" target="_blank" rel="noopener noreferrer">在线阅读网站</a>基于 Vuepress 搭建，使用的是主题是 <a href="https://github.com/vuepress-theme-hope/vuepress-theme-hope" target="_blank" rel="noopener noreferrer">vuepress-theme-hope</a>（很 Nice 的一个主题）。</li>
<li>项目的 Markdown 格式参考：<a href="https://guides.github.com/features/mastering-markdown/" target="_blank" rel="noopener noreferrer">Github Markdown 格式</a>，表情素材来自：<a href="https://www.webpagefx.com/tools/emoji-cheat-sheet/" target="_blank" rel="noopener noreferrer">EMOJI CHEAT SHEET</a>。</li>
<li>Logo 下的小图标是使用<a href="https://shields.io/" target="_blank" rel="noopener noreferrer">Shields.IO</a> 生成的。</li>
</ul>
<h2> 贡献者</h2>
<p><a href="https://github.com/Snailclimb/JavaGuide/graphs/contributors" target="_blank" rel="noopener noreferrer">你可以点此链接查看 JavaGuide 的所有贡献者。</a> 感谢你们让 JavaGuide 变得更好！如果你们来到武汉一定要找我，我请你们吃饭玩耍。</p>
<p>欢迎参与 <a href="https://zhuanlan.zhihu.com/p/464832264" target="_blank" rel="noopener noreferrer">JavaGuide 的维护工作</a>，这是一件非常有意义的事情。</p>
]]></content:encoded>
    </item>
    <item>
      <title>项目待办</title>
      <link>https://javaguide.cn/javaguide/todo.html</link>
      <guid>https://javaguide.cn/javaguide/todo.html</guid>
      <source url="https://javaguide.cn/rss.xml">项目待办</source>
      <description>数据结构内容完善 Java 基础内容完善 大篇幅文章拆分 JVM 内容更新完善 计算机网络知识点完善 分布式常见理论和算法总结完善</description>
      <category>走近项目</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<ul class="task-list-container">
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-0" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-0"> 数据结构内容完善</label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-1" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-1"> Java 基础内容完善</label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-2" checked="checked" disabled="disabled"><label class="task-list-item-label" for="task-item-2"> 大篇幅文章拆分</label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-3" disabled="disabled"><label class="task-list-item-label" for="task-item-3"> JVM 内容更新完善</label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-4" disabled="disabled"><label class="task-list-item-label" for="task-item-4"> 计算机网络知识点完善</label></li>
<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox" id="task-item-5" disabled="disabled"><label class="task-list-item-label" for="task-item-5"> 分布式常见理论和算法总结完善</label></li>
</ul>
<p>欢迎参与 JavaGuide 的维护工作，这是一件非常有意义的事情。详细信息请看：<a href="/javaguide/contribution-guideline.html" target="blank">JavaGuide 贡献指南</a> 。</p>
]]></content:encoded>
    </item>
    <item>
      <title>个人博客内容</title>
      <link>https://javaguide.cn/my-blog/</link>
      <guid>https://javaguide.cn/my-blog/</guid>
      <source url="https://javaguide.cn/rss.xml">个人博客内容</source>
      <description>个人博客内容 docker 安装基础软件 👉 日常博客文章，编写关于dokcer相关内容 👉 作者：小白</description>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 个人博客内容</h1>
<div class="hint-container tip">
<p class="hint-container-title">docker 安装基础软件</p>
<p>👉 日常博客文章，编写关于dokcer相关内容</p>
<p>👉 作者：小白</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>Java 优质开源大数据项目</title>
      <link>https://javaguide.cn/open-source-project/big-data.html</link>
      <guid>https://javaguide.cn/open-source-project/big-data.html</guid>
      <source url="https://javaguide.cn/rss.xml">Java 优质开源大数据项目</source>
      <description>Spark :Spark 是用于大规模数据处理的统一分析引擎。 Flink ：Apache Flink 是一个框架和分布式处理引擎，用于在无边界和有边界数据流上进行有状态的计算。Flink 能在所有常见集群环境中运行，并能以内存速度和任意规模进行计算。 HBase： HBase – Hadoop Database，是一个高可靠性、高性能、面向列、可伸缩的分布式存储系统，利用 HBase 技术可在廉价 PC Server 上搭建起大规模结构化存储集群。 Flume :Apache Flume 是一个分布式的、可靠的、可用的，从多种不同的源收集、聚集、移动大量日志数据到集中数据存储的系统。 Storm : 一个分布式，高容错的实时计算系统。</description>
      <category>开源项目</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<ul>
<li><strong><a href="https://github.com/apache/spark" target="_blank" rel="noopener noreferrer">Spark</a></strong> :Spark 是用于大规模数据处理的统一分析引擎。</li>
<li><strong><a href="https://github.com/apache/flink" title="flink" target="_blank" rel="noopener noreferrer">Flink</a></strong> ：Apache Flink 是一个框架和分布式处理引擎，用于在<em>无边界和有边界</em>数据流上进行有状态的计算。Flink 能在所有常见集群环境中运行，并能以内存速度和任意规模进行计算。</li>
<li><strong><a href="https://hbase.apache.org/" target="_blank" rel="noopener noreferrer">HBase</a></strong>： HBase – Hadoop Database，是一个高可靠性、高性能、面向列、可伸缩的分布式存储系统，利用 HBase 技术可在廉价 PC Server 上搭建起大规模结构化存储集群。</li>
<li><strong><a href="https://flume.apache.org/" target="_blank" rel="noopener noreferrer">Flume</a></strong> :Apache Flume 是一个分布式的、可靠的、可用的，从多种不同的源收集、聚集、移动大量日志数据到集中数据存储的系统。</li>
<li><strong><a href="https://storm.apache.org/" target="_blank" rel="noopener noreferrer">Storm</a></strong> : 一个分布式，高容错的实时计算系统。</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Java 优质开源机器学习项目</title>
      <link>https://javaguide.cn/open-source-project/machine-learning.html</link>
      <guid>https://javaguide.cn/open-source-project/machine-learning.html</guid>
      <source url="https://javaguide.cn/rss.xml">Java 优质开源机器学习项目</source>
      <description>Deeplearning4j ： Deeplearning4j 是第一个为 Java 和 Scala 编写的商业级，开源，分布式深度学习库。 Smile ：基于 Java 和 Scala 的机器学习库。</description>
      <category>开源项目</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<ul>
<li><strong><a href="https://github.com/eclipse/deeplearning4j" target="_blank" rel="noopener noreferrer">Deeplearning4j</a></strong> ： Deeplearning4j 是第一个为 Java 和 Scala 编写的商业级，开源，分布式深度学习库。</li>
<li><strong><a href="https://github.com/haifengl/smile" target="_blank" rel="noopener noreferrer">Smile</a></strong> ：基于 Java 和 Scala 的机器学习库。</li>
</ul>
<p>相关阅读：<a href="https://www.infoq.cn/article/GA9UeYlv8ohBzBso9eph" target="_blank" rel="noopener noreferrer">Java 能用于机器学习和数据科学吗？-InfoQ</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>Java 优质开源实战项目</title>
      <link>https://javaguide.cn/open-source-project/practical-project.html</link>
      <guid>https://javaguide.cn/open-source-project/practical-project.html</guid>
      <source url="https://javaguide.cn/rss.xml">Java 优质开源实战项目</source>
      <description>博客/论坛系统 下面这几个项目都是非常适合 Spring Boot 初学者学习的，下面的大部分项目的总体代码架构我都看过，个人觉得还算不错，不会误导没有实际做过项目的朋友。 blog ：一款基于 SpringBoot + Vue 开发的前后端分离博客，非常精致，功能也比通过类型博客系统更加丰富完善。采用 SpringSecurity 进行权限管理，ElasticSearch 全文搜索，支持 QQ、微博第三方登录、在线聊天、发布说说等功能。相关阅读：这个 SpringBoot+ Vue 开源博客系统太酷炫了！。 forest ：下一代的知识社区系统，可以自定义专题和作品集。后端基于 SpringBoot + Shrio + MyBatis + JWT + Redis，前端基于 Vue + NuxtJS + Element-UI。 vhr ：微人事是一个前后端分离的人力资源管理系统，项目采用 SpringBoot+Vue 开发。 favorites-web :云收藏 Spring Boot 2.X 开源项目。云收藏是一个使用 Spring Boot 构建的开源网站，可以让用户在线随时随地收藏的一个网站，在网站上分类整理收藏的网站或者文章。 community ：开源论坛、问答系统，现有功能提问、回复、通知、最新、最热、消除零回复功能。功能持续更新中…… 技术栈 Spring、Spring Boot、MyBatis、MySQL/H2、Bootstrap。 VBlog ：V 部落，Vue+SpringBoot 实现的多用户博客管理平台! My-Blog ： My Blog 是由 SpringBoot + Mybatis + Thymeleaf 等技术实现的 Java 博客系统，页面美观、功能齐全、部署简单及完善的代码，一定会给使用者无与伦比的体验。</description>
      <category>开源项目</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 博客/论坛系统</h2>
<p>下面这几个项目都是非常适合 Spring Boot 初学者学习的，下面的大部分项目的总体代码架构我都看过，个人觉得还算不错，不会误导没有实际做过项目的朋友。</p>
<ul>
<li><strong><a href="https://github.com/X1192176811/blog" target="_blank" rel="noopener noreferrer">blog</a></strong> ：一款基于 SpringBoot + Vue 开发的前后端分离博客，非常精致，功能也比通过类型博客系统更加丰富完善。采用 SpringSecurity 进行权限管理，ElasticSearch 全文搜索，支持 QQ、微博第三方登录、在线聊天、发布说说等功能。相关阅读：<a href="https://mp.weixin.qq.com/s/CCzsX3Sn2Q3vhuBDEmRTlw" target="_blank" rel="noopener noreferrer">这个 SpringBoot+ Vue 开源博客系统太酷炫了！</a>。</li>
<li><strong><a href="https://github.com/rymcu" target="_blank" rel="noopener noreferrer">forest</a></strong> ：下一代的知识社区系统，可以自定义专题和作品集。后端基于 SpringBoot + Shrio + MyBatis + JWT + Redis，前端基于 Vue + NuxtJS + Element-UI。</li>
<li><strong><a href="https://github.com/lenve/vhr" title="vhr" target="_blank" rel="noopener noreferrer">vhr</a></strong> ：微人事是一个前后端分离的人力资源管理系统，项目采用 SpringBoot+Vue 开发。</li>
<li><strong><a href="https://github.com/cloudfavorites/favorites-web" target="_blank" rel="noopener noreferrer">favorites-web</a></strong> :云收藏 Spring Boot 2.X 开源项目。云收藏是一个使用 Spring Boot 构建的开源网站，可以让用户在线随时随地收藏的一个网站，在网站上分类整理收藏的网站或者文章。</li>
<li><strong><a href="https://github.com/codedrinker/community" target="_blank" rel="noopener noreferrer">community</a></strong> ：开源论坛、问答系统，现有功能提问、回复、通知、最新、最热、消除零回复功能。功能持续更新中…… 技术栈 Spring、Spring Boot、MyBatis、MySQL/H2、Bootstrap。</li>
<li><strong><a href="https://github.com/lenve/VBlog" target="_blank" rel="noopener noreferrer">VBlog</a></strong> ：V 部落，Vue+SpringBoot 实现的多用户博客管理平台!</li>
<li><strong><a href="https://github.com/ZHENFENG13/My-Blog" target="_blank" rel="noopener noreferrer">My-Blog</a></strong> ： My Blog 是由 SpringBoot + Mybatis + Thymeleaf 等技术实现的 Java 博客系统，页面美观、功能齐全、部署简单及完善的代码，一定会给使用者无与伦比的体验。</li>
</ul>
<h2> 考试/刷题系统</h2>
<ul>
<li><strong><a href="https://gitee.com/mindskip/uexam" target="_blank" rel="noopener noreferrer">uexam</a></strong> ：一个非常不错的考试系统！考试系统应用场景还挺多的，不论是对于在校大学生还是已经工作的小伙伴，并且，类似的私活也有很多。相关阅读：<a href="http://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s%3F__biz%3DMzg2OTA0Njk0OA%3D%3D%26mid%3D2247491585%26idx%3D1%26sn%3D8d3c6768c22e72d6bfcbeee9624886a7%26chksm%3Dcea1afcaf9d626dc918760289c37025ad526f6255786bc198d2402203df64c873ad7934f58df%26scene%3D178%26cur_album_id%3D1345382825083895808%23rd" target="_blank" rel="noopener noreferrer">《好一个 Spring Boot 开源在线考试系统！解决了我的燃眉之急》</a> 。</li>
<li><strong><a href="https://github.com/Jackson0714/PassJava-Platform" target="_blank" rel="noopener noreferrer">PassJava-Platform</a></strong> ：一个基于微服务(SpringBoot、Spring Cloud)的面试刷题系统！相关阅读：<a href="http://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s%3F__biz%3DMzg2OTA0Njk0OA%3D%3D%26mid%3D2247497045%26idx%3D1%26sn%3D577175bfd6c040a0df5a494fce6f9758%26chksm%3Dcea1ba9ef9d633883a2e213c0fb9a88bdc87051347d4b3fad2c2befb65d8b16e1ea81d8146dd%26scene%3D178%26cur_album_id%3D1345382825083895808%23rd" target="_blank" rel="noopener noreferrer">《一个基于 Spring Cloud 的面试刷题系统。面试、毕设、项目经验一网打尽》</a>。</li>
</ul>
<p>相关文章：<a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247491191&amp;idx=1&amp;sn=fd5efa645c2f2e09f088f6a018cea028&amp;chksm=cea251bcf9d5d8aac8653c686b7a331ffe4e13aa9ffc9beab2c378ea2497a9bd3295ff8d2c51&amp;token=747074901&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">想要搭建个人博客？我调研了 100 来个 Java 开源博客系统，发现这 5 个最好用！</a></p>
<h2> 商城系统</h2>
<p>下面的商城系统大多比较复杂比如 mall ,如果没有 Java 基础和 Spring Boot 都还没有摸熟的话不推荐过度研究下面几个项目或者使用这些项目当作毕业设计。</p>
<ul>
<li><strong><a href="https://github.com/macrozheng/mall" title="mall" target="_blank" rel="noopener noreferrer">mall</a></strong> ：mall 项目是一套电商系统，包括前台商城系统及后台管理系统，基于 SpringBoot+MyBatis 实现。</li>
<li><strong><a href="https://github.com/macrozheng/mall-swarm" title="mall-swarm" target="_blank" rel="noopener noreferrer">mall-swarm</a></strong> : mall-swarm 是一套微服务商城系统，采用了 Spring Cloud Greenwich、Spring Boot 2、MyBatis、Docker、Elasticsearch 等核心技术，同时提供了基于 Vue 的管理后台方便快速搭建系统。</li>
<li><strong><a href="https://github.com/YunaiV/onemall" target="_blank" rel="noopener noreferrer">onemall</a></strong> ：mall 商城，基于微服务的思想，构建在 B2C 电商场景下的项目实战。核心技术栈，是 Spring Boot + Dubbo 。未来，会重构成 Spring Cloud Alibaba 。</li>
<li><strong><a href="https://github.com/linlinjava/litemall" title="litemall" target="_blank" rel="noopener noreferrer">litemall</a></strong> ： 又一个小商城。litemall = Spring Boot 后端 + Vue 管理员前端 + 微信小程序用户前端 + Vue 用户移动端。</li>
<li><strong><a href="https://github.com/Exrick/xmall" target="_blank" rel="noopener noreferrer">xmall</a></strong> :基于 SOA 架构的分布式电商购物商城 前后端分离 前台商城:Vue 全家桶 后台管理系统:Spring/Dubbo/SSM/Elasticsearch/Redis/MySQL/ActiveMQ/Shiro/Zookeeper 等</li>
<li><strong><a href="https://github.com/newbee-ltd/newbee-mall" target="_blank" rel="noopener noreferrer">newbee-mall</a></strong> :newbee-mall 项目（新蜂商城）是一套电商系统，包括 newbee-mall 商城系统及 newbee-mall-admin 商城后台管理系统，基于 Spring Boot 2.X 及相关技术栈开发。</li>
</ul>
<h2> 权限管理系统</h2>
<p>权限管理系统在企业级的项目中一般都是非常重要的，如果你需求去实际了解一个不错的权限系统是如何设计的话，推荐你可以参考下面这些开源项目。</p>
<ul>
<li><strong><a href="https://github.com/wxiaoqi/Spring-Cloud-Admin" title="Spring-Cloud-Admin" target="_blank" rel="noopener noreferrer">Spring-Cloud-Admin</a></strong> ：Cloud-Admin 是国内首个基于 Spring Cloud 微服务化开发平台，具有统一授权、认证后台管理系统，其中包含具备用户管理、资源权限管理、网关 API 管理等多个模块，支持多业务系统并行开发，可以作为后端服务的开发脚手架。代码简洁，架构清晰，适合学习和直接项目中使用。核心技术采用 Spring Boot2 以及 Spring Cloud Gateway 相关核心组件，前端采用 vue-element-admin 组件。</li>
<li><strong><a href="https://gitee.com/log4j/pig" title="pig" target="_blank" rel="noopener noreferrer">pig</a></strong>：（gitee）基于 Spring Boot 2.2、 Spring Cloud Hoxton &amp; Alibaba、 OAuth2 的 RBAC 权限管理系统。</li>
<li><strong><a href="https://github.com/wuyouzhuguli/FEBS-Shiro" title="FEBS-Shiro" target="_blank" rel="noopener noreferrer">FEBS-Shiro</a></strong> ：Spring Boot 2.1.3，Shiro1.4.0 &amp; Layui 2.5.4 权限管理系统。</li>
<li><strong><a href="https://github.com/elunez/eladmin" target="_blank" rel="noopener noreferrer">eladmin</a></strong> : 项目基于 Spring Boot 2.1.0 、 Jpa、 Spring Security、redis、Vue 的前后端分离的后台管理系统，项目采用分模块开发方式， 权限控制采用 RBAC，支持数据字典与数据权限管理，支持一键生成前后端代码，支持动态路由。</li>
<li><strong><a href="https://github.com/Heeexy/SpringBoot-Shiro-Vue" target="_blank" rel="noopener noreferrer">SpringBoot-Shiro-Vue</a></strong> ：提供一套基于 Spring Boot-Shiro-Vue 的权限管理思路.前后端都加以控制,做到按钮/接口级别的权限。</li>
</ul>
<h2> 快速开发脚手架</h2>
<ul>
<li><strong><a href="https://gitee.com/y_project/RuoYi" target="_blank" rel="noopener noreferrer">RuoYi</a></strong> ：RuoYi 一款基于基于 SpringBoot 的权限管理系统 易读易懂、界面简洁美观，直接运行即可用 。</li>
<li><strong><a href="https://github.com/valarchie/AgileBoot-Back-End" target="_blank" rel="noopener noreferrer">AgileBoot-Back-End</a></strong> ：基于Ruoyi做了大量重构优化的基础快速开发框架。采用Springboot + Vue 3 + Mybatis Plus + 更面向对象的业务建模 + 面向生产的项目。（非玩具项目）</li>
<li><strong><a href="https://github.com/YunaiV/ruoyi-vue-pro" target="_blank" rel="noopener noreferrer">RuoYi-Vue-Pro</a></strong> ： 基于 SpringBoot，Spring Security，JWT，Vue &amp; Element 的前后端分离权限管理系统。</li>
<li><strong><a href="https://gitee.com/stylefeng/guns" target="_blank" rel="noopener noreferrer">Guns</a></strong> ： 我在上大学的时候就了解和接触过了这个项目，当时我还是一个 Spring 入门不太久的小菜鸟。一晃，不经意间已经过去快 3 年了。Guns 功能齐全 ，采用主流框架 Spring Boot2.0+开发，并且支持 Spring Cloud Alibaba 微服务）。 适合企业后台管理网站的快速开发场景，不论是对于单体和微服务都有支持。</li>
<li><strong><a href="https://github.com/jhipster/generator-jhipster" target="_blank" rel="noopener noreferrer">JHipster</a></strong> :开源应用程序平台，可在几秒钟内创建 Spring Boot + Angular / React 项目！</li>
<li><strong><a href="https://github.com/zhangdaiscott/jeecg-boot" target="_blank" rel="noopener noreferrer">JeecgBoot</a></strong>：一款基于代码生成器的 J2EE 低代码快速开发平台，支持生成前后端分离架构的项目。</li>
<li><strong><a href="https://github.com/zuihou/zuihou-admin-cloud" target="_blank" rel="noopener noreferrer">zuihou-admin-cloud</a></strong> :基于<code>SpringCloud(Hoxton.SR7)</code> + <code>SpringBoot(2.2.9.RELEASE)</code> 的 SaaS 型微服务快速开发平台，具备用户管理、资源权限管理、网关统一鉴权、Xss 防跨站攻击、自动代码生成、多存储系统、分布式事务、分布式定时任务等多个模块，支持多业务系统并行开发， 支持多服务并行开发，可以作为后端服务的开发脚手架。</li>
<li><strong><a href="https://gitee.com/erupt/erupt" target="_blank" rel="noopener noreferrer">Erupt</a></strong> : 使用 Java 注解，快速开发 Admin 管理后台。零前端代码、零 CURD、不生成任何代码、自动建表、注解式 API，支持所有主流数据库，支持自定义页面，支持多数据源，提供二十几类业务组件，十几种展示形式，支持逻辑删除，动态定时任务，前端后端分离等。 核心技术：Spring Boot、JPA、Reflect、TypeScript、NG-ZORRO 等。</li>
<li><strong><a href="https://gitee.com/lab1024/smart-admin" target="_blank" rel="noopener noreferrer">SmartAdmin</a></strong> : 互联网企业级的通用型中后台解决方案！使用最前沿的前后台技术栈 SpringBoot 和 Vue，前后端分离!代码质量非常高！</li>
<li><strong><a href="https://github.com/ballcat-projects/ballcat" target="_blank" rel="noopener noreferrer">BallCat</a></strong> ：一个功能完善的快速开发脚手架！除了最基本的权限管理，定时任务功能之外，还额外支持 XSS 过滤，SQL 防注入、数据脱敏等多种功能</li>
</ul>
<p><strong>相关阅读</strong> ：</p>
<ul>
<li><a href="https://sourl.cn/cFyLTR" target="_blank" rel="noopener noreferrer">听说你要接私活？Guide 连夜整理了 5 个开源免费的 Java 项目快速开发脚手架。</a></li>
<li><a href="https://sourl.cn/StkiAv" target="_blank" rel="noopener noreferrer">解放双手，再来推荐 5 个 Java 项目开发快速开发脚手架！项目经验和私活都不愁了！</a></li>
</ul>
<h2> 造轮子</h2>
<ul>
<li><strong><a href="https://github.com/Snailclimb/guide-rpc-framework" target="_blank" rel="noopener noreferrer">guide-rpc-framework</a></strong> ：一款基于 Netty+Kyro+Zookeeper 实现的自定义 RPC 框架-附详细实现过程和相关教程。</li>
<li><strong><a href="https://github.com/DerekYRC/mini-spring" target="_blank" rel="noopener noreferrer">mini-spring</a></strong> ：简化版的 Spring 框架，能帮助你快速熟悉 Spring 源码和掌握 Spring 的核心原理。代码极度简化，保留了 Spring 的核心功能，如 IoC 和 AOP、资源加载器等核心功能。</li>
<li><strong><a href="https://github.com/DerekYRC/mini-spring-cloud" target="_blank" rel="noopener noreferrer">mini-spring-cloud</a></strong> ：一个手写的简化版的 Spring Cloud，旨在帮助你快速熟悉 Spring Cloud 源码及掌握其核心原理。相关阅读：<a href="https://mp.weixin.qq.com/s/v3FUp-keswE2EhcTaLpSMQ" target="_blank" rel="noopener noreferrer">手写一个简化版的 Spring Cloud！</a> 。</li>
<li><strong><a href="https://github.com/fuzhengwei/itstack-demo-jvm" target="_blank" rel="noopener noreferrer">itstack-demo-jvm</a></strong> ：通过 Java 代码来实现 JVM 的基础功能（搜索解析 class 文件、字节码命令、运行时数据区等。相关阅读：<a href="https://zachaxy.github.io/tags/JVM/" target="_blank" rel="noopener noreferrer">《zachaxy 的手写 JVM 系列》</a></li>
<li><strong><a href="https://github.com/alchemystar/Freedom" target="_blank" rel="noopener noreferrer">Freedom</a></strong> ：自己 DIY 一个具有 ACID 的数据库。相关项目：<a href="https://github.com/CN-GuoZiyang/MYDB" target="_blank" rel="noopener noreferrer">MYDB</a>（一个简单的数据库实现）、<a href="https://github.com/erikgrinaker/toydb" target="_blank" rel="noopener noreferrer">toyDB</a>（Rust 实现的分布式 SQL 数据库）。</li>
<li><strong><a href="https://github.com/stateIs0/lu-raft-kv" target="_blank" rel="noopener noreferrer">lu-raft-kv</a></strong> ：一个 Java 版本的 Raft(CP) KV 分布式存储实现，非常适合想要深入学习 Raft 协议的小伙伴研究。lu-raft-kv 已经实现了 Raft 协议其中的两个核心功能：leader 选举和日志复制。如果你想要学习这个项目的话，建议你提前看一下作者写的项目介绍，比较详细，地址：http://thinkinjava.cn/2019/01/12/2019/2019-01-12-lu-raft-kv/ 。</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Java 开源项目精选</title>
      <link>https://javaguide.cn/open-source-project/</link>
      <guid>https://javaguide.cn/open-source-project/</guid>
      <source url="https://javaguide.cn/rss.xml">Java 开源项目精选</source>
      <description>这是一则或许对你有用的小广告 👉 欢迎准备 Java 面试以及学习 Java 的同学加入我的知识星球，干货很多！收费虽然是白菜价，但星球里的内容或许比你参加上万的培训班质量还要高。 👉 《Java 面试指北》持续更新完善中！这是一份教你如何更高效地准备面试的小册，涵盖常见八股文（系统设计、常见框架、分布式、高并发 ......）、优质面经等内容。</description>
      <category>开源项目</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<div class="hint-container tip">
<p class="hint-container-title">这是一则或许对你有用的小广告</p>
<p>👉 欢迎准备 Java 面试以及学习 Java 的同学加入我的<a href="/about-the-author/zhishixingqiu-two-years.html" target="blank">知识星球</a>，干货很多！收费虽然是白菜价，但星球里的内容或许比你参加上万的培训班质量还要高。</p>
<p>👉 <a href="/zhuanlan/java-mian-shi-zhi-bei.html" target="blank">《Java 面试指北》</a>持续更新完善中！这是一份教你如何更高效地准备面试的小册，涵盖常见八股文（系统设计、常见框架、分布式、高并发 ......）、优质面经等内容。</p>
</div>
<p>精选 Github 和 Gitee 上优质的 Java 开源项目.</p>
<p>欢迎大家在项目 <a href="https://github.com/CodingDocs/awesome-java/issues" target="_blank" rel="noopener noreferrer">issues 区</a>推荐自己认可的 Java 开源项目，让我们共同维护一个优质的 Java 开源项目精选集！</p>
<ul>
<li>Github 地址：<a href="https://github.com/CodingDocs/awesome-java" target="_blank" rel="noopener noreferrer">https://github.com/CodingDocs/awesome-java</a></li>
<li>Gitee 地址：<a href="https://gitee.com/SnailClimb/awesome-java" target="_blank" rel="noopener noreferrer">https://gitee.com/SnailClimb/awesome-java</a></li>
</ul>
<p>如果内容对你有帮助的话，欢迎给本项目点个 Star。我会用我的业余时间持续完善这份名单，感谢！</p>
<p>另外，我的公众号还会定期分享优质开源项目，每一期我都会精选 5 个高质量的 Java 开源项目。</p>
<p>目前已经更新到了第 13 期：</p>
<ol>
<li><a href="http://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247515383&amp;idx=1&amp;sn=ba7244020c05d966b483d8c302d54e85&amp;chksm=cea1f33cf9d67a2a111bcf6cadc3cc1c44828ba2302cd3e13bbd88349e43d4254808e6434133&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">一款基于 Spring Boot + Vue 的一站式开源持续测试平台</a>。</li>
<li><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247515981&amp;idx=1&amp;sn=e4b9c06af65f739bdcdf76bdc35d59f6&amp;chksm=cea1f086f9d679908bd6604b1c42d67580160d9789951f3707ad2f5de4d97aa72121d8fe777e&amp;token=435278690&amp;lang=zh_CN&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">用 Java 写个沙盒塔防游戏！已上架 Steam,Apple Store</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247516459&amp;idx=1&amp;sn=a86fefe083fa91c83638243d75500a04&amp;chksm=cea1cee0f9d647f69237357e869f52e0903afad62f365e18b04ff1851aeb4c80c8d31a488fee&amp;scene=21&amp;cur_album_id=1345382825083895808#wechat_redirect" target="_blank" rel="noopener noreferrer">一款基于 Java 的可视化 HTTP API 接口开发神器</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247518215&amp;idx=1&amp;sn=91e467f39322d2e7979b85fe235822d2&amp;chksm=cea1c7ccf9d64edaf966c95923d72d337bf5e655a773a3d295d65fc92e4535ae5d8b0e6d9d86&amp;token=660789642&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">一款对业务代码无侵入的可视化 Java 进程管理平台</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247519466&amp;idx=1&amp;sn=0dd412d5220444b37a1101f77ccdc65d&amp;chksm=cea1c321f9d64a376ef7de329b5c91e593a32c7a8e5c179b7ab3619296feea35939deb1f6a3f&amp;scene=178&amp;cur_album_id=1345382825083895808#rd" target="_blank" rel="noopener noreferrer">一个比 Spring 更轻量级的 Web 框架！！！微软、红帽都在用</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247519972&amp;idx=1&amp;sn=f03c67e6e24eda2ccf703c8a9bc8c8f8&amp;chksm=cea1c12ff9d6483943f409e5ab50b773b5750b63d00950805fa340a67ad7b52ee74ff6651043&amp;scene=178&amp;cur_album_id=1345382825083895808#rd" target="_blank" rel="noopener noreferrer">轻量！Google 开源了一个简易版 Spring ！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247520633&amp;idx=1&amp;sn=aec35af40e3ed3b1e844addd04e31af5&amp;chksm=cea1deb2f9d657a46a0684bbcbcb2900cebff39a2b2746a4a809b6b5306bce08d4382efd5ca8&amp;scene=178&amp;cur_album_id=1345382825083895808#rd" target="_blank" rel="noopener noreferrer">一款跨时代的高性能 Java 框架！启动速度快到飞起</a></li>
<li><a href="https://mp.weixin.qq.com/s/kRgqHt73ZJGFQ2XmKG4PXw" target="_blank" rel="noopener noreferrer">Spring Boot+MyBatis Plus+JWT 问卷系统！开源！</a></li>
<li><a href="https://mp.weixin.qq.com/s/v3FUp-keswE2EhcTaLpSMQ" target="_blank" rel="noopener noreferrer">手写一个简化版的 Spring Cloud！</a></li>
<li><a href="https://mp.weixin.qq.com/s/CCzsX3Sn2Q3vhuBDEmRTlw" target="_blank" rel="noopener noreferrer">这个 SpringBoot+ Vue 开源博客系统太酷炫了！</a></li>
<li><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=Mzg2OTA0Njk0OA==&amp;action=getalbum&amp;album_id=1345382825083895808&amp;scene=173&amp;from_msgid=2247530323&amp;from_itemidx=1&amp;count=3&amp;nolastread=1#wechat_redirect" target="_blank" rel="noopener noreferrer">手写一个简易版数据库！项目经验稳了</a></li>
<li><a href="https://mp.weixin.qq.com/s/Ecjm801RpS34Mhj02bIOsQ" target="_blank" rel="noopener noreferrer">一款强大的快速开发脚手架，前后端分离，干掉 70% 重复工作！</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247530783&amp;idx=1&amp;sn=c9fdc0c71e2fc95d88ba954291b07e29&amp;chksm=cea136d4f9d6bfc2931a18a42f7bd9903503963e8a85a318adcce579614c0831b1881be3267d&amp;token=1811572747&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">手写一个入门级编译器！YYDS！</a></li>
</ol>
<p>推荐你在我的公众号“<strong>JavaGuide</strong>”回复“<strong>开源</strong>”在线阅读<a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=Mzg2OTA0Njk0OA==&amp;action=getalbum&amp;album_id=1345382825083895808&amp;scene=173&amp;from_msgid=2247516459&amp;from_itemidx=1&amp;count=3&amp;nolastread=1#wechat_redirect" target="_blank" rel="noopener noreferrer">「优质开源项目推荐」</a>系列。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/open-source-project/image-20220512211235432.png" alt="“JavaGuide”公众号回复“开源”"></p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/books167598cd2e17b8ec.png" alt="我的公众号"></p>
]]></content:encoded>
      <enclosure url="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/open-source-project/image-20220512211235432.png" type="image/png"/>
    </item>
    <item>
      <title>Java 优质开源系统设计项目</title>
      <link>https://javaguide.cn/open-source-project/system-design.html</link>
      <guid>https://javaguide.cn/open-source-project/system-design.html</guid>
      <source url="https://javaguide.cn/rss.xml">Java 优质开源系统设计项目</source>
      <description>基础框架 Spring Boot ：Spring Boot 可以轻松创建独立的生产级基于 Spring 的应用程序,内置 web 服务器让你可以像运行普通 Java 程序一样运行项 目。另外，大部分 Spring Boot 项目只需要少量的配置即可，这有别于 Spring 的重配置。 Javalin ：一个轻量级的 Web 框架，同时支持 Java 和 Kotlin，被微软、红帽、Uber等公司使用。 Quarkus : 用于编写 Java 应用程序的云原生和容器优先的框架。 Guice ：Google 开源的一个轻量级依赖注入框架，相当于一个功能极简化的轻量级 Spring Boot。在某些情况下非常实用，就比如说我们的项目只需要使用依赖注入，不需要 AOP 等功能特性。 SOFABoot ：SOFABoot 基于 Spring Boot ，不过在其基础上增加了 Readiness Check，类隔离，日志空间隔离等等能力。 配套提供的还有：SOFARPC（RPC 框架）、SOFABolt（基于 Netty 的远程通信框架）、SOFARegistry（注册中心）...详情请参考：SOFAStack 。 Spring Batch : Spring Batch 是一个轻量级但功能又十分全面的批处理框架，主要用于批处理场景比如从数据库、文件或队列中读取大量记录。不过，需要注意的是：Spring Batch 不是调度框架。商业和开源领域都有许多优秀的企业调度框架比如 Quartz、XXL-JOB、Elastic-Job。它旨在与调度程序一起工作，而不是取代调度程序。更多介绍请参考 Spring Batch 官方文档，入门教程可以参考 Spring Batch 从入门到实战。</description>
      <category>开源项目</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 基础框架</h2>
<ul>
<li><strong><a href="https://github.com/spring-projects/spring-boot" title="spring-boot" target="_blank" rel="noopener noreferrer">Spring Boot </a></strong> ：Spring Boot 可以轻松创建独立的生产级基于 Spring 的应用程序,内置 web 服务器让你可以像运行普通 Java 程序一样运行项 目。另外，大部分 Spring Boot 项目只需要少量的配置即可，这有别于 Spring 的重配置。</li>
<li><strong><a href="https://github.com/tipsy/javalin" target="_blank" rel="noopener noreferrer">Javalin</a></strong> ：一个轻量级的 Web 框架，同时支持 Java 和 Kotlin，被微软、红帽、Uber等公司使用。</li>
<li><strong><a href="https://github.com/quarkusio/quarkus" target="_blank" rel="noopener noreferrer">Quarkus</a></strong> : 用于编写 Java 应用程序的云原生和容器优先的框架。</li>
<li><strong><a href="https://github.com/google/guice" target="_blank" rel="noopener noreferrer">Guice</a></strong> ：Google 开源的一个轻量级依赖注入框架，相当于一个功能极简化的轻量级 Spring Boot。在某些情况下非常实用，就比如说我们的项目只需要使用依赖注入，不需要 AOP 等功能特性。</li>
<li><strong><a href="https://github.com/sofastack/sofa-boot" target="_blank" rel="noopener noreferrer">SOFABoot</a></strong> ：SOFABoot 基于 Spring Boot ，不过在其基础上增加了 Readiness Check，类隔离，日志空间隔离等等能力。 配套提供的还有：SOFARPC（RPC 框架）、SOFABolt（基于 Netty 的远程通信框架）、SOFARegistry（注册中心）...详情请参考：<a href="https://github.com/sofastack" target="_blank" rel="noopener noreferrer">SOFAStack </a> 。</li>
<li><a href="https://github.com/spring-projects/spring-batch" target="_blank" rel="noopener noreferrer"><strong>Spring Batch</strong></a> : Spring Batch 是一个轻量级但功能又十分全面的批处理框架，主要用于批处理场景比如从数据库、文件或队列中读取大量记录。不过，需要注意的是：<strong>Spring Batch 不是调度框架</strong>。商业和开源领域都有许多优秀的企业调度框架比如 Quartz、XXL-JOB、Elastic-Job。它旨在与调度程序一起工作，而不是取代调度程序。更多介绍请参考 <a href="https://docs.spring.io/spring-batch/docs/4.3.x/reference/html/spring-batch-intro.html#spring-batch-intro" target="_blank" rel="noopener noreferrer">Spring Batch 官方文档</a>，入门教程可以参考 <a href="https://mrbird.cc/Spring-Batch%E5%85%A5%E9%97%A8.html" target="_blank" rel="noopener noreferrer">Spring Batch 从入门到实战</a>。</li>
</ul>
<h2> 数据库</h2>
<h3> 数据库连接池</h3>
<ul>
<li><strong><a href="https://github.com/alibaba/druid" target="_blank" rel="noopener noreferrer">Druid</a></strong> : 阿里巴巴数据库事业部出品，为监控而生的数据库连接池。</li>
<li><strong><a href="https://github.com/brettwooldridge/HikariCP" target="_blank" rel="noopener noreferrer">HikariCP</a></strong> : 一个可靠的高性能 JDBC 连接池。Springboot 2.0 选择 HikariCP 作为默认数据库连接池。</li>
</ul>
<h3> 数据库框架</h3>
<ul>
<li><strong><a href="https://github.com/baomidou/mybatis-plus" target="_blank" rel="noopener noreferrer">MyBatis-Plus</a></strong> : <a href="https://github.com/baomidou/mybatis-plus" target="_blank" rel="noopener noreferrer">MyBatis-Plus</a>（简称 MP）是一个 <a href="http://www.mybatis.org/mybatis-3/" target="_blank" rel="noopener noreferrer">MyBatis</a> 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。</li>
<li><strong><a href="https://github.com/redisson/redisson" title="redisson" target="_blank" rel="noopener noreferrer">Redisson</a></strong> ： Redis 基础上的一个 Java 驻内存数据网格（In-Memory Data Grid）,支持超过 30 个对象和服务:<code>Set</code>,<code>SortedSet</code>, <code>Map</code>, <code>List</code>, <code>Queue</code>, <code>Deque</code> ......，并且提供了多种分布式锁的实现。更多介绍请看：<a href="https://github.com/redisson/redisson/wiki/Redisson%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D" title="Redisson项目介绍" target="_blank" rel="noopener noreferrer">《Redisson 项目介绍》</a>。</li>
</ul>
<h3> 数据同步</h3>
<ul>
<li><strong><a href="https://github.com/alibaba/canal" title="canal" target="_blank" rel="noopener noreferrer">Canal</a></strong> [kə'næl] : Canal 译意为水道/管道/沟渠，主要用途是基于 MySQL 数据库增量日志解析，提供增量数据订阅和消费。</li>
<li><strong><a href="https://github.com/alibaba/DataX" title="DataX" target="_blank" rel="noopener noreferrer">DataX</a></strong> ：DataX 是阿里巴巴集团内被广泛使用的离线数据同步工具/平台，实现包括 MySQL、Oracle、SqlServer、Postgre、HDFS、Hive、ADS、HBase、TableStore(OTS)、MaxCompute(ODPS)、DRDS 等各种异构数据源之间高效的数据同步功能。相关项目：<strong><a href="https://github.com/WeiYe-Jing/datax-web" target="_blank" rel="noopener noreferrer">DataX-Web</a></strong> （DataX 集成可视化页面，选择数据源即可一键生成数据同步任务）。</li>
</ul>
<p>其他：<strong><a href="https://github.com/DTStack/flinkx" target="_blank" rel="noopener noreferrer">Flinkx</a></strong> （基于 Flink 的分布式数据同步工具）。</p>
<h3> 时序数据库</h3>
<ul>
<li><strong><a href="https://github.com/apache/iotdb" target="_blank" rel="noopener noreferrer">IoTDB</a></strong> ：一款 Java 语言编写的国产时序数据库，为用户提供数据收集、存储和分析等服务。与 Hadoop、Spark 和可视化工具(如 Grafana)无缝集成，满足了工业 IoT 领域中海量数据存储、高吞吐量数据写入和复杂数据查询分析的需求。</li>
<li><strong><a href="https://github.com/kairosdb/kairosdb" target="_blank" rel="noopener noreferrer">KairosDB</a></strong> ：一个基于 Cassandra 的快速分布式可扩展时间序列数据库。</li>
</ul>
<h2> 搜索引擎</h2>
<ul>
<li><strong><a href="https://github.com/elastic/elasticsearch" title="elasticsearch" target="_blank" rel="noopener noreferrer">Elasticsearch</a></strong> （推荐）：开源，分布式，RESTful 搜索引擎。</li>
<li><strong><a href="https://lucene.apache.org/solr/" target="_blank" rel="noopener noreferrer">Solr</a></strong> : Solr（读作“solar”）是 Apache Lucene 项目的开源企业搜索平台。</li>
</ul>
<h2> 认证授权</h2>
<ul>
<li><strong><a href="https://github.com/Wechat-Group/WxJava" target="_blank" rel="noopener noreferrer">WxJava</a></strong> : WxJava （微信开发 Java SDK），支持包括微信支付、开放平台、小程序、企业微信/企业号和公众号等的后端开发。</li>
<li><strong><a href="https://github.com/dromara/sa-token" target="_blank" rel="noopener noreferrer">Sa-Token</a></strong> ：轻量级 Java 权限认证框架。支持认证授权、单点登录、踢人下线、自动续签等功能。</li>
<li><strong><a href="https://github.com/justauth/JustAuth" target="_blank" rel="noopener noreferrer">JustAuth</a></strong> ：小而全而美的第三方登录开源组件。目前已经集成了诸如：Github、Gitee、支付宝、新浪微博、微信、Google、Facebook、Twitter、StackOverflow 等国内外数十家第三方平台。</li>
</ul>
<h2> 网络通讯</h2>
<ul>
<li><strong><a href="https://github.com/netty/netty" target="_blank" rel="noopener noreferrer">Netty</a></strong> : 一个基于 NIO 的 client-server(客户端服务器)框架，使用它可以快速简单地开发网络应用程序。</li>
<li><strong><a href="https://github.com/square/retrofit" target="_blank" rel="noopener noreferrer">Retrofit</a></strong> ：适用于 Android 和 Java 的类型安全的 HTTP 客户端。Retrofit 的 HTTP 请求使用的是 <a href="https://square.github.io/okhttp/" target="_blank" rel="noopener noreferrer">OkHttp</a> 库（一款被广泛使用网络框架）。</li>
<li><strong><a href="https://gitee.com/dromara/forest" target="_blank" rel="noopener noreferrer">Forest</a></strong> ：轻量级 HTTP 客户端 API 框架，让 Java 发送 HTTP/HTTPS 请求不再难。它比 OkHttp 和 HttpClient 更高层，是封装调用第三方 restful api client 接口的好帮手，是 retrofit 和 feign 之外另一个选择。</li>
<li><strong><a href="https://github.com/YeautyYE/netty-websocket-spring-boot-starter" target="_blank" rel="noopener noreferrer">netty-websocket-spring-boot-starter</a></strong> :帮助你在 Spring Boot 中使用 Netty 来开发 WebSocket 服务器，并像 spring-websocket 的注解开发一样简单。</li>
</ul>
<h2> 测试</h2>
<p>为了能让我们编写的系统更加健壮，必要的测试（UI 测试、单元测试...）是必须的。</p>
<h3> 测试框架</h3>
<ul>
<li><strong><a href="http://junit.org/" target="_blank" rel="noopener noreferrer">JUnit</a></strong> : Java 测试框架。</li>
<li><strong><a href="https://github.com/mockito/mockito" target="_blank" rel="noopener noreferrer">Mockito</a></strong> ：Mockito 是一个模拟测试框架，可以让你用优雅，简洁的接口写出漂亮的单元测试。（对那些不容易构建的对象用一个虚拟对象来代替，使其在调试期间用来作为真实对象的替代品）</li>
<li><strong><a href="https://github.com/powermock/powermock" target="_blank" rel="noopener noreferrer">PowerMock</a></strong> ： 编写单元测试仅靠 Mockito 是不够。因为 Mockito 无法 mock 私有方法、final 方法及静态方法等。PowerMock 这个 framework，主要是为了扩展其他 mock 框架，如 Mockito、EasyMock。它使用一个自定义的类加载器，纂改字节码，突破 Mockito 无法 mock 静态方法、构造方法、final 类、final 方法以及私有方法的限制。</li>
<li><strong><a href="https://github.com/tomakehurst/wiremock" target="_blank" rel="noopener noreferrer">WireMock</a></strong> ：模拟 HTTP 服务的工具（Mock your APIs）。</li>
<li><strong><a href="https://github.com/testcontainers/testcontainers-java" target="_blank" rel="noopener noreferrer">Testcontainers</a></strong> ：一个支持 JUnit 的测试工具库，提供轻量级的且一次性的常见数据库测试支持、Selenium Web 浏览器或者其他任何可以在 Docker 容器中运行的实例支持。</li>
</ul>
<p>相关阅读：</p>
<ul>
<li><a href="https://martinfowler.com/articles/practical-test-pyramid.html" target="_blank" rel="noopener noreferrer">The Practical Test Pyramid- Martin Fowler</a> (很赞的一篇文章，不过是英文的)</li>
<li><a href="https://juejin.im/post/6844903982058618894" target="_blank" rel="noopener noreferrer">浅谈测试之 PowerMock</a></li>
</ul>
<h3> 测试平台</h3>
<ul>
<li><strong><a href="https://github.com/metersphere/metersphere" target="_blank" rel="noopener noreferrer">MeterSphere</a></strong> : 一站式开源持续测试平台，涵盖测试跟踪、接口测试、性能测试、团队协作等功能，全面兼容 JMeter、Postman、Swagger 等开源、主流标准。</li>
<li><strong><a href="https://www.apifox.cn/" target="_blank" rel="noopener noreferrer">Apifox</a></strong> ：API 文档、API 调试、API Mock、API 自动化测试。</li>
</ul>
<h3> API 调试</h3>
<ul>
<li><strong><a href="https://insomnia.rest/" target="_blank" rel="noopener noreferrer">Insomnia</a></strong> :像人类而不是机器人一样调试 API。我平时经常用的，界面美观且轻量，总之很喜欢。</li>
<li><strong><a href="https://www.getpostman.com/" target="_blank" rel="noopener noreferrer">Postman</a></strong> ：API 请求生成器。</li>
<li><strong><a href="https://github.com/liyasthomas/postwoman" title="postwoman" target="_blank" rel="noopener noreferrer">Postwoman</a></strong> ：API 请求生成器-一个免费、快速、漂亮的 Postma 替代品。</li>
</ul>
<h2> 任务调度</h2>
<ul>
<li><strong><a href="https://github.com/quartz-scheduler/quartz" target="_blank" rel="noopener noreferrer">Quartz</a></strong> ：一个很火的开源任务调度框架，Java 定时任务领域的老大哥或者说参考标准， 很多其他任务调度框架都是基于 <code>quartz</code> 开发的，比如当当网的<code>elastic-job</code>就是基于<code>quartz</code>二次开发之后的分布式调度解决方案</li>
<li><strong><a href="https://github.com/xuxueli/xxl-job" target="_blank" rel="noopener noreferrer">XXL-JOB</a></strong> :XXL-JOB 是一个分布式任务调度平台，其核心设计目标是开发迅速、学习简单、轻量级、易扩展。现已开放源代码并接入多家公司线上产品线，开箱即用。</li>
<li><strong><a href="http://elasticjob.io/index_zh.html" target="_blank" rel="noopener noreferrer">Elastic-Job</a></strong> ：Elastic-Job 是当当网开源的一个基于 Quartz 和 Zookeeper 的分布式调度解决方案，由两个相互独立的子项目 Elastic-Job-Lite 和 Elastic-Job-Cloud 组成，一般我们只要使用 Elastic-Job-Lite 就好。</li>
<li><strong><a href="https://github.com/analysys/EasyScheduler" title="EasyScheduler" target="_blank" rel="noopener noreferrer">EasyScheduler</a></strong> （已经更名为 DolphinScheduler，已经成为 Apache 孵化器项目）： Easy Scheduler 是一个分布式工作流任务调度系统，主要解决“复杂任务依赖但无法直接监控任务健康状态”的问题。Easy Scheduler 以 DAG 方式组装任务，可以实时监控任务的运行状态。同时，它支持重试，重新运行等操作... 。</li>
<li><strong><a href="https://gitee.com/KFCFans/PowerJob" target="_blank" rel="noopener noreferrer">PowerJob</a></strong> ：新一代分布式任务调度与计算框架，支持 CRON、API、固定频率、固定延迟等调度策略，提供工作流来编排任务解决依赖关系，使用简单，功能强大，文档齐全，欢迎各位接入使用！http://www.powerjob.tech/ 。</li>
<li><strong><a href="https://github.com/apache/dolphinscheduler" target="_blank" rel="noopener noreferrer">DolphinScheduler</a></strong> ：分布式易扩展的可视化工作流任务调度平台。</li>
</ul>
<p>相关阅读：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/jqN4noo5NazckPCehWFgpA" target="_blank" rel="noopener noreferrer">Spring Job、Quartz、XXL-Job 对比+全解析</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247518215&amp;idx=1&amp;sn=91e467f39322d2e7979b85fe235822d2&amp;chksm=cea1c7ccf9d64edaf966c95923d72d337bf5e655a773a3d295d65fc92e4535ae5d8b0e6d9d86&amp;token=2063686030&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">推荐 5 个 YYDS 的 Java 项目</a></li>
</ul>
<h2> 分布式</h2>
<h3> API 网关</h3>
<p>微服务下一个系统被拆分为多个服务，但是像 安全认证，流量控制，日志，监控等功能是每个服务都需要的，没有网关的话，我们就需要在每个服务中单独实现，这使得我们做了很多重复的事情并且没有一个全局的视图来统一管理这些功能。</p>
<p>综上：<strong>一般情况下，网关一般都会提供请求转发、安全认证（身份/权限认证）、流量控制、负载均衡、容灾、日志、监控这些功能。</strong></p>
<p>上面介绍了这么多功能实际上网关主要做了一件事情：<strong>请求过滤</strong> 。权限校验、流量控制这些都可以通过过滤器实现，请求转也是通过过滤器实现的。</p>
<ol>
<li><strong><a href="https://github.com/Kong/kong" title="kong" target="_blank" rel="noopener noreferrer">Kong</a></strong> ：Kong 是一个云原生、快速的、可伸缩的分布式微服务抽象层(也称为 API 网关、API 中间件或在某些情况下称为服务网格)。2015 年作为开源项目发布，其核心价值是高性能和可扩展性。</li>
<li><strong><a href="https://github.com/Dromara/soul" title="soul" target="_blank" rel="noopener noreferrer">Soul</a></strong> ：高性能、基于 webflux 的反应式 Java API 网关</li>
<li><strong><a href="https://github.com/spring-cloud/spring-cloud-gateway" target="_blank" rel="noopener noreferrer">Spring Cloud Gateway</a></strong> : 基于 Spring Framework 5.x 和 Spring Boot 2.x 构建的高性能网关。</li>
<li><strong><a href="https://github.com/Netflix/zuul" target="_blank" rel="noopener noreferrer">Zuul</a></strong> : Zuul 是一个 L7 应用程序网关，它提供了动态路由，监视，弹性，安全性等功能。</li>
</ol>
<h3> 配置中心</h3>
<ul>
<li><strong><a href="https://github.com/ctripcorp/apollo" title="apollo" target="_blank" rel="noopener noreferrer">Apollo</a></strong>（推荐） ：Apollo（阿波罗）是携程框架部门研发的分布式配置中心，能够集中化管理应用不同环境、不同集群的配置，配置修改后能够实时推送到应用端，并且具备规范的权限、流程治理等特性，适用于微服务配置管理场景。</li>
<li><strong><a href="https://github.com/alibaba/nacos" target="_blank" rel="noopener noreferrer">Nacos</a></strong>（推荐）：Nacos 是 Spring Cloud Alibaba 提供的服务注册发现组件，类似于 Consul、Eureka。并且，提供了分布式配置管理功能。</li>
<li><strong><a href="https://github.com/spring-cloud/spring-cloud-config" target="_blank" rel="noopener noreferrer">Spring Cloud Config</a></strong> ： Spring Cloud Config 是 Spring Cloud 家族中最早的配置中心，虽然后来又发布了 Consul 可以代替配置中心功能，但是 Config 依然适用于 Spring Cloud 项目，通过简单的配置即可实现功能。</li>
<li><strong><a href="https://github.com/hashicorp/consul" target="_blank" rel="noopener noreferrer">Consul</a></strong> ：Consul 是 HashiCorp 公司推出的开源软件，提供了微服务系统中的服务治理、配置中心、控制总线等功能。这些功能中的每一个都可以根据需要单独使用，也可以一起使用以构建全方位的服务网格，总之 Consul 提供了一种完整的服务网格解决方案。</li>
</ul>
<h3> 链路追踪</h3>
<p>目前分布式链路追踪系统基本都是根据谷歌的《Dapper 大规模分布式系统的跟踪系统》这篇论文发展而来，主流的有 Pinpoint，Skywalking ，CAT（当然也有其他的例如 Zipkin，Jaeger 等产品，不过总体来说不如前面选取的 3 个完成度高）等。</p>
<ol>
<li><strong><a href="https://github.com/apache/skywalking" title="skywalking" target="_blank" rel="noopener noreferrer">Skywalking</a></strong> : 针对分布式系统的应用性能监控，尤其是针对微服务、云原生和面向容器的分布式系统架构。</li>
<li><strong><a href="https://github.com/openzipkin/zipkin" title="zipkin" target="_blank" rel="noopener noreferrer">Zipkin</a></strong> ：Zipkin 是一个分布式跟踪系统。它有助于收集解决服务体系结构中的延迟问题所需的时序数据。功能包括该数据的收集和查找。</li>
<li><strong><a href="https://github.com/dianping/cat" title="cat" target="_blank" rel="noopener noreferrer">CAT</a></strong> ： CAT 作为服务端项目基础组件，提供了 Java, C/C++, Node.js, Python, Go 等多语言客户端，已经在美团点评的基础架构中间件框架（MVC 框架，RPC 框架，数据库框架，缓存框架等，消息队列，配置系统等）深度集成，为美团点评各业务线提供系统丰富的性能指标、健康状况、实时告警等。</li>
</ol>
<p>相关阅读： <a href="https://skywalking.apache.org/zh/blog/2019-03-29-introduction-of-skywalking-and-simple-practice.html" target="_blank" rel="noopener noreferrer">Skywalking 官网对于主流开源链路追踪系统的对比</a></p>
<h2> 高性能</h2>
<h3> 消息队列</h3>
<p><strong>分布式队列</strong> ：</p>
<ol>
<li><strong><a href="https://github.com/apache/rocketmq" title="RocketMQ" target="_blank" rel="noopener noreferrer">RocketMQ</a></strong> ：阿里巴巴开源的一款高性能、高吞吐量的分布式消息中间件。</li>
<li><strong><a href="https://github.com/apache/kafka" title="Kafaka" target="_blank" rel="noopener noreferrer">Kafaka</a></strong>: Kafka 是一种分布式的，基于发布 / 订阅的消息系统。关于它的入门可以查看：<a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/system-design/data-communication/Kafka%E5%85%A5%E9%97%A8%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86.md" title="Kafka入门看这一篇就够了" target="_blank" rel="noopener noreferrer">Kafka 入门看这一篇就够了</a></li>
<li><strong><a href="https://github.com/rabbitmq" title="RabbitMQ" target="_blank" rel="noopener noreferrer">RabbitMQ</a></strong> :由 erlang 开发的基于 AMQP（Advanced Message Queue 高级消息队列协议）协议实现的消息队列。</li>
</ol>
<p><strong>内存队列</strong> ：</p>
<p><strong><a href="https://github.com/LMAX-Exchange/disruptor" target="_blank" rel="noopener noreferrer">Disruptor</a></strong> ： Disruptor 是英国外汇交易公司 LMAX 开发的一个高性能队列，研发的初衷是解决内存队列的延迟问题（在性能测试中发现竟然与 I/O 操作处于同样的数量级）。相关阅读 ：<a href="https://tech.meituan.com/2016/11/18/disruptor.html" target="_blank" rel="noopener noreferrer">《高性能内存队列——Disruptor》</a> 。</p>
<p><strong>管理工具</strong> ：</p>
<ol>
<li><strong><a href="https://github.com/obsidiandynamics/kafdrop" target="_blank" rel="noopener noreferrer">Kafdrop</a></strong> : 一个用于查看 Kafka 主题和浏览消费者组的 Web UI。</li>
<li><strong><a href="https://github.com/smartloli/EFAK" target="_blank" rel="noopener noreferrer">EFAK</a></strong> （Eagle For Apache Kafka，以前叫做 Kafka Eagle） ：一个简单的高性能监控系统，用于对 Kafka 集群进行全面的监控和管理。</li>
</ol>
<h3> 数据库中间件</h3>
<ul>
<li><strong><a href="https://github.com/apache/shardingsphere" target="_blank" rel="noopener noreferrer">ShardingSphere</a></strong> ：ShardingSphere 是一套开源的分布式数据库中间件解决方案组成的生态圈，它由 Sharding-JDBC、Sharding-Proxy 和 Sharding-Sidecar（计划中）这 3 款相互独立的产品组成。 他们均提供标准化的数据分片、分布式事务和数据库治理功能，可适用于如 Java 同构、异构语言、云原生等各种多样化的应用场景。中文文档：<a href="https://shardingsphere.apache.org/document/current/cn/overview/" target="_blank" rel="noopener noreferrer">https://shardingsphere.apache.org/document/current/cn/overview/</a> 。</li>
<li><strong><a href="https://github.com/MyCatApache/MyCat2" target="_blank" rel="noopener noreferrer">MyCat</a></strong> : MyCat 是数据库分库分表的中间件，MyCat 使用最多的两个功能是：读写分离和分库分表。MyCat 是一些社区爱好者在阿里 Cobar 的基础上进行二次开发，解决了 Cobar 当时存 在的一些问题，并且加入了许多新的功能在其中。</li>
<li><strong><a href="https://github.com/baomidou/dynamic-datasource-spring-boot-starter" target="_blank" rel="noopener noreferrer">dynamic-datasource-spring-boot-starter</a></strong> ：dynamic-datasource-spring-boot-starter 是一个基于 springboot 的快速集成多数据源的启动器。如果说你有配置多数据源、读写分离等需求的话，可以了解一下这个项目。</li>
</ul>
<p>相关阅读：<a href="https://zhuanlan.zhihu.com/p/87144535" target="_blank" rel="noopener noreferrer">数据库中间件详解（精品长文）</a></p>
<h3> 线程池</h3>
<ul>
<li><strong><a href="https://github.com/opengoofy/hippo4j" target="_blank" rel="noopener noreferrer">Hippo-4J</a></strong> ：一款强大的动态线程池框架，解决了传统线程池使用存在的一些痛点比如线程池参数没办法动态修改、不支持运行时变量的传递、无法执行优雅关闭。除了支持动态修改线程池参数、线程池任务传递上下文，还支持通知报警、运行监控等开箱即用的功能。</li>
<li><strong><a href="https://github.com/dromara/dynamic-tp" target="_blank" rel="noopener noreferrer">Dynamic Tp</a></strong> ：一款基于 SpringBoot 的轻量级动态线程池，参考<a href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html" target="_blank" rel="noopener noreferrer">美团线程池实践</a>，内置监控告警功能，提供多种报警维度。</li>
</ul>
<h3> 缓存</h3>
<ul>
<li><strong><a href="https://github.com/ben-manes/caffeine" target="_blank" rel="noopener noreferrer">Caffeine</a></strong> : 一款强大的本地缓存解决方案，性能非常 🐂。</li>
<li><strong><a href="https://github.com/redis/redis" target="_blank" rel="noopener noreferrer">Redis</a></strong> ：一个使用 C 语言开发的内存数据库，分布式缓存首选。</li>
</ul>
<h2> 高可用</h2>
<h3> 限流</h3>
<p><strong>分布式限流</strong> ：</p>
<ul>
<li><strong><a href="https://github.com/alibaba/Sentinel" target="_blank" rel="noopener noreferrer"> Sentinel</a></strong>（推荐）：面向分布式服务架构的高可用防护组件，主要以流量为切入点，从流量控制、熔断降级、系统自适应保护等多个维度来帮助用户保障微服务的稳定性。</li>
<li><strong><a href="https://github.com/Netflix/Hystrix" target="_blank" rel="noopener noreferrer">Hystrix</a></strong> ：类似于 Sentinel 。</li>
</ul>
<p>相关阅读：<a href="https://sentinelguard.io/zh-cn/blog/sentinel-vs-hystrix.html" target="_blank" rel="noopener noreferrer">Sentinel 与 Hystrix 的对比</a></p>
<p><strong>单机限流</strong> ：</p>
<ul>
<li><strong><a href="https://github.com/vladimir-bukhtoyarov/bucket4j" target="_blank" rel="noopener noreferrer">Bucket4j</a></strong> ：一个非常不错的基于令牌/漏桶算法的限流库。</li>
<li><strong><a href="https://github.com/resilience4j/resilience4j" target="_blank" rel="noopener noreferrer">Resilience4j</a></strong> ：一个轻量级的容错组件，其灵感来自于 Hystrix。</li>
</ul>
<h3> 监控</h3>
<ul>
<li><strong><a href="https://github.com/codecentric/spring-boot-admin" target="_blank" rel="noopener noreferrer">Spring Boot Admin</a></strong> ：管理和监控 Spring Boot 应用程序。</li>
<li><strong><a href="https://github.com/dropwizard/metrics" target="_blank" rel="noopener noreferrer">Metrics</a></strong> ：捕获<strong>JVM</strong>和应用程序级别的指标。所以你知道发生了什么事。</li>
</ul>
<h3> 日志</h3>
<ul>
<li><strong>EKL 老三件套</strong> : 最原始的时候，ELK 是由 3 个开源项目的首字母构成，分别是 <strong>E</strong>lasticsearch 、<strong>L</strong>ogstash、<strong>K</strong>ibana。</li>
<li><strong>新一代 ELK 架构</strong> : Elasticsearch+Logstash+Kibana+Beats。</li>
<li><strong>EFK</strong> : EFK 中的 F 代表的是 <a href="https://github.com/fluent/fluentd" target="_blank" rel="noopener noreferrer">Fluentd</a>。</li>
<li><strong><a href="https://gitee.com/dromara/TLog" target="_blank" rel="noopener noreferrer">TLog</a></strong> ：一个轻量级的分布式日志标记追踪神器，10 分钟即可接入，自动对日志打标签完成微服务的链路追踪。</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Java 优质开源工具类库</title>
      <link>https://javaguide.cn/open-source-project/tool-library.html</link>
      <guid>https://javaguide.cn/open-source-project/tool-library.html</guid>
      <source url="https://javaguide.cn/rss.xml">Java 优质开源工具类库</source>
      <description>代码质量 lombok :使用 Lombok 我们可以简化我们的 Java 代码，比如使用它之后我们通过注释就可以实现 getter/setter、equals 等方法。 guava ：Guava 是一组核心库，其中包括新的集合类型（例如 multimap 和 multiset），不可变集合，图形库以及用于并发、I / O、哈希、原始类型、字符串等的实用程序！ p3c ：Alibaba Java Coding Guidelines pmd implements and IDE plugin。Eclipse 和 IDEA 上都有该插件，推荐使用！ arthas ： Arthas 是 Alibaba 开源的 Java 诊断工具。 sonarqube ：SonarQube 支持所有开发人员编写更干净，更安全的代码。 checkstyle :Checkstyle 是一种开发工具，可帮助程序员编写符合编码标准的 Java 代码。它使检查 Java 代码的过程自动化，从而使人们不必执行这项无聊（但很重要）的任务。这使其成为想要实施编码标准的项目的理想选择。 pmd : 可扩展的多语言静态代码分析器。 spotbugs :SpotBugs 是 FindBugs 的继任者。静态分析工具，用于查找 Java 代码中的错误。 hutool : Hutool 是一个 Java 工具包，也只是一个工具包，它帮助我们简化每一行代码，减少每一个方法，让 Java 语言也可以“甜甜的”。</description>
      <category>开源项目</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 代码质量</h2>
<ul>
<li><strong><a href="https://github.com/rzwitserloot/lombok" target="_blank" rel="noopener noreferrer">lombok</a></strong> :使用 Lombok 我们可以简化我们的 Java 代码，比如使用它之后我们通过注释就可以实现 getter/setter、equals 等方法。</li>
<li><strong><a href="https://github.com/google/guava" title="guava" target="_blank" rel="noopener noreferrer">guava</a></strong> ：Guava 是一组核心库，其中包括新的集合类型（例如 multimap 和 multiset），不可变集合，图形库以及用于并发、I / O、哈希、原始类型、字符串等的实用程序！</li>
<li><strong><a href="https://github.com/alibaba/p3c" title="p3c" target="_blank" rel="noopener noreferrer">p3c</a></strong> ：Alibaba Java Coding Guidelines pmd implements and IDE plugin。Eclipse 和 IDEA 上都有该插件，推荐使用！</li>
<li><strong><a href="https://github.com/alibaba/arthas" title="arthas" target="_blank" rel="noopener noreferrer">arthas</a></strong> ： Arthas 是 Alibaba 开源的 Java 诊断工具。</li>
<li><strong><a href="https://github.com/SonarSource/sonarqube" title="sonarqube" target="_blank" rel="noopener noreferrer">sonarqube</a></strong> ：SonarQube 支持所有开发人员编写更干净，更安全的代码。</li>
<li><strong><a href="https://github.com/checkstyle/checkstyle" title="checkstyle" target="_blank" rel="noopener noreferrer">checkstyle</a></strong> :Checkstyle 是一种开发工具，可帮助程序员编写符合编码标准的 Java 代码。它使检查 Java 代码的过程自动化，从而使人们不必执行这项无聊（但很重要）的任务。这使其成为想要实施编码标准的项目的理想选择。</li>
<li><strong><a href="https://github.com/pmd/pmd" title="pmd" target="_blank" rel="noopener noreferrer">pmd</a></strong> : 可扩展的多语言静态代码分析器。</li>
<li><strong><a href="https://github.com/spotbugs/spotbugs" title="spotbugs" target="_blank" rel="noopener noreferrer">spotbugs</a></strong> :SpotBugs 是 FindBugs 的继任者。静态分析工具，用于查找 Java 代码中的错误。</li>
<li><strong><a href="https://github.com/looly/hutool" title="hutool" target="_blank" rel="noopener noreferrer">hutool</a></strong> : Hutool 是一个 Java 工具包，也只是一个工具包，它帮助我们简化每一行代码，减少每一个方法，让 Java 语言也可以“甜甜的”。</li>
</ul>
<h2> 文档处理</h2>
<h3> Excel</h3>
<ul>
<li><strong><a href="https://github.com/alibaba/easyexcel" target="_blank" rel="noopener noreferrer">easyexcel</a></strong> :快速、简单避免 OOM 的 java 处理 Excel 工具。</li>
</ul>
<h3> JSON</h3>
<ul>
<li><strong><a href="https://github.com/json-path/JsonPath" target="_blank" rel="noopener noreferrer">JsonPath</a></strong> ：处理 JSON 数据的工具库。</li>
</ul>
<h3> PDF</h3>
<ul>
<li><strong><a href="https://github.com/apache/pdfbox" target="_blank" rel="noopener noreferrer">pdfbox</a></strong> :用于处理 PDF 文档的开放源码 Java 工具。该项目允许创建新的 PDF 文档、对现有文档进行操作以及从文档中提取内容。PDFBox 还包括几个命令行实用程序。PDFBox 是在 Apache 2.0 版许可下发布的。</li>
<li><strong><a href="https://github.com/LibrePDF/OpenPDF" target="_blank" rel="noopener noreferrer">OpenPDF</a></strong> ：OpenPDF 是一个免费的 Java 库，用于使用 LGPL 和 MPL 开源许可创建和编辑 PDF 文件。OpenPDF 基于 iText 的一个分支。</li>
<li><strong><a href="https://github.com/itext/itext7" target="_blank" rel="noopener noreferrer">itext7</a></strong> ：iText 7 代表了想要利用利用好 PDF 的开发人员的更高级别的 sdk。iText 7 配备了更好的文档引擎、高级和低级编程功能以及创建、编辑和增强 PDF 文档的能力，几乎对每个工作流都有好处。</li>
<li><strong><a href="https://xmlgraphics.apache.org/fop/" target="_blank" rel="noopener noreferrer">FOP</a></strong> :Apache FOP 项目的主要的输出目标是 PDF。</li>
</ul>
<h2> 验证码</h2>
<ul>
<li><strong><a href="https://gitee.com/whvse/EasyCaptcha" target="_blank" rel="noopener noreferrer">EasyCaptcha</a></strong> ：Java 图形验证码，支持 gif、中文、算术等类型，可用于 Java Web、JavaSE 等项目。</li>
<li><strong><a href="https://gitee.com/anji-plus/captcha" target="_blank" rel="noopener noreferrer">AJ-Captcha</a></strong> ：行为验证码(滑动拼图、点选文字)，前后端(java)交互。</li>
<li><strong><a href="https://gitee.com/tianai/tianai-captcha" target="_blank" rel="noopener noreferrer">tianai-captcha</a></strong> ：好看又好用的滑块验证码。</li>
</ul>
<h2> 在线支付</h2>
<ul>
<li><strong><a href="https://gitee.com/jeequan/jeepay" target="_blank" rel="noopener noreferrer">jeepay</a></strong> ：一套适合互联网企业使用的开源支付系统，已实现交易、退款、转账、分账等接口，支持服务商特约商户和普通商户接口。已对接微信，支付宝，云闪付官方接口，支持聚合码支付。</li>
<li><strong><a href="https://gitee.com/YunGouOS/YunGouOS-PAY-SDK" target="_blank" rel="noopener noreferrer">YunGouOS-PAY-SDK</a></strong> ：YunGouOS 微信支付接口、微信官方个人支付接口、非二维码收款，非第四方清算。个人用户可提交资料开通微信支付商户，完成对接。</li>
<li><strong><a href="https://gitee.com/javen205/IJPay" target="_blank" rel="noopener noreferrer">IJPay</a></strong> ：聚合支付，IJPay 让支付触手可及，封装了微信支付、QQ 支付、支付宝支付、京东支付、银联支付、PayPal 支付等常用的支付方式以及各种常用的接口。</li>
</ul>
<h2> 其他</h2>
<ul>
<li><strong><a href="https://github.com/oshi/oshi" title="oshi" target="_blank" rel="noopener noreferrer">oshi</a></strong> ：一款为 Java 语言提供的基于 JNA 的（本机）操作系统和硬件信息库。</li>
<li><strong><a href="https://github.com/lionsoul2014/ip2region" target="_blank" rel="noopener noreferrer">ip2region</a></strong> :最自由的 ip 地址查询库，ip 到地区的映射库，提供 Binary,B 树和纯内存三种查询算法，妈妈再也不用担心我的 ip 地址定位。</li>
<li><strong><a href="https://github.com/real-logic/agrona" target="_blank" rel="noopener noreferrer">agrona</a></strong> ：Java 高性能数据结构（<code>Buffers</code>、<code>Lists</code>、<code>Maps</code>、<code>Scalable Timer Wheel</code>......）和实用方法。</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Java 优质开源开发工具</title>
      <link>https://javaguide.cn/open-source-project/tools.html</link>
      <guid>https://javaguide.cn/open-source-project/tools.html</guid>
      <source url="https://javaguide.cn/rss.xml">Java 优质开源开发工具</source>
      <description>Java JADX ：一款功能强大的反编译工具。 Recaf ： Java 字节码编辑器，基于 ASM（Java 字节码操作框架） 来修改字节码，可简化编辑已编译 Java 应用程序的过程。</description>
      <category>开源项目</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<h2> Java</h2>
<ul>
<li><strong><a href="https://github.com/skylot/jadx" target="_blank" rel="noopener noreferrer">JADX</a></strong> ：一款功能强大的反编译工具。</li>
<li><strong><a href="https://github.com/Col-E/Recaf" target="_blank" rel="noopener noreferrer">Recaf</a></strong> ： Java 字节码编辑器，基于 ASM（Java 字节码操作框架） 来修改字节码，可简化编辑已编译 Java 应用程序的过程。</li>
</ul>
<h2> 数据库</h2>
<h3> 数据库建模</h3>
<ul>
<li><strong><a href="https://gitee.com/robergroup/chiner" target="_blank" rel="noopener noreferrer">CHINER</a></strong> ：开源免费的国产数据库建模工具。目标是做一款丰富数据库生态，独立于具体数据库之外的，数据库关系模型设计平台。前生是 <a href="https://gitee.com/robergroup/pdman" target="_blank" rel="noopener noreferrer">PDMan</a>，定位为 PowerDesigner 的免费替代方案。</li>
</ul>
<p>开源的数据库建模工具比较少，以下是一些非开源的数据库建模工具（部分需要付费才能使用） :</p>
<ul>
<li><strong><a href="https://www.mysql.com/products/workbench/" target="_blank" rel="noopener noreferrer">MySQL Workbench</a></strong> : MySQL 官方为数据库架构师、开发人员和 DBA 提供的一个可视化工具。 MySQL Workbench 支持数据建模，SQL 开发以及服务器配置、用户管理、性能优化、数据库备份以及迁移等功能，支持 Windows、Linux 和 Mac OS X 平台。</li>
<li><strong><a href="https://www.navicat.com.cn/products/navicat-data-modeler" target="_blank" rel="noopener noreferrer">Navicat Data Modeler</a></strong> : 一款强大的和符合成本效益的数据库设计工具，它能帮助用户创建高质素的概念、逻辑和物理数据模型。让你可视化地设计数据库结构、执行逆向或正向工程程序、从 ODBC 数据源导入模型、生成复杂的 SQL/DDL 和打印模型到文件等。付费。</li>
<li><strong><a href="https://dbschema.com/" target="_blank" rel="noopener noreferrer">DbSchema</a></strong> : 一款功能强大的数据库设计和管理的可视化工具，支持几乎所有的关系型和 NoSQL 数据库。付费。</li>
<li><strong><a href="https://dbdiagram.io/home" target="_blank" rel="noopener noreferrer">dbdiagram.io</a></strong> : 是一款简单免费的在线 ER 图绘制工具，通过编写代码创建模型，专为开发人员和数据分析师而设计。它通过一个简单的自定义语言来生成数据模型，支持 MySQL、PostgreSQL、SQL Server 数据库 DDL 文件的正向工程和逆向工程、版本历史、在线共享、导出图片或者 PDF 等功能。dbdiagram.io 提供了免费版。</li>
</ul>
<h3> 数据库管理</h3>
<ul>
<li><strong><a href="https://github.com/beekeeper-studio/beekeeper-studio" target="_blank" rel="noopener noreferrer">Beekeeper Studio</a></strong> ：跨平台数据库管理工具，颜值高，支持 SQLite、MySQL、MariaDB、Postgres、CockroachDB、SQL Server、Amazon Redshift。</li>
<li><strong><a href="https://github.com/sequelpro/sequelpro" target="_blank" rel="noopener noreferrer">Sequel Pro</a></strong> ：适用于 macOS 的 MySQL/MariaDB 数据库管理工具。</li>
<li><strong><a href="https://github.com/dbeaver/dbeaver" target="_blank" rel="noopener noreferrer">DBeaver</a></strong> ：一个基于 Java 开发 ，并且支持几乎所有的数据库产品的开源数据库管理工具。DBeaver 社区版不光支持关系型数据库比如 MySQL、PostgreSQL、MariaDB、SQLite、Oracle、Db2、SQL Server，还比如 SQLite、H2 这些内嵌数据库。还支持常见的全文搜索引擎比如 Elasticsearch 和 Solr、大数据相关的工具比如 Hive 和 Spark。</li>
<li><strong><a href="https://gitee.com/dbkangaroo/kangaroo" target="_blank" rel="noopener noreferrer">Kangaroo</a></strong> ：袋鼠是一款为热门数据库系统打造的管理客户端(SQLite / MySQL / PostgreSQL / ...) ，支持建表、查询、模型、同步、导入导出等功能，支持 Windows / Mac / Linux 等操作系统，力求打造成好用、好玩、开发友好的 SQL 工具。</li>
<li><strong><a href="https://arctype.com/" target="_blank" rel="noopener noreferrer">Arctype</a></strong> ：一个桌面的数据库查询工具，可以连接各种数据库，在其中执行 SQL 语句，以可视化形式展示数据。</li>
<li><strong><a href="https://github.com/RenzHoly/Mongood" target="_blank" rel="noopener noreferrer">Mongood</a></strong> : MongoDB 图形化的管理工具。基于微软 Fluent UI，支持自动黑暗模式。</li>
</ul>
<h3> Redis</h3>
<ul>
<li><strong><a href="https://github.com/qishibo/AnotherRedisDesktopManager/blob/master/README.zh-CN.md" target="_blank" rel="noopener noreferrer">Another Redis Desktop Manager</a></strong> ：更快、更好、更稳定的 Redis 桌面(GUI)管理客户端。</li>
<li><strong><a href="https://github.com/ngbdf/redis-manager" target="_blank" rel="noopener noreferrer">Redis Manager</a></strong> ：Redis 一站式管理平台，支持集群（cluster、master-replica、sentinel）的监控、安装（除 sentinel）、管理、告警以及基本的数据操作功能。</li>
</ul>
<h2> Devops</h2>
<ul>
<li><strong><a href="https://github.com/portainer/portainer" target="_blank" rel="noopener noreferrer">Portainer</a></strong> ：可视化管理 Docker 和 Kubernetes。相关阅读：<a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247504221&amp;idx=1&amp;sn=85a3c69d64fba1b0d6d8485ab28ab4c4&amp;chksm=cea19e96f9d617802920d5769bafc824b3b80afdfb6166a00532f0caa3b6f5bdac930e4e89de&amp;token=693114125&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">《吊炸天的 Docker 图形化工具 Portainer，必须推荐给你！》</a>。</li>
</ul>
<h2> ZooKeeper</h2>
<ul>
<li><strong><a href="https://github.com/vran-dev/PrettyZoo" target="_blank" rel="noopener noreferrer">PrettyZoo</a></strong> ： 一个基于 Apache Curator 和 JavaFX 实现的 ZooKeeper 图形化管理客户端，颜值非常高，支持 Mac / Windows / Linux 。你可以使用 PrettyZoo 来实现对 ZooKeeper 的可视化增删改查。</li>
<li><strong><a href="https://zktools.readthedocs.io/en/latest/#installing" target="_blank" rel="noopener noreferrer">zktools</a></strong> ： 一个低延迟的 ZooKeeper 图形化管理客户端，颜值非常高，支持 Mac / Windows / Linux 。你可以使用 zktools 来实现对 ZooKeeper 的可视化增删改查。</li>
</ul>
<h2> Markdown</h2>
<ul>
<li><strong><a href="https://github.com/marktext/marktext" target="_blank" rel="noopener noreferrer">MarkText</a></strong> ：一个简单而优雅的开源 Markdown 编辑器，专注于速度和可用性。Linux、macOS 和 Windows 均适用。</li>
<li><strong><a href="https://www.typora.io/" target="_blank" rel="noopener noreferrer">Typora</a></strong> :我一直用的一款 Markdown 工具，直接文件夹视图和目录视图，支持 Markdown 格式直接导出成 PDF、HTML 等格式。</li>
<li><strong><a href="https://github.com/adam-p/markdown-here" target="_blank" rel="noopener noreferrer">Markdown Here</a></strong> ：使用 Markdown 语法发邮件，并且提供多种主题，快来拯救你的邮件格式吧！</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Java 优质开源技术教程</title>
      <link>https://javaguide.cn/open-source-project/tutorial.html</link>
      <guid>https://javaguide.cn/open-source-project/tutorial.html</guid>
      <source url="https://javaguide.cn/rss.xml">Java 优质开源技术教程</source>
      <description>Java JavaGuide :【Java 学习+面试指南】 一份涵盖大部分 Java 程序员所需要掌握的核心知识。 toBeBetterJavaer ：一份通俗易懂、风趣幽默的 Java 学习指南，内容涵盖 Java 基础、Java 集合框架、Java 并发编程、JVM、Java 企业级开发（Git、SSM、Spring Boot）等知识点。 interview-guide ：总结了后端面试八股文中的重点，希望能帮助各位准备互联网开发岗校招面试的同学。 advanced-java :互联网 Java 工程师进阶知识完全扫盲：涵盖高并发、分布式、高可用、微服务、海量数据处理等领域知识。 toBeTopJavaer ：Java 工程师成神之路 。 technology-talk : 汇总 java 生态圈常用技术框架、开源中间件，系统架构、数据库、大公司架构案例、常用三方类库、项目管理、线上问题排查、个人成长、思考等知识 JCSprout :处于萌芽阶段的 Java 核心知识库。 bestJavaer : 这是一个成为更好的 Java 程序员的系列教程。 java-design-patterns ： 用 Java 实现的设计模式。</description>
      <category>开源项目</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<h2> Java</h2>
<ul>
<li><strong><a href="https://github.com/Snailclimb/JavaGuide" title="JavaGuide" target="_blank" rel="noopener noreferrer">JavaGuide</a></strong> :【Java 学习+面试指南】 一份涵盖大部分 Java 程序员所需要掌握的核心知识。</li>
<li><strong><a href="https://github.com/itwanger/toBeBetterJavaer" target="_blank" rel="noopener noreferrer">toBeBetterJavaer</a></strong> ：一份通俗易懂、风趣幽默的 Java 学习指南，内容涵盖 Java 基础、Java 集合框架、Java 并发编程、JVM、Java 企业级开发（Git、SSM、Spring Boot）等知识点。</li>
<li><strong><a href="https://github.com/csguide-dabai/interview-guide" target="_blank" rel="noopener noreferrer">interview-guide</a></strong> ：总结了后端面试八股文中的重点，希望能帮助各位准备互联网开发岗校招面试的同学。</li>
<li><strong><a href="https://github.com/doocs/advanced-java" title="advanced-java" target="_blank" rel="noopener noreferrer">advanced-java</a></strong> :互联网 Java 工程师进阶知识完全扫盲：涵盖高并发、分布式、高可用、微服务、海量数据处理等领域知识。</li>
<li><strong><a href="https://github.com/hollischuang/toBeTopJavaer" title="toBeTopJavaer" target="_blank" rel="noopener noreferrer">toBeTopJavaer</a></strong> ：Java 工程师成神之路 。</li>
<li><strong><a href="https://github.com/aalansehaiyang/technology-talk" target="_blank" rel="noopener noreferrer">technology-talk</a></strong> : 汇总 java 生态圈常用技术框架、开源中间件，系统架构、数据库、大公司架构案例、常用三方类库、项目管理、线上问题排查、个人成长、思考等知识</li>
<li><strong><a href="https://github.com/crossoverJie/JCSprout" title="JCSprout" target="_blank" rel="noopener noreferrer">JCSprout</a></strong> :处于萌芽阶段的 Java 核心知识库。</li>
<li><strong><a href="https://github.com/crisxuan/bestJavaer" target="_blank" rel="noopener noreferrer">bestJavaer</a></strong> : 这是一个成为更好的 Java 程序员的系列教程。</li>
<li><strong><a href="https://github.com/iluwatar/java-design-patterns" title="java-design-patterns" target="_blank" rel="noopener noreferrer">java-design-patterns</a></strong> ： 用 Java 实现的设计模式。</li>
</ul>
<h2> 计算机基础</h2>
<ul>
<li><strong><a href="https://github.com/PKUFlyingPig/cs-self-learning" target="_blank" rel="noopener noreferrer">cs-self-learning </a></strong> ：计算机自学指南，汇总欧美众多名校高质量计算机课程。</li>
<li><strong><a href="https://github.com/CyC2018/CS-Notes" title="CS-Notes" target="_blank" rel="noopener noreferrer">CS-Notes</a></strong> ：技术面试必备基础知识、Leetcode 题解、后端面试、Java 面试、春招、秋招、操作系统、计算机网络、系统设计。</li>
<li><strong><a href="https://github.com/wolverinn/Waking-Up" target="_blank" rel="noopener noreferrer">Waking-Up</a></strong> ：计算机基础（计算机网络/操作系统/数据库/Git...）面试问题全面总结。</li>
</ul>
<h2> 系统设计</h2>
<h3> SpringBoot</h3>
<ul>
<li><strong><a href="https://github.com/Snailclimb/springboot-guide" target="_blank" rel="noopener noreferrer">springboot-guide</a></strong> ：SpringBoot 核心知识点总结。 基于 Spring Boot 2.19+。</li>
<li><strong><a href="https://github.com/wuyouzhuguli/SpringAll" title="SpringAll" target="_blank" rel="noopener noreferrer">SpringAll</a></strong> ：循序渐进，学习 Spring Boot、Spring Boot &amp; Shiro、Spring Cloud、Spring Security &amp; Spring Security OAuth2，博客 Spring 系列源码。</li>
<li><strong><a href="https://github.com/chengxy-nds/Springboot-Notebook" target="_blank" rel="noopener noreferrer">Springboot-Notebook</a></strong> :一系列以 Spring Boot 为基础开发框架，整合 Redis 、 Rabbitmq 、ES 、MongoDB 、Spring Cloud、Kafka、Skywalking 等互联网主流技术，实现各种常见功能点的综合性案例。</li>
<li><strong><a href="https://github.com/JeffLi1993/springboot-learning-example" title="springboot-learning-example" target="_blank" rel="noopener noreferrer">springboot-learning-example</a></strong> ：Spring Boot 实践学习案例，是 Spring Boot 初学者及核心技术巩固的最佳实践。</li>
<li><strong><a href="https://github.com/xkcoding/spring-boot-demo" title="spring-boot-demo" target="_blank" rel="noopener noreferrer">spring-boot-demo</a></strong> ：spring boot demo 是一个用来深度学习并实战 spring boot 的项目，目前总共包含 63 个集成 demo，已经完成 52 个。</li>
<li><strong><a href="https://github.com/YunaiV/SpringBoot-Labs" target="_blank" rel="noopener noreferrer">SpringBoot-Labs</a></strong> ：Spring Boot 系列教程。</li>
</ul>
<p>相关文章：<a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247488298&amp;idx=3&amp;sn=0a8fd88ec5a050de131c2a3305482ac4&amp;chksm=cea25ce1f9d5d5f7f53a0237d27489326bce4546353b038085c03b086d91ef396bf824d3a155&amp;token=496868067&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">Github 点赞接近 100k 的 SpringBoot 学习教程+实战推荐！牛批！</a></p>
<h3> SpringCloud</h3>
<ul>
<li><strong><a href="https://github.com/forezp/SpringCloudLearning" title="SpringCloudLearning" target="_blank" rel="noopener noreferrer">SpringCloudLearning</a></strong> : 方志朋的《史上最简单的 Spring Cloud 教程源码》。</li>
<li><strong><a href="https://github.com/macrozheng/springcloud-learning" target="_blank" rel="noopener noreferrer">springcloud-learning</a></strong> : 一套涵盖大部分核心组件使用的 Spring Cloud 教程。</li>
<li><strong><a href="https://github.com/zhoutaoo/SpringCloud" title="SpringCloud" target="_blank" rel="noopener noreferrer">SpringCloud</a></strong> ：基于 SpringCloud2.1 的微服务开发脚手架，整合了 spring-security-oauth2、nacos、feign、sentinel、springcloud-gateway 等。</li>
</ul>
<p>相关文章：<a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247488377&amp;idx=1&amp;sn=0fb33ef330159db5a9c8bc0f029cd739&amp;chksm=cea25cb2f9d5d5a4c7bacc9dcfc90ed86e89f4262e32b40c7aa47af84c747cb6c0429f753e1d&amp;token=496868067&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">Github 点赞接近 70k 的 Spring Cloud 学习教程+实战项目推荐！牛批！</a></p>
<h3> Nginx</h3>
<ul>
<li><strong><a href="https://github.com/dunwu/nginx-tutorial" target="_blank" rel="noopener noreferrer">nginx-tutorial</a></strong> ：一系列 Nginx 极简教程，包含HTTP 反向代理、HTTPS 反向代理、负载均衡、静态站点、文件服务器搭建等实战内容。</li>
</ul>
<h2> 大数据</h2>
<ul>
<li><strong><a href="https://github.com/heibaiying/BigData-Notes" title="BigData-Notes" target="_blank" rel="noopener noreferrer">BigData-Notes</a></strong> :大数据入门指南 ⭐️。</li>
<li><strong><a href="https://github.com/zhisheng17/flink-learning" title="flink-learning" target="_blank" rel="noopener noreferrer">flink-learning</a></strong> ：含 Flink 入门、概念、原理、实战、性能调优、源码解析等内容。</li>
</ul>
<h2> 开源书籍</h2>
<ul>
<li><strong><a href="https://github.com/clxering/Effective-Java-3rd-edition-Chinese-English-bilingual" target="_blank" rel="noopener noreferrer">《Effective Java（第 3 版）》中英对照版</a></strong> ：《Effective Java（第 3 版）各章节的中英文学习参考。</li>
<li><strong><a href="https://github.com/Vonng/ddia" target="_blank" rel="noopener noreferrer">《DDIA（设计数据密集型应用）》中文版</a></strong> ：《Designing Data-Intensive Application》DDIA 中文翻译。</li>
<li><strong><a href="https://github.com/fenixsoft/awesome-fenix" target="_blank" rel="noopener noreferrer">《凤凰架构》</a></strong> ：讨论如何构建一套可靠的大型分布式系统。</li>
<li><strong><a href="https://github.com/dreamhead/patterns-of-distributed-systems" target="_blank" rel="noopener noreferrer">《分布式系统模式》中文版</a></strong> ：《Patterns of Distributed Systems》中文翻译。</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>设计模式常见面试题总结</title>
      <link>https://javaguide.cn/system-design/design-pattern.html</link>
      <guid>https://javaguide.cn/system-design/design-pattern.html</guid>
      <source url="https://javaguide.cn/rss.xml">设计模式常见面试题总结</source>
      <description>设计模式 相关的面试题已经整理到了 PDF 手册中，你可以在我的公众号“JavaGuide”后台回复“PDF” 获取。 《设计模式》PDF 电子书内容概览 ：</description>
      <category>系统设计</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<p><strong>设计模式</strong> 相关的面试题已经整理到了 PDF 手册中，你可以在我的公众号“<strong>JavaGuide</strong>”后台回复“<strong>PDF</strong>” 获取。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/gongzhonghaoxuanchuan.png" alt="JavaGuide 官方公众号"></p>
<p><strong>《设计模式》PDF 电子书内容概览</strong> ：</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/system-design/design-pattern-pdf.png" alt="《设计模式》PDF文档概览"></p>
]]></content:encoded>
      <enclosure url="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/gongzhonghaoxuanchuan.png" type="image/png"/>
    </item>
    <item>
      <title></title>
      <link>https://javaguide.cn/system-design/J2EE%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html</link>
      <guid>https://javaguide.cn/system-design/J2EE%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html</guid>
      <source url="https://javaguide.cn/rss.xml"></source>
      <description>点击关注公众号及时获取笔主最新更新文章，并可免费领取本文档配套的《Java面试突击》以及Java工程师必备学习资源。 Servlet总结 阐述Servlet和CGI的区别? CGI的不足之处: Servlet的优点： Servlet接口中有哪些方法及Servlet生命周期探秘 get和post请求的区别 什么情况下调用doGet()和doPost() 转发（Forward）和重定向（Redirect）的区别 自动刷新(Refresh) Servlet与线程安全 JSP和Servlet是什么关系 JSP工作原理 JSP有哪些内置对象、作用分别是什么 Request对象的主要方法有哪些 request.getAttribute()和 request.getParameter()有何区别 include指令include的行为的区别 JSP九大内置对象，七大动作，三大指令 讲解JSP中的四种作用域 如何实现JSP或Servlet的单线程模式 实现会话跟踪的技术有哪些 Cookie和Session的的区别</description>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<p>点击关注<a href="#%E5%85%AC%E4%BC%97%E5%8F%B7">公众号</a>及时获取笔主最新更新文章，并可免费领取本文档配套的《Java面试突击》以及Java工程师必备学习资源。</p>
<!-- MarkdownTOC -->
<ul>
<li><a href="#servlet%E6%80%BB%E7%BB%93">Servlet总结</a></li>
<li><a href="#%E9%98%90%E8%BF%B0servlet%E5%92%8Ccgi%E7%9A%84%E5%8C%BA%E5%88%AB">阐述Servlet和CGI的区别?</a>
<ul>
<li><a href="#cgi%E7%9A%84%E4%B8%8D%E8%B6%B3%E4%B9%8B%E5%A4%84">CGI的不足之处:</a></li>
<li><a href="#servlet%E7%9A%84%E4%BC%98%E7%82%B9">Servlet的优点：</a></li>
</ul>
</li>
<li><a href="#servlet%E6%8E%A5%E5%8F%A3%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%E5%8F%8Aservlet%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%8E%A2%E7%A7%98">Servlet接口中有哪些方法及Servlet生命周期探秘</a></li>
<li><a href="#get%E5%92%8Cpost%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB">get和post请求的区别</a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E8%B0%83%E7%94%A8doget%E5%92%8Cdopost">什么情况下调用doGet()和doPost()</a></li>
<li><a href="#%E8%BD%AC%E5%8F%91forward%E5%92%8C%E9%87%8D%E5%AE%9A%E5%90%91redirect%E7%9A%84%E5%8C%BA%E5%88%AB">转发（Forward）和重定向（Redirect）的区别</a></li>
<li><a href="#%E8%87%AA%E5%8A%A8%E5%88%B7%E6%96%B0refresh">自动刷新(Refresh)</a></li>
<li><a href="#servlet%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8">Servlet与线程安全</a></li>
<li><a href="#jsp%E5%92%8Cservlet%E6%98%AF%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB">JSP和Servlet是什么关系</a></li>
<li><a href="#jsp%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">JSP工作原理</a></li>
<li><a href="#jsp%E6%9C%89%E5%93%AA%E4%BA%9B%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E3%80%81%E4%BD%9C%E7%94%A8%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88">JSP有哪些内置对象、作用分别是什么</a></li>
<li><a href="#request%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%BB%E8%A6%81%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B">Request对象的主要方法有哪些</a></li>
<li><a href="#requestgetattribute%E5%92%8C-requestgetparameter%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB">request.getAttribute()和 request.getParameter()有何区别</a></li>
<li><a href="#include%E6%8C%87%E4%BB%A4include%E7%9A%84%E8%A1%8C%E4%B8%BA%E7%9A%84%E5%8C%BA%E5%88%AB">include指令include的行为的区别</a></li>
<li><a href="#jsp%E4%B9%9D%E5%A4%A7%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%EF%BC%8C%E4%B8%83%E5%A4%A7%E5%8A%A8%E4%BD%9C%EF%BC%8C%E4%B8%89%E5%A4%A7%E6%8C%87%E4%BB%A4">JSP九大内置对象，七大动作，三大指令</a></li>
<li><a href="#%E8%AE%B2%E8%A7%A3jsp%E4%B8%AD%E7%9A%84%E5%9B%9B%E7%A7%8D%E4%BD%9C%E7%94%A8%E5%9F%9F">讲解JSP中的四种作用域</a></li>
<li><a href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0jsp%E6%88%96servlet%E7%9A%84%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%BC%8F">如何实现JSP或Servlet的单线程模式</a></li>
<li><a href="#%E5%AE%9E%E7%8E%B0%E4%BC%9A%E8%AF%9D%E8%B7%9F%E8%B8%AA%E7%9A%84%E6%8A%80%E6%9C%AF%E6%9C%89%E5%93%AA%E4%BA%9B">实现会话跟踪的技术有哪些</a></li>
<li><a href="#cookie%E5%92%8Csession%E7%9A%84%E7%9A%84%E5%8C%BA%E5%88%AB">Cookie和Session的的区别</a></li>
</ul>
<!-- /MarkdownTOC -->
<h2> Servlet总结</h2>
<p>在Java Web程序中，<strong>Servlet</strong>主要负责接收用户请求 <code>HttpServletRequest</code>,在<code>doGet()</code>,<code>doPost()</code>中做相应的处理，并将回应<code>HttpServletResponse</code>反馈给用户。<strong>Servlet</strong> 可以设置初始化参数，供Servlet内部使用。一个Servlet类只会有一个实例，在它初始化时调用<code>init()</code>方法，销毁时调用<code>destroy()</code>方法**。**Servlet需要在web.xml中配置（MyEclipse中创建Servlet会自动配置），<strong>一个Servlet可以设置多个URL访问</strong>。<strong>Servlet不是线程安全</strong>，因此要谨慎使用类变量。</p>
<h2> 阐述Servlet和CGI的区别?</h2>
<h3> CGI的不足之处:</h3>
<p>1，需要为每个请求启动一个操作CGI程序的系统进程。如果请求频繁，这将会带来很大的开销。</p>
<p>2，需要为每个请求加载和运行一个CGI程序，这将带来很大的开销</p>
<p>3，需要重复编写处理网络协议的代码以及编码，这些工作都是非常耗时的。</p>
<h3> Servlet的优点:</h3>
<p>1，只需要启动一个操作系统进程以及加载一个JVM，大大降低了系统的开销</p>
<p>2，如果多个请求需要做同样处理的时候，这时候只需要加载一个类，这也大大降低了开销</p>
<p>3，所有动态加载的类可以实现对网络协议以及请求解码的共享，大大降低了工作量。</p>
<p>4，Servlet能直接和Web服务器交互，而普通的CGI程序不能。Servlet还能在各个程序之间共享数据，使数据库连接池之类的功能很容易实现。</p>
<p>补充：Sun Microsystems公司在1996年发布Servlet技术就是为了和CGI进行竞争，Servlet是一个特殊的Java程序，一个基于Java的Web应用通常包含一个或多个Servlet类。Servlet不能够自行创建并执行，它是在Servlet容器中运行的，容器将用户的请求传递给Servlet程序，并将Servlet的响应回传给用户。通常一个Servlet会关联一个或多个JSP页面。以前CGI经常因为性能开销上的问题被诟病，然而Fast CGI早就已经解决了CGI效率上的问题，所以面试的时候大可不必信口开河的诟病CGI，事实上有很多你熟悉的网站都使用了CGI技术。</p>
<p>参考：《javaweb整合开发王者归来》P7</p>
<h2> Servlet接口中有哪些方法及Servlet生命周期探秘</h2>
<p>Servlet接口定义了5个方法，其中<strong>前三个方法与Servlet生命周期相关</strong>：</p>
<ul>
<li><code>void init(ServletConfig config) throws ServletException</code></li>
<li><code>void service(ServletRequest req, ServletResponse resp) throws ServletException, java.io.IOException</code></li>
<li><code>void destroy()</code></li>
<li><code>java.lang.String getServletInfo()</code></li>
<li><code>ServletConfig getServletConfig()</code></li>
</ul>
<p><strong>生命周期：</strong> <strong>Web容器加载Servlet并将其实例化后，Servlet生命周期开始</strong>，容器运行其<strong>init()方法</strong>进行Servlet的初始化；请求到达时调用Servlet的<strong>service()方法</strong>，service()方法会根据需要调用与请求对应的<strong>doGet或doPost</strong>等方法；当服务器关闭或项目被卸载时服务器会将Servlet实例销毁，此时会调用Servlet的<strong>destroy()方法</strong>。<strong>init方法和destroy方法只会执行一次，service方法客户端每次请求Servlet都会执行</strong>。Servlet中有时会用到一些需要初始化与销毁的资源，因此可以把初始化资源的代码放入init方法中，销毁资源的代码放入destroy方法中，这样就不需要每次处理客户端的请求都要初始化与销毁资源。</p>
<p>参考：《javaweb整合开发王者归来》P81</p>
<h2> get和post请求的区别</h2>
<p>get和post请求实际上是没有区别，大家可以自行查询相关文章（参考文章：<a href="https://www.cnblogs.com/logsharing/p/8448446.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/logsharing/p/8448446.html</a>，知乎对应的问题链接：<a href="https://www.zhihu.com/question/28586791" target="_blank" rel="noopener noreferrer">get和post区别？</a>）！</p>
<p>可以把 get 和 post 当作两个不同的行为，两者并没有什么本质区别，底层都是 TCP 连接。 get请求用来从服务器上获得资源，而post是用来向服务器提交数据。比如你要获取人员列表可以用 get 请求，你需要创建一个人员可以用 post 。这也是 Restful  API 最基本的一个要求。</p>
<p>推荐阅读：</p>
<ul>
<li>https://www.zhihu.com/question/28586791</li>
<li>https://mp.weixin.qq.com/s?__biz=MzI3NzIzMzg3Mw==&amp;mid=100000054&amp;idx=1&amp;sn=71f6c214f3833d9ca20b9f7dcd9d33e4#rd</li>
</ul>
<h2> 什么情况下调用doGet()和doPost()</h2>
<p>Form标签里的method的属性为get时调用doGet()，为post时调用doPost()。</p>
<h2> 转发(Forward)和重定向(Redirect)的区别</h2>
<p><strong>转发是服务器行为，重定向是客户端行为。</strong></p>
<p><strong>转发（Forward）</strong>
通过RequestDispatcher对象的forward（HttpServletRequest request,HttpServletResponse response）方法实现的。RequestDispatcher可以通过HttpServletRequest 的getRequestDispatcher()方法获得。例如下面的代码就是跳转到login_success.jsp页面。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>重定向（Redirect）</strong>  是利用服务器返回的状态码来实现的。客户端浏览器请求服务器的时候，服务器会返回一个状态码。服务器通过 <code>HttpServletResponse</code> 的 <code>setStatus(int status)</code> 方法设置状态码。如果服务器返回301或者302，则浏览器会到新的网址重新请求该资源。</p>
<ol>
<li><strong>从地址栏显示来说</strong></li>
</ol>
<p>forward是服务器请求资源,服务器直接访问目标地址的URL,把那个URL的响应内容读取过来,然后把这些内容再发给浏览器.浏览器根本不知道服务器发送的内容从哪里来的,所以它的地址栏还是原来的地址.
redirect是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址.所以地址栏显示的是新的URL.</p>
<ol start="2">
<li><strong>从数据共享来说</strong></li>
</ol>
<p>forward:转发页面和转发到的页面可以共享request里面的数据.
redirect:不能共享数据.</p>
<ol start="3">
<li><strong>从运用地方来说</strong></li>
</ol>
<p>forward:一般用于用户登陆的时候,根据角色转发到相应的模块.
redirect:一般用于用户注销登陆时返回主页面和跳转到其它的网站等</p>
<ol start="4">
<li>从效率来说</li>
</ol>
<p>forward:高.
redirect:低.</p>
<h2> 自动刷新(Refresh)</h2>
<p>自动刷新不仅可以实现一段时间之后自动跳转到另一个页面，还可以实现一段时间之后自动刷新本页面。Servlet中通过HttpServletResponse对象设置Header属性实现自动刷新例如：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>其中5为时间，单位为秒。URL指定就是要跳转的页面（如果设置自己的路径，就会实现每过5秒自动刷新本页面一次）</p>
<h2> Servlet与线程安全</h2>
<p><strong>Servlet不是线程安全的，多线程并发的读写会导致数据不同步的问题。</strong> 解决的办法是尽量不要定义name属性，而是要把name变量分别定义在doGet()和doPost()方法内。虽然使用synchronized(name){}语句块可以解决问题，但是会造成线程的等待，不是很科学的办法。
注意：多线程的并发的读写Servlet类属性会导致数据不同步。但是如果只是并发地读取属性而不写入，则不存在数据不同步的问题。因此Servlet里的只读属性最好定义为final类型的。</p>
<p>参考：《javaweb整合开发王者归来》P92</p>
<h2> JSP和Servlet是什么关系</h2>
<p>其实这个问题在上面已经阐述过了，Servlet是一个特殊的Java程序，它运行于服务器的JVM中，能够依靠服务器的支持向浏览器提供显示内容。JSP本质上是Servlet的一种简易形式，JSP会被服务器处理成一个类似于Servlet的Java程序，可以简化页面内容的生成。Servlet和JSP最主要的不同点在于，Servlet的应用逻辑是在Java文件中，并且完全从表示层中的HTML分离开来。而JSP的情况是Java和HTML可以组合成一个扩展名为.jsp的文件。有人说，Servlet就是在Java中写HTML，而JSP就是在HTML中写Java代码，当然这个说法是很片面且不够准确的。JSP侧重于视图，Servlet更侧重于控制逻辑，在MVC架构模式中，JSP适合充当视图（view）而Servlet适合充当控制器（controller）。</p>
<h2> JSP工作原理</h2>
<p>JSP是一种Servlet，但是与HttpServlet的工作方式不太一样。HttpServlet是先由源代码编译为class文件后部署到服务器下，为先编译后部署。而JSP则是先部署后编译。JSP会在客户端第一次请求JSP文件时被编译为HttpJspPage类（接口Servlet的一个子类）。该类会被服务器临时存放在服务器工作目录里面。下面通过实例给大家介绍。
工程JspLoginDemo下有一个名为login.jsp的Jsp文件，把工程第一次部署到服务器上后访问这个Jsp文件，我们发现这个目录下多了下图这两个东东。
.class文件便是JSP对应的Servlet。编译完毕后再运行class文件来响应客户端请求。以后客户端访问login.jsp的时候，Tomcat将不再重新编译JSP文件，而是直接调用class文件来响应客户端请求。
<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/1.png" alt="JSP工作原理">
由于JSP只会在客户端第一次请求的时候被编译 ，因此第一次请求JSP时会感觉比较慢，之后就会感觉快很多。如果把服务器保存的class文件删除，服务器也会重新编译JSP。</p>
<p>开发Web程序时经常需要修改JSP。Tomcat能够自动检测到JSP程序的改动。如果检测到JSP源代码发生了改动。Tomcat会在下次客户端请求JSP时重新编译JSP，而不需要重启Tomcat。这种自动检测功能是默认开启的，检测改动会消耗少量的时间，在部署Web应用的时候可以在web.xml中将它关掉。</p>
<p>参考：《javaweb整合开发王者归来》P97</p>
<h2> JSP有哪些内置对象、作用分别是什么</h2>
<p><a href="http://blog.csdn.net/qq_34337272/article/details/64310849" target="_blank" rel="noopener noreferrer">JSP内置对象 - CSDN博客 </a></p>
<p>JSP有9个内置对象：</p>
<ul>
<li>request：封装客户端的请求，其中包含来自GET或POST请求的参数；</li>
<li>response：封装服务器对客户端的响应；</li>
<li>pageContext：通过该对象可以获取其他对象；</li>
<li>session：封装用户会话的对象；</li>
<li>application：封装服务器运行环境的对象；</li>
<li>out：输出服务器响应的输出流对象；</li>
<li>config：Web应用的配置对象；</li>
<li>page：JSP页面本身（相当于Java程序中的this）；</li>
<li>exception：封装页面抛出异常的对象。</li>
</ul>
<h2> Request对象的主要方法有哪些</h2>
<ul>
<li>setAttribute(String name,Object)：设置名字为name的request 的参数值</li>
<li>getAttribute(String name)：返回由name指定的属性值</li>
<li>getAttributeNames()：返回request 对象所有属性的名字集合，结果是一个枚举的实例</li>
<li>getCookies()：返回客户端的所有 Cookie 对象，结果是一个Cookie 数组</li>
<li>getCharacterEncoding() ：返回请求中的字符编码方式 = getContentLength() ：返回请求的 Body的长度</li>
<li>getHeader(String name) ：获得HTTP协议定义的文件头信息</li>
<li>getHeaders(String name) ：返回指定名字的request Header 的所有值，结果是一个枚举的实例</li>
<li>getHeaderNames() ：返回所以request Header 的名字，结果是一个枚举的实例</li>
<li>getInputStream() ：返回请求的输入流，用于获得请求中的数据</li>
<li>getMethod() ：获得客户端向服务器端传送数据的方法</li>
<li>getParameter(String name) ：获得客户端传送给服务器端的有 name指定的参数值</li>
<li>getParameterNames() ：获得客户端传送给服务器端的所有参数的名字，结果是一个枚举的实例</li>
<li>getParameterValues(String name)：获得有name指定的参数的所有值</li>
<li>getProtocol()：获取客户端向服务器端传送数据所依据的协议名称</li>
<li>getQueryString() ：获得查询字符串</li>
<li>getRequestURI() ：获取发出请求字符串的客户端地址</li>
<li>getRemoteAddr()：获取客户端的 IP 地址</li>
<li>getRemoteHost() ：获取客户端的名字</li>
<li>getSession([Boolean create]) ：返回和请求相关 Session</li>
<li>getServerName() ：获取服务器的名字</li>
<li>getServletPath()：获取客户端所请求的脚本文件的路径</li>
<li>getServerPort()：获取服务器的端口号</li>
<li>removeAttribute(String name)：删除请求中的一个属性</li>
</ul>
<h2> request.getAttribute()和 request.getParameter()有何区别</h2>
<p><strong>从获取方向来看：</strong></p>
<p><code>getParameter()</code>是获取 POST/GET 传递的参数值；</p>
<p><code>getAttribute()</code>是获取对象容器中的数据值；</p>
<p><strong>从用途来看：</strong></p>
<p><code>getParameter()</code>用于客户端重定向时，即点击了链接或提交按扭时传值用，即用于在用表单或url重定向传值时接收数据用。</p>
<p><code>getAttribute()</code> 用于服务器端重定向时，即在 sevlet 中使用了 forward 函数,或 struts 中使用了
mapping.findForward。 getAttribute 只能收到程序用 setAttribute 传过来的值。</p>
<p>另外，可以用 <code>setAttribute()</code>,<code>getAttribute()</code> 发送接收对象.而 <code>getParameter()</code> 显然只能传字符串。
<code>setAttribute()</code> 是应用服务器把这个对象放在该页面所对应的一块内存中去，当你的页面服务器重定向到另一个页面时，应用服务器会把这块内存拷贝另一个页面所对应的内存中。这样<code>getAttribute()</code>就能取得你所设下的值，当然这种方法可以传对象。session也一样，只是对象在内存中的生命周期不一样而已。<code>getParameter()</code>只是应用服务器在分析你送上来的 request页面的文本时，取得你设在表单或 url 重定向时的值。</p>
<p><strong>总结：</strong></p>
<p><code>getParameter()</code>返回的是String,用于读取提交的表单中的值;（获取之后会根据实际需要转换为自己需要的相应类型，比如整型，日期类型啊等等）</p>
<p><code>getAttribute()</code>返回的是Object，需进行转换,可用<code>setAttribute()</code>设置成任意对象，使用很灵活，可随时用</p>
<h2> include指令include的行为的区别</h2>
<p><strong>include指令：</strong> JSP可以通过include指令来包含其他文件。被包含的文件可以是JSP文件、HTML文件或文本文件。包含的文件就好像是该JSP文件的一部分，会被同时编译执行。 语法格式如下：
&lt;%@ include file="文件相对 url 地址" %&gt;</p>
<p>i<strong>nclude动作：</strong> <code>&lt;jsp:include&gt;</code>动作元素用来包含静态和动态的文件。该动作把指定文件插入正在生成的页面。语法格式如下：
&lt;jsp:include page="相对 URL 地址" flush="true" /&gt;</p>
<h2> JSP九大内置对象，七大动作，三大指令</h2>
<p><a href="http://blog.csdn.net/qq_34337272/article/details/64310849" target="_blank" rel="noopener noreferrer">JSP九大内置对象，七大动作，三大指令总结</a></p>
<h2> 讲解JSP中的四种作用域</h2>
<p>JSP中的四种作用域包括page、request、session和application，具体来说：</p>
<ul>
<li><strong>page</strong>代表与一个页面相关的对象和属性。</li>
<li><strong>request</strong>代表与Web客户机发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，涉及多个Web组件；需要在页面显示的临时数据可以置于此作用域。</li>
<li><strong>session</strong>代表与某个用户与服务器建立的一次会话相关的对象和属性。跟某个用户相关的数据应该放在用户自己的session中。</li>
<li><strong>application</strong>代表与整个Web应用程序相关的对象和属性，它实质上是跨越整个Web应用程序，包括多个页面、请求和会话的一个全局作用域。</li>
</ul>
<h2> 如何实现JSP或Servlet的单线程模式</h2>
<p>对于JSP页面，可以通过page指令进行设置。
<code>&lt;%@page isThreadSafe="false"%&gt;</code></p>
<p>对于Servlet，可以让自定义的Servlet实现SingleThreadModel标识接口。</p>
<p>说明：如果将JSP或Servlet设置成单线程工作模式，会导致每个请求创建一个Servlet实例，这种实践将导致严重的性能问题（服务器的内存压力很大，还会导致频繁的垃圾回收），所以通常情况下并不会这么做。</p>
<h2> 实现会话跟踪的技术有哪些</h2>
<ol>
<li><strong>使用Cookie</strong></li>
</ol>
<p>向客户端发送Cookie</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从客户端读取Cookie</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>优点:</strong> 数据可以持久保存，不需要服务器资源，简单，基于文本的Key-Value</p>
<p><strong>缺点:</strong> 大小受到限制，用户可以禁用Cookie功能，由于保存在本地，有一定的安全风险。</p>
<ol start="2">
<li>URL 重写</li>
</ol>
<p>在URL中添加用户会话的信息作为请求的参数，或者将唯一的会话ID添加到URL结尾以标识一个会话。</p>
<p><strong>优点：</strong> 在Cookie被禁用的时候依然可以使用</p>
<p><strong>缺点：</strong> 必须对网站的URL进行编码，所有页面必须动态生成，不能用预先记录下来的URL进行访问。</p>
<p>3.隐藏的表单域</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>优点：</strong> Cookie被禁时可以使用</p>
<p><strong>缺点：</strong> 所有页面必须是表单提交之后的结果。</p>
<ol start="4">
<li>HttpSession</li>
</ol>
<p>在所有会话跟踪技术中，HttpSession对象是最强大也是功能最多的。当一个用户第一次访问某个网站时会自动创建 HttpSession，每个用户可以访问他自己的HttpSession。可以通过HttpServletRequest对象的getSession方 法获得HttpSession，通过HttpSession的setAttribute方法可以将一个值放在HttpSession中，通过调用 HttpSession对象的getAttribute方法，同时传入属性名就可以获取保存在HttpSession中的对象。与上面三种方式不同的 是，HttpSession放在服务器的内存中，因此不要将过大的对象放在里面，即使目前的Servlet容器可以在内存将满时将HttpSession 中的对象移到其他存储设备中，但是这样势必影响性能。添加到HttpSession中的值可以是任意Java对象，这个对象最好实现了 Serializable接口，这样Servlet容器在必要的时候可以将其序列化到文件中，否则在序列化时就会出现异常。</p>
<h2> Cookie和Session的区别</h2>
<p>Cookie 和 Session都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。</p>
<p><strong>Cookie 一般用来保存用户信息</strong> 比如①我们在 Cookie 中保存已经登录过得用户信息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了；②一般的网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了一个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可(为了安全考虑，重新登录一般要将 Token 重写)；③登录一次网站后访问网站其他页面不需要重新登录。<strong>Session 的主要作用就是通过服务端记录用户的状态。</strong> 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。</p>
<p>Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。</p>
<p>Cookie 存储在客户端中，而Session存储在服务器上，相对来说 Session 安全性更高。如果使用 Cookie 的一些敏感信息不要写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。</p>
<h2> 公众号</h2>
<p>如果大家想要实时关注我更新的文章以及分享的干货的话，可以关注我的公众号。</p>
<p><strong>《Java面试突击》:</strong> 由本文档衍生的专为面试而生的《Java面试突击》V2.0 PDF 版本<a href="#%E5%85%AC%E4%BC%97%E5%8F%B7">公众号</a>后台回复 <strong>"Java面试突击"</strong> 即可免费领取！</p>
<p><strong>Java工程师必备学习资源:</strong> 一些Java工程师常用学习资源公众号后台回复关键字 <strong>“1”</strong> 即可免费无套路获取。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/167598cd2e17b8ec.png" alt="我的公众号"></p>
]]></content:encoded>
      <enclosure url="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/1.png" type="image/png"/>
    </item>
    <item>
      <title>Java 定时任务详解</title>
      <link>https://javaguide.cn/system-design/schedule-task.html</link>
      <guid>https://javaguide.cn/system-design/schedule-task.html</guid>
      <source url="https://javaguide.cn/rss.xml">Java 定时任务详解</source>
      <description>为什么需要定时任务？ 我们来看一下几个非常常见的业务场景： 某系统凌晨要进行数据备份。 某电商平台，用户下单半个小时未支付的情况下需要自动取消订单。 某媒体聚合平台，每 10 分钟动态抓取某某网站的数据为自己所用。 某博客平台，支持定时发送文章。 某基金平台，每晚定时计算用户当日收益情况并推送给用户最新的数据。 ...... 这些场景往往都要求我们在某个特定的时间去做某个事情。 单机定时任务技术选型</description>
      <category>系统设计</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 为什么需要定时任务？</h2>
<p>我们来看一下几个非常常见的业务场景：</p>
<ol>
<li>某系统凌晨要进行数据备份。</li>
<li>某电商平台，用户下单半个小时未支付的情况下需要自动取消订单。</li>
<li>某媒体聚合平台，每 10 分钟动态抓取某某网站的数据为自己所用。</li>
<li>某博客平台，支持定时发送文章。</li>
<li>某基金平台，每晚定时计算用户当日收益情况并推送给用户最新的数据。</li>
<li>......</li>
</ol>
<p>这些场景往往都要求我们在某个特定的时间去做某个事情。</p>
<h2> 单机定时任务技术选型</h2>
<h3> Timer</h3>
<p><code>java.util.Timer</code>是 JDK 1.3 开始就已经支持的一种定时任务的实现方式。</p>
<p><code>Timer</code> 内部使用一个叫做 <code>TaskQueue</code> 的类存放定时任务，它是一个基于最小堆实现的优先级队列。<code>TaskQueue</code> 会按照任务距离下一次执行时间的大小将任务排序，保证在堆顶的任务最先执行。这样在需要执行任务时，每次只需要取出堆顶的任务运行即可！</p>
<p><code>Timer</code> 使用起来比较简单，通过下面的方式我们就能创建一个 1s 之后执行的定时任务。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>不过其缺陷较多，比如一个 <code>Timer</code> 一个线程，这就导致 <code>Timer</code> 的任务的执行只能串行执行，一个任务执行时间过长的话会影响其他任务（性能非常差），再比如发生异常时任务直接停止（<code>Timer</code> 只捕获了 <code>InterruptedException</code> ）。</p>
<p><code>Timer</code> 类上的有一段注释是这样写的：</p>
<div class="language-JAVA line-numbers-mode" data-ext="JAVA"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>大概的意思就是： <code>ScheduledThreadPoolExecutor</code> 支持多线程执行定时任务并且功能更强大，是 <code>Timer</code> 的替代品。</p>
<h3> ScheduledExecutorService</h3>
<p><code>ScheduledExecutorService</code> 是一个接口，有多个实现类，比较常用的是 <code>ScheduledThreadPoolExecutor</code> 。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/20210607154324712.png" alt=""></p>
<p><code>ScheduledThreadPoolExecutor</code> 本身就是一个线程池，支持任务并发执行。并且，其内部使用 <code>DelayQueue</code> 作为任务队列。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>不论是使用 <code>Timer</code> 还是 <code>ScheduledExecutorService</code> 都无法使用 Cron 表达式指定任务执行的具体时间。</p>
<h3> Spring Task</h3>
<p><img src="https://img-blog.csdnimg.cn/20210528145056880.png" alt=""></p>
<p>我们直接通过 Spring 提供的 <code>@Scheduled</code> 注解即可定义定时任务，非常方便！</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我在大学那会做的一个 SSM 的企业级项目，就是用的 Spring Task 来做的定时任务。</p>
<p>并且，Spring Task 还是支持 <strong>Cron 表达式</strong> 的。Cron 表达式主要用于定时作业(定时任务)系统定义执行时间或执行频率的表达式，非常厉害，你可以通过 Cron 表达式进行设置定时任务每天或者每个月什么时候执行等等操作。咱们要学习定时任务的话，Cron 表达式是一定是要重点关注的。推荐一个在线 Cron 表达式生成器：<a href="http://cron.qqe2.com/" target="_blank" rel="noopener noreferrer">http://cron.qqe2.com/</a> 。</p>
<p>但是，Spring 自带的定时调度只支持单机，并且提供的功能比较单一。之前写过一篇文章:<a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247485563&amp;idx=1&amp;sn=7419341f04036a10b141b74624a3f8c9&amp;chksm=cea247b0f9d5cea6440759e6d49b4e77d06f4c99470243a10c1463834e873ca90266413fbc92&amp;token=2133161636&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">《5 分钟搞懂如何在 Spring Boot 中 Schedule Tasks》</a> ，不了解的小伙伴可以参考一下。</p>
<p>Spring Task 底层是基于 JDK 的 <code>ScheduledThreadPoolExecutor</code> 线程池来实现的。</p>
<p><strong>优缺点总结：</strong></p>
<ul>
<li>优点： 简单，轻量，支持 Cron 表达式</li>
<li>缺点 ：功能单一</li>
</ul>
<h3> 时间轮</h3>
<p>Kafka、Dubbo、ZooKeeper、Netty 、Caffeine 、Akka 中都有对时间轮的实现。</p>
<p>时间轮简单来说就是一个环形的队列（底层一般基于数组实现），队列中的每一个元素（时间格）都可以存放一个定时任务列表。</p>
<p>时间轮中的每个时间格代表了时间轮的基本时间跨度或者说时间精度，加入时间一秒走一个时间格的话，那么这个时间轮的最高精度就是 1 秒（也就是说 3 s 和 3.9s 会在同一个时间格中）。</p>
<p>下图是一个有 12 个时间格的时间轮，转完一圈需要 12 s。当我们需要新建一个 3s 后执行的定时任务，只需要将定时任务放在下标为 3 的时间格中即可。当我们需要新建一个 9s 后执行的定时任务，只需要将定时任务放在下标为 9 的时间格中即可。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/20210607171334861.png" alt=""></p>
<p>那当我们需要创建一个 13s 后执行的定时任务怎么办呢？这个时候可以引入一叫做 <strong>圈数/轮数</strong> 的概念，也就是说这个任务还是放在下标为 3 的时间格中， 不过它的圈数为 2 。</p>
<p>除了增加圈数这种方法之外，还有一种 <strong>多层次时间轮</strong> （类似手表），Kafka 采用的就是这种方案。</p>
<p>针对下图的时间轮，我来举一个例子便于大家理解。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/20210607193042151.png" alt=""></p>
<p>上图的时间轮，第 1 层的时间精度为 1 ，第 2 层的时间精度为 20 ，第 3 层的时间精度为 400。假如我们需要添加一个 350s 后执行的任务 A 的话（当前时间是 0s），这个任务会被放在第 2 层（因为第二层的时间跨度为 20*20=400&gt;350）的第 350/20=17 个时间格子。</p>
<p>当第一层转了 17 圈之后，时间过去了 340s ，第 2 层的指针此时来到第 17 个时间格子。此时，第 2 层第 17 个格子的任务会被移动到第 1 层。</p>
<p>任务 A 当前是 10s 之后执行，因此它会被移动到第 1 层的第 10 个时间格子。</p>
<p>这里在层与层之间的移动也叫做时间轮的升降级。参考手表来理解就好！</p>
<p><img src="https://img-blog.csdnimg.cn/20210607195206797.png" alt=""></p>
<p><strong>时间轮比较适合任务数量比较多的定时任务场景，它的任务写入和执行的时间复杂度都是 0（1）。</strong></p>
<h2> 分布式定时任务技术选型</h2>
<p>上面提到的一些定时任务的解决方案都是在单机下执行的，适用于比较简单的定时任务场景比如每天凌晨备份一次数据。</p>
<p>如果我们需要一些高级特性比如支持任务在分布式场景下的分片和高可用的话，我们就需要用到分布式任务调度框架了。</p>
<p>通常情况下，一个定时任务的执行往往涉及到下面这些角色：</p>
<ul>
<li><strong>任务</strong> ： 首先肯定是要执行的任务，这个任务就是具体的业务逻辑比如定时发送文章。</li>
<li><strong>调度器</strong> ：其次是调度中心，调度中心主要负责任务管理，会分配任务给执行器。</li>
<li><strong>执行器</strong> ： 最后就是执行器，执行器接收调度器分派的任务并执行。</li>
</ul>
<h3> Quartz</h3>
<p><img src="https://img-blog.csdnimg.cn/2021052814502425.png" alt=""></p>
<p>一个很火的开源任务调度框架，完全由<code>Java</code>写成。<code>Quartz</code> 可以说是 Java 定时任务领域的老大哥或者说参考标准，其他的任务调度框架基本都是基于 <code>Quartz</code> 开发的，比如当当网的<code>elastic-job</code>就是基于<code>quartz</code>二次开发之后的分布式调度解决方案。</p>
<p>使用 <code>Quartz</code> 可以很方便地与 <code>Spring</code> 集成，并且支持动态添加任务和集群。但是，<code>Quartz</code> 使用起来也比较麻烦，API 繁琐。</p>
<p>并且，<code>Quzrtz</code> 并没有内置 UI 管理控制台，不过你可以使用 <a href="https://github.com/zhaopeiym/quartzui" target="_blank" rel="noopener noreferrer">quartzui</a> 这个开源项目来解决这个问题。</p>
<p>另外，<code>Quartz</code> 虽然也支持分布式任务。但是，它是在数据库层面，通过数据库的锁机制做的，有非常多的弊端比如系统侵入性严重、节点负载不均衡。有点伪分布式的味道。</p>
<p><strong>优缺点总结：</strong></p>
<ul>
<li>优点： 可以与 <code>Spring</code> 集成，并且支持动态添加任务和集群。</li>
<li>缺点 ：分布式支持不友好，没有内置 UI 管理控制台、使用麻烦（相比于其他同类型框架来说）</li>
</ul>
<h3> Elastic-Job</h3>
<p><img src="https://img-blog.csdnimg.cn/20210528144508114.png" alt=""></p>
<p><code>Elastic-Job</code> 是当当网开源的一个基于<code>Quartz</code>和<code>ZooKeeper</code>的分布式调度解决方案，由两个相互独立的子项目 <code>Elastic-Job-Lite</code> 和 <code>Elastic-Job-Cloud</code> 组成，一般我们只要使用 <code>Elastic-Job-Lite</code> 就好。</p>
<p><code>ElasticJob</code> 支持任务在分布式场景下的分片和高可用、任务可视化管理等功能。</p>
<p><img src="https://img-blog.csdnimg.cn/20210608080437356.png" alt=""></p>
<p>ElasticJob-Lite 的架构设计如下图所示：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-a8f63f828666d43009d5d3497bcbd2cfb61.png" alt=""></p>
<p>从上图可以看出，<code>Elastic-Job</code> 没有调度中心这一概念，而是使用 <code>ZooKeeper</code> 作为注册中心，注册中心负责协调分配任务到不同的节点上。</p>
<p>Elastic-Job 中的定时调度都是由执行器自行触发，这种设计也被称为去中心化设计（调度和处理都是执行器单独完成）。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>相关地址：</strong></p>
<ul>
<li>Github 地址：https://github.com/apache/shardingsphere-elasticjob。</li>
<li>官方网站：https://shardingsphere.apache.org/elasticjob/index_zh.html 。</li>
</ul>
<p><strong>优缺点总结：</strong></p>
<ul>
<li>优点 ：可以与 <code>Spring</code> 集成、支持分布式、支持集群、性能不错</li>
<li>缺点 ：依赖了额外的中间件比如 Zookeeper（复杂度增加，可靠性降低、维护成本变高）</li>
</ul>
<h3> XXL-JOB</h3>
<p><img src="https://img-blog.csdnimg.cn/20210528144611728.png" alt=""></p>
<p><code>XXL-JOB</code> 于 2015 年开源，是一款优秀的轻量级分布式任务调度框架，支持任务可视化管理、弹性扩容缩容、任务失败重试和告警、任务分片等功能，</p>
<p><img src="https://img-blog.csdnimg.cn/20210608080550433.png" alt=""></p>
<p>根据 <code>XXL-JOB</code> 官网介绍，其解决了很多 <code>Quartz</code> 的不足。</p>
<p><img src="https://img-blog.csdnimg.cn/20210607202503193.png" alt=""></p>
<p><code>XXL-JOB</code> 的架构设计如下图所示：</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-b8ecc6acf651f112c4dfae98243d72adea3.png" alt=""></p>
<p>从上图可以看出，<code>XXL-JOB</code> 由 <strong>调度中心</strong> 和 <strong>执行器</strong> 两大部分组成。调度中心主要负责任务管理、执行器管理以及日志管理。执行器主要是接收调度信号并处理。另外，调度中心进行任务调度时，是通过自研 RPC 来实现的。</p>
<p>不同于 <code>Elastic-Job</code> 的去中心化设计， <code>XXL-JOB</code> 的这种设计也被称为中心化设计（调度中心调度多个执行器执行任务）。</p>
<p>和 <code>Quzrtz</code> 类似 <code>XXL-JOB</code> 也是基于数据库锁调度任务，存在性能瓶颈。不过，一般在任务量不是特别大的情况下，没有什么影响的，可以满足绝大部分公司的要求。</p>
<p>不要被 <code>XXL-JOB</code> 的架构图给吓着了，实际上，我们要用 <code>XXL-JOB</code> 的话，只需要重写 <code>IJobHandler</code> 自定义任务执行逻辑就可以了，非常易用！</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>还可以直接基于注解定义任务。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://img-blog.csdnimg.cn/20210607200728212.png" alt=""></p>
<p><strong>相关地址：</strong></p>
<ul>
<li>Github 地址：https://github.com/xuxueli/xxl-job/。</li>
<li>官方介绍：https://www.xuxueli.com/xxl-job/ 。</li>
</ul>
<p><strong>优缺点总结：</strong></p>
<ul>
<li>优点：开箱即用（学习成本比较低）、与 Spring 集成、支持分布式、支持集群、内置了 UI 管理控制台。</li>
<li>缺点：不支持动态添加任务（如果一定想要动态创建任务也是支持的，参见：<a href="https://github.com/xuxueli/xxl-job/issues/277" target="_blank" rel="noopener noreferrer">xxl-job issue277</a>）。</li>
</ul>
<h3> PowerJob</h3>
<p><img src="https://img-blog.csdnimg.cn/20210528145009701.png" alt=""></p>
<p>非常值得关注的一个分布式任务调度框架，分布式任务调度领域的新星。目前，已经有很多公司接入比如 OPPO、京东、中通、思科。</p>
<p>这个框架的诞生也挺有意思的，PowerJob 的作者当时在阿里巴巴实习过，阿里巴巴那会使用的是内部自研的 SchedulerX（阿里云付费产品）。实习期满之后，PowerJob 的作者离开了阿里巴巴。想着说自研一个 SchedulerX，防止哪天 SchedulerX 满足不了需求，于是 PowerJob 就诞生了。</p>
<p>更多关于 PowerJob 的故事，小伙伴们可以去看看 PowerJob 作者的视频 <a href="https://www.bilibili.com/video/BV1SK411A7F3/" target="_blank" rel="noopener noreferrer">《我和我的任务调度中间件》</a>。简单点概括就是：“游戏没啥意思了，我要扛起了新一代分布式任务调度与计算框架的大旗！”。</p>
<p>由于 SchedulerX 属于人民币产品，我这里就不过多介绍。PowerJob 官方也对比过其和 QuartZ、XXL-JOB 以及 SchedulerX。</p>
<p><img src="https://oscimg.oschina.net/oscnet/up-795f5e9b0d875063717b1ee6a08f2ff1c01.png" alt=""></p>
<h2> 总结</h2>
<p>这篇文章中，我主要介绍了：</p>
<ul>
<li><strong>定时任务的相关概念</strong> ：为什么需要定时任务、定时任务中的核心角色、分布式定时任务。</li>
<li><strong>定时任务的技术选型</strong> ： XXL-JOB 2015 年推出，已经经过了很多年的考验。XXL-JOB 轻量级，并且使用起来非常简单。虽然存在性能瓶颈，但是，在绝大多数情况下，对于企业的基本需求来说是没有影响的。PowerJob 属于分布式任务调度领域里的新星，其稳定性还有待继续考察。ElasticJob 由于在架构设计上是基于 Zookeeper ，而 XXL-JOB 是基于数据库，性能方面的话，ElasticJob 略胜一筹。</li>
</ul>
<p>这篇文章并没有介绍到实际使用，但是，并不代表实际使用不重要。我在写这篇文章之前，已经动手写过相应的 Demo。像 Quartz，我在大学那会就用过。不过，当时用的是 Spring 。为了能够更好地体验，我自己又在 Spring Boot 上实际体验了一下。如果你并没有实际使用某个框架，就直接说它并不好用的话，是站不住脚的。</p>
<p>最后，这篇文章要感谢艿艿的帮助，写这篇文章的时候向艿艿询问过一些问题。推荐一篇艿艿写的偏实战类型的硬核文章：<a href="https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;mid=2247490679&amp;idx=1&amp;sn=25374dbdcca95311d41be5d7b7db454d&amp;chksm=fa4963c6cd3eead055bb9cd10cca13224bb35d0f7373a27aa22a55495f71e24b8273a7603314&amp;scene=27#wechat_redirect" target="_blank" rel="noopener noreferrer">《Spring Job？Quartz？XXL-Job？年轻人才做选择，艿艿全莽~》</a> 。</p>
]]></content:encoded>
      <enclosure url="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/20210607154324712.png" type="image/png"/>
    </item>
    <item>
      <title>系统设计常见面试题总结(付费)</title>
      <link>https://javaguide.cn/system-design/system-design-questions.html</link>
      <guid>https://javaguide.cn/system-design/system-design-questions.html</guid>
      <source url="https://javaguide.cn/rss.xml">系统设计常见面试题总结(付费)</source>
      <description>系统设计 相关的面试题为我的知识星球（点击链接即可查看详细介绍以及加入方法）专属内容，已经整理到了《Java 面试指北》（点击链接即可查看详细介绍以及获取方法）中。</description>
      <category>Java面试指北</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<p><strong>系统设计</strong> 相关的面试题为我的<a href="https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc" target="_blank" rel="noopener noreferrer">知识星球</a>（点击链接即可查看详细介绍以及加入方法）专属内容，已经整理到了<a href="https://www.yuque.com/docs/share/f37fc804-bfe6-4b0d-b373-9c462188fec7" target="_blank" rel="noopener noreferrer">《Java 面试指北》</a>（点击链接即可查看详细介绍以及获取方法）中。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javamianshizhibei/system-design-questions.png" alt=""></p>
<p><a href="https://www.yuque.com/docs/share/f37fc804-bfe6-4b0d-b373-9c462188fec7" target="_blank" rel="noopener noreferrer">《Java 面试指北》</a> 的部分内容展示如下，你可以将其看作是 <a href="https://javaguide.cn" target="_blank" rel="noopener noreferrer">JavaGuide</a> 的补充完善，两者可以配合使用。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220304102536445.png" alt=""></p>
<p><a href="https://www.yuque.com/docs/share/f37fc804-bfe6-4b0d-b373-9c462188fec7" target="_blank" rel="noopener noreferrer">《Java 面试指北》</a>只是星球内部众多资料中的一个，星球还有很多其他优质资料比如<a href="https://javaguide.cn/zhuanlan/" target="_blank" rel="noopener noreferrer">专属专栏</a>、Java 编程视频、PDF 资料。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220211231206733.png" alt=""></p>
<p>最近几年，市面上有越来越多的“技术大佬”开始办培训班/训练营，动辄成千上万的学费，却并没有什么干货，单纯的就是割韭菜。</p>
<p>为了帮助更多同学准备 Java 面试以及学习 Java ，我创建了一个纯粹的<a href="https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc" target="_blank" rel="noopener noreferrer">知识星球</a>。虽然收费只有培训班/训练营的百分之一，但是<a href="https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc" target="_blank" rel="noopener noreferrer">知识星球</a>里的内容质量更高，提供的服务也更全面。</p>
<p>欢迎准备 Java 面试以及学习 Java 的同学加入我的<a href="https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc" target="_blank" rel="noopener noreferrer">知识星球</a>，干货非常多，学习氛围非常好！收费虽然是白菜价，但星球里的内容或许比你参加上万的培训班质量还要高。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220311203414600.png" alt=""></p>
<p>下面是星球提供的部分服务（点击下方图片即可获取知识星球的详细介绍）：</p>
<div align="center">
  <a href="https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html">
    <img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/xingqiufuwu.png" style="margin: 0 auto; ">
  </a>
</div>
<p>我有自己的原则，不割韭菜，用心做内容，真心希望帮助到你！</p>
<p>如果你感兴趣的话，不妨花 3 分钟左右看看星球的详细介绍： <a href="https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc" target="_blank" rel="noopener noreferrer">JavaGuide 知识星球详细介绍</a>（文末有优惠券）。</p>
<div align="center">
  <a href="https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html">
    <img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/xingqiuyouhuijuanheyi.png" style="margin: 0 auto; ">
  </a>
</div>
]]></content:encoded>
      <enclosure url="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javamianshizhibei/system-design-questions.png" type="image/png"/>
    </item>
    <item>
      <title>Web 实时消息推送详解</title>
      <link>https://javaguide.cn/system-design/web-real-time-message-push.html</link>
      <guid>https://javaguide.cn/system-design/web-real-time-message-push.html</guid>
      <source url="https://javaguide.cn/rss.xml">Web 实时消息推送详解</source>
      <description>原文地址：https://juejin.cn/post/7122014462181113887，JavaGuide 对本文进行了完善总结。 我有一个朋友做了一个小破站，现在要实现一个站内信 Web 消息推送的功能，对，就是下图这个小红点，一个很常用的功能。</description>
      <category>系统设计</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>原文地址：https://juejin.cn/post/7122014462181113887，JavaGuide 对本文进行了完善总结。</p>
</blockquote>
<p>我有一个朋友做了一个小破站，现在要实现一个站内信 Web 消息推送的功能，对，就是下图这个小红点，一个很常用的功能。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/system-design/web-real-time-message-push/1460000042192380.png" alt="站内信 Web 消息推送"></p>
<p>不过他还没想好用什么方式做，这里我帮他整理了一下几种方案，并简单做了实现。</p>
<h2> 什么是消息推送？</h2>
<p>推送的场景比较多，比如有人关注我的公众号，这时我就会收到一条推送消息，以此来吸引我点击打开应用。</p>
<p>消息推送通常是指网站的运营工作等人员，通过某种工具对用户当前网页或移动设备 APP 进行的主动消息推送。</p>
<p>消息推送一般又分为 Web 端消息推送和移动端消息推送。</p>
<p>移动端消息推送示例 ：</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/system-design/web-real-time-message-push/IKleJ9auR1Ojdicyr0bH.png" alt="移动端消息推送示例"></p>
<p>Web 端消息推送示例：</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/system-design/web-real-time-message-push/image-20220819100512941.png" alt="Web 端消息推送示例"></p>
<p>在具体实现之前，咱们再来分析一下前边的需求，其实功能很简单，只要触发某个事件（主动分享了资源或者后台主动推送消息），Web 页面的通知小红点就会实时的 <code>+1</code> 就可以了。</p>
<p>通常在服务端会有若干张消息推送表，用来记录用户触发不同事件所推送不同类型的消息，前端主动查询（拉）或者被动接收（推）用户所有未读的消息数。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/system-design/web-real-time-message-push/1460000042192384.png" alt="消息推送表"></p>
<p>消息推送无非是推（push）和拉（pull）两种形式，下边我们逐个了解下。</p>
<h2> 消息推送常见方案</h2>
<h3> 短轮询</h3>
<p><strong>轮询(polling)</strong> 应该是实现消息推送方案中最简单的一种，这里我们暂且将轮询分为短轮询和长轮询。</p>
<p>短轮询很好理解，指定的时间间隔，由浏览器向服务器发出 HTTP 请求，服务器实时返回未读消息数据给客户端，浏览器再做渲染显示。</p>
<p>一个简单的 JS 定时器就可以搞定，每秒钟请求一次未读消息数接口，返回的数据展示即可。</p>
<div class="language-typescript line-numbers-mode" data-ext="ts"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>效果还是可以的，短轮询实现固然简单，缺点也是显而易见，由于推送数据并不会频繁变更，无论后端此时是否有新的消息产生，客户端都会进行请求，势必会对服务端造成很大压力，浪费带宽和服务器资源。</p>
<h3> 长轮询</h3>
<p>长轮询是对上边短轮询的一种改进版本，在尽可能减少对服务器资源浪费的同时，保证消息的相对实时性。长轮询在中间件中应用的很广泛，比如 Nacos 和 Apollo 配置中心，消息队列 Kafka、RocketMQ 中都有用到长轮询。</p>
<p><a href="https://mp.weixin.qq.com/s/94ftESkDoZI9gAGflLiGwg" target="_blank" rel="noopener noreferrer">Nacos 配置中心交互模型是 push 还是 pull？</a>一文中我详细介绍过 Nacos 长轮询的实现原理，感兴趣的小伙伴可以瞅瞅。</p>
<p>长轮询其实原理跟轮询差不多，都是采用轮询的方式。不过，如果服务端的数据没有发生变更，会 一直 hold 住请求，直到服务端的数据发生变化，或者等待一定时间超时才会返回。返回后，客户端又会立即再次发起下一次长轮询。</p>
<p>这次我使用 Apollo 配置中心实现长轮询的方式，应用了一个类<code>DeferredResult</code>，它是在 Servelet3.0 后经过 Spring 封装提供的一种异步请求机制，直意就是延迟结果。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/system-design/web-real-time-message-push/1460000042192386.png" alt="长轮询示意图"></p>
<p><code>DeferredResult</code>可以允许容器线程快速释放占用的资源，不阻塞请求线程，以此接受更多的请求提升系统的吞吐量，然后启动异步工作线程处理真正的业务逻辑，处理完成调用<code>DeferredResult.setResult(200)</code>提交响应结果。</p>
<p>下边我们用长轮询来实现消息推送。</p>
<p>因为一个 ID 可能会被多个长轮询请求监听，所以我采用了 Guava 包提供的<code>Multimap</code>结构存放长轮询，一个 key 可以对应多个 value。一旦监听到 key 发生变化，对应的所有长轮询都会响应。前端得到非请求超时的状态码，知晓数据变更，主动查询未读消息数接口，更新页面数据。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当请求超过设置的超时时间，会抛出<code>AsyncRequestTimeoutException</code>异常，这里直接用<code>@ControllerAdvice</code>全局捕获统一返回即可，前端获取约定好的状态码后再次发起长轮询请求，如此往复调用。</p>
<div class="language-kotlin line-numbers-mode" data-ext="kt"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们来测试一下，首先页面发起长轮询请求<code>/polling/watch/10086</code>监听消息更变，请求被挂起，不变更数据直至超时，再次发起了长轮询请求；紧接着手动变更数据<code>/polling/publish/10086</code>，长轮询得到响应，前端处理业务逻辑完成后再次发起请求，如此循环往复。</p>
<p>长轮询相比于短轮询在性能上提升了很多，但依然会产生较多的请求，这是它的一点不完美的地方。</p>
<h3> iframe 流</h3>
<p>iframe 流就是在页面中插入一个隐藏的<code>&lt;iframe&gt;</code>标签，通过在<code>src</code>中请求消息数量 API 接口，由此在服务端和客户端之间创建一条长连接，服务端持续向<code>iframe</code>传输数据。</p>
<p>传输的数据通常是 HTML、或是内嵌的JavaScript 脚本，来达到实时更新页面的效果。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/system-design/web-real-time-message-push/1460000042192388.png" alt="iframe 流示意图"></p>
<p>这种方式实现简单，前端只要一个<code>&lt;iframe&gt;</code>标签搞定了</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>服务端直接组装 HTML、JS 脚本数据向 response 写入就行了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>iframe 流的服务器开销很大，而且IE、Chrome等浏览器一直会处于 loading 状态，图标会不停旋转，简直是强迫症杀手。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/system-design/web-real-time-message-push/1460000042192389.png" alt="iframe 流效果"></p>
<p>iframe 流非常不友好，强烈不推荐。</p>
<h3> SSE (我的方式)</h3>
<p>很多人可能不知道，服务端向客户端推送消息，其实除了可以用<code>WebSocket</code>这种耳熟能详的机制外，还有一种服务器发送事件(Server-Sent Events)，简称 SSE。这是一种服务器端到客户端(浏览器)的单向消息推送。</p>
<p>SSE 基于 HTTP 协议的，我们知道一般意义上的 HTTP 协议是无法做到服务端主动向客户端推送消息的，但 SSE 是个例外，它变换了一种思路。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/system-design/web-real-time-message-push/1460000042192390.png" alt=""></p>
<p>SSE 在服务器和客户端之间打开一个单向通道，服务端响应的不再是一次性的数据包而是<code>text/event-stream</code>类型的数据流信息，在有数据变更时从服务器流式传输到客户端。</p>
<p>整体的实现思路有点类似于在线视频播放，视频流会连续不断的推送到浏览器，你也可以理解成，客户端在完成一次用时很长（网络不畅）的下载。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/system-design/web-real-time-message-push/1460000042192391.png" alt="SSE 示意图"></p>
<p>SSE 与 WebSocket 作用相似，都可以建立服务端与浏览器之间的通信，实现服务端向客户端推送消息，但还是有些许不同：</p>
<ul>
<li>SSE 是基于 HTTP 协议的，它们不需要特殊的协议或服务器实现即可工作；WebSocket 需单独服务器来处理协议。</li>
<li>SSE 单向通信，只能由服务端向客户端单向通信；WebSocket 全双工通信，即通信的双方可以同时发送和接受信息。</li>
<li>SSE 实现简单开发成本低，无需引入其他组件；WebSocket 传输数据需做二次解析，开发门槛高一些。</li>
<li>SSE 默认支持断线重连；WebSocket 则需要自己实现。</li>
<li>SSE 只能传送文本消息，二进制数据需要经过编码后传送；WebSocket 默认支持传送二进制数据。</li>
</ul>
<p><strong>SSE 与 WebSocket 该如何选择？</strong></p>
<blockquote>
<p>技术并没有好坏之分，只有哪个更合适</p>
</blockquote>
<p>SSE 好像一直不被大家所熟知，一部分原因是出现了 WebSocket，这个提供了更丰富的协议来执行双向、全双工通信。对于游戏、即时通信以及需要双向近乎实时更新的场景，拥有双向通道更具吸引力。</p>
<p>但是，在某些情况下，不需要从客户端发送数据。而你只需要一些服务器操作的更新。比如：站内信、未读消息数、状态更新、股票行情、监控数量等场景，SEE 不管是从实现的难易和成本上都更加有优势。此外，SSE 具有 WebSocket 在设计上缺乏的多种功能，例如：自动重新连接、事件 ID 和发送任意事件的能力。</p>
<p>前端只需进行一次 HTTP 请求，带上唯一 ID，打开事件流，监听服务端推送的事件就可以了</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>服务端的实现更简单，创建一个<code>SseEmitter</code>对象放入<code>sseEmitterMap</code>进行管理</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>注意：</strong> SSE 不支持 IE 浏览器，对其他主流浏览器兼容性做的还不错。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/system-design/web-real-time-message-push/1460000042192393.png" alt="SSE 兼容性"></p>
<h3> Websocket</h3>
<p>Websocket 应该是大家都比较熟悉的一种实现消息推送的方式，上边我们在讲 SSE 的时候也和 Websocket 进行过比较。</p>
<p>是一种在 TCP 连接上进行全双工通信的协议，建立客户端和服务器之间的通信渠道。浏览器和服务器仅需一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/system-design/web-real-time-message-push/1460000042192394.png" alt="Websocket 示意图"></p>
<p>SpringBoot 整合 Websocket，先引入 Websocket 相关的工具包，和 SSE 相比额外的开发成本。</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>服务端使用<code>@ServerEndpoint</code>注解标注当前类为一个 WebSocket 服务器，客户端可以通过<code>ws://localhost:7777/webSocket/10086</code>来连接到 WebSocket 服务器端。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>前端初始化打开 WebSocket 连接，并监听连接状态，接收服务端数据或向服务端发送数据。</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>页面初始化建立 WebSocket 连接，之后就可以进行双向通信了，效果还不错。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/system-design/web-real-time-message-push/1460000042192395.png" alt=""></p>
<h3> MQTT</h3>
<p><strong>什么是 MQTT 协议？</strong></p>
<p>MQTT (Message Queue Telemetry Transport)是一种基于发布/订阅（publish/subscribe）模式的轻量级通讯协议，通过订阅相应的主题来获取消息，是物联网（Internet of Thing）中的一个标准传输协议。</p>
<p>该协议将消息的发布者（publisher）与订阅者（subscriber）进行分离，因此可以在不可靠的网络环境中，为远程连接的设备提供可靠的消息服务，使用方式与传统的 MQ 有点类似。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/system-design/web-real-time-message-push/1460000022986325.png" alt="MQTT 协议示例"></p>
<p>TCP 协议位于传输层，MQTT 协议位于应用层，MQTT 协议构建于 TCP/IP 协议上，也就是说只要支持 TCP/IP 协议栈的地方，都可以使用 MQTT 协议。</p>
<p><strong>为什么要用 MQTT 协议？</strong></p>
<p>MQTT 协议为什么在物联网（IOT）中如此受偏爱？而不是其它协议，比如我们更为熟悉的 HTTP 协议呢？</p>
<ul>
<li>首先 HTTP 协议它是一种同步协议，客户端请求后需要等待服务器的响应。而在物联网（IOT）环境中，设备会很受制于环境的影响，比如带宽低、网络延迟高、网络通信不稳定等，显然异步消息协议更为适合 IOT 应用程序。</li>
<li>HTTP 是单向的，如果要获取消息客户端必须发起连接，而在物联网（IOT）应用程序中，设备或传感器往往都是客户端，这意味着它们无法被动地接收来自网络的命令。</li>
<li>通常需要将一条命令或者消息，发送到网络上的所有设备上。HTTP 要实现这样的功能不但很困难，而且成本极高。</li>
</ul>
<p>具体的 MQTT 协议介绍和实践，这里我就不再赘述了，大家可以参考我之前的两篇文章，里边写的也都很详细了。</p>
<ul>
<li>MQTT 协议的介绍：<a href="https://mp.weixin.qq.com/s/udFE6k9pPetIWsa6KeErrA" target="_blank" rel="noopener noreferrer">我也没想到 SpringBoot + RabbitMQ 做智能家居，会这么简单</a></li>
<li>MQTT 实现消息推送：<a href="https://mp.weixin.qq.com/s/U-fUGr9i1MVa4PoVyiDFCg" target="_blank" rel="noopener noreferrer">未读消息（小红点），前端 与 RabbitMQ 实时消息推送实践，贼简单~</a></li>
</ul>
<h2> 总结</h2>
<blockquote>
<p>以下内容为 JavaGuide 补充</p>
</blockquote>
<table>
<thead>
<tr>
<th></th>
<th>介绍</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>短轮询</td>
<td>客户端定时向服务端发送请求，服务端直接返回响应数据（即使没有数据更新）</td>
<td>简单、易理解、易实现</td>
<td>实时性太差，无效请求太多，频繁建立连接太耗费资源</td>
</tr>
<tr>
<td>长轮询</td>
<td>与短轮询不同是，长轮询接收到客户端请求之后等到有数据更新才返回请求</td>
<td>减少了无效请求</td>
<td>挂起请求会导致资源浪费</td>
</tr>
<tr>
<td>iframe 流</td>
<td>服务端和客户端之间创建一条长连接，服务端持续向<code>iframe</code>传输数据。</td>
<td>简单、易理解、易实现</td>
<td>维护一个长连接会增加开销，效果太差（图标会不停旋转）</td>
</tr>
<tr>
<td>SSE</td>
<td>一种服务器端到客户端(浏览器)的单向消息推送。</td>
<td>简单、易实现，功能丰富</td>
<td>不支持双向通信</td>
</tr>
<tr>
<td>WebSocket</td>
<td>除了最初建立连接时用 HTTP 协议，其他时候都是直接基于 TCP 协议进行通信的，可以实现客户端和服务端的全双工通信。</td>
<td>性能高、开销小</td>
<td>对开发人员要求更高，实现相对复杂一些</td>
</tr>
<tr>
<td>MQTT</td>
<td>基于发布/订阅（publish/subscribe）模式的轻量级通讯协议，通过订阅相应的主题来获取消息。</td>
<td>成熟稳定，轻量级</td>
<td>对开发人员要求更高，实现相对复杂一些</td>
</tr>
</tbody>
</table>
]]></content:encoded>
      <enclosure url="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/system-design/web-real-time-message-push/1460000042192380.png" type="image/png"/>
    </item>
    <item>
      <title>常用开发工具总结</title>
      <link>https://javaguide.cn/tools/</link>
      <guid>https://javaguide.cn/tools/</guid>
      <source url="https://javaguide.cn/rss.xml">常用开发工具总结</source>
      <description>常用开发工具总结 数据库 CHINER: 干掉 PowerDesigner，这个国产数据库建模工具很强！ DBeaver:开源数据库管理工具。 screw:一键生成数据库文档，堪称数据库界的Swagger DataGrip:IDEA官方的这个数据库管理神器真香！</description>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 常用开发工具总结</h1>
<h2> 数据库</h2>
<ul>
<li><a href="/tools/database/CHINER.html" target="blank">CHINER: 干掉 PowerDesigner，这个国产数据库建模工具很强！</a></li>
<li><a href="/tools/database/DBeaver.html" target="blank">DBeaver:开源数据库管理工具。</a></li>
<li><a href="/tools/database/screw.html" target="blank">screw:一键生成数据库文档，堪称数据库界的Swagger</a></li>
<li><a href="/tools/database/datagrip.html" target="blank">DataGrip:IDEA官方的这个数据库管理神器真香！</a></li>
</ul>
<h2> Git</h2>
<ul>
<li><a href="/tools/git/git-intro.html" target="blank">Git 入门</a></li>
<li><a href="/tools/git/git-intro.html" target="blank">Github 小技巧</a></li>
</ul>
<h2> Docker</h2>
<ul>
<li><a href="/tools/docker/docker-intro.html" target="blank">Docker 基本概念解读</a></li>
<li><a href="/tools/docker/docker-in-actiono.html" target="blank">Docker从入门到上手干事</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>《手写 RPC 框架》(付费)</title>
      <link>https://javaguide.cn/zhuanlan/handwritten-rpc-framework.html</link>
      <guid>https://javaguide.cn/zhuanlan/handwritten-rpc-framework.html</guid>
      <source url="https://javaguide.cn/rss.xml">《手写 RPC 框架》(付费)</source>
      <description>介绍 《手写 RPC 框架》 是我的知识星球的一个内部小册，我写了 12 篇文章来讲解如何从零开始基于 Netty+Kyro+Zookeeper 实现一个简易的 RPC 框架。 麻雀虽小五脏俱全，项目代码注释详细，结构清晰，并且集成了 Check Style 规范代码结构，非常适合阅读和学习。 内容概览</description>
      <category>知识星球</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 介绍</h2>
<p><strong>《手写 RPC 框架》</strong> 是我的<a href="/about-the-author/zhishixingqiu-two-years.html" target="blank">知识星球</a>的一个内部小册，我写了 12 篇文章来讲解如何从零开始基于 Netty+Kyro+Zookeeper 实现一个简易的 RPC 框架。</p>
<p>麻雀虽小五脏俱全，项目代码注释详细，结构清晰，并且集成了 Check Style 规范代码结构，非常适合阅读和学习。</p>
<h2> 内容概览</h2>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/image-20220308100605485.png" alt=""></p>
<p>通过这个简易的轮子，你可以学到 RPC 的底层原理和原理以及各种 Java 编码实践的运用。你甚至可以把它当做你的毕设/项目经验的选择，这是非常不错！对比其他求职者的项目经验都是各种系统，造轮子肯定是更加能赢得面试官的青睐。</p>
<ul>
<li>Github 地址：<a href="https://github.com/Snailclimb/guide-rpc-framework" target="_blank" rel="noopener noreferrer">https://github.com/Snailclimb/guide-rpc-framework</a> 。</li>
<li>Gitee 地址：<a href="https://gitee.com/SnailClimb/guide-rpc-framework" target="_blank" rel="noopener noreferrer">https://gitee.com/SnailClimb/guide-rpc-framework</a> 。</li>
</ul>
<h2> 星球其他资源</h2>
<p>除了 <strong>《手写 RPC 框架》</strong> 之外，星球还有 <strong>《Java 必读源码系列》</strong>（目前已经整理了 Dubbo 2.6.x 、Netty 4.x、SpringBoot2.1 的源码）、 <strong>《Java 面试指北》</strong> 、<strong>《Kafka 常见面试题/知识点总结》</strong> 等多个专属小册。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220316200015412.png" alt="">
另外，星球还会有读书活动、学习打卡、简历修改、免费提问、海量 Java 优质面试资源以及各种不定时的福利。
<img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220304124333119.png" alt=""></p>
<h2> 星球限时优惠</h2>
<p>两年前，星球的定价是 <strong>50/年</strong> ，这是星球的最低定价，我还附送了 33 元优惠券。扣除了星球手续费，发了各种福利之后，几乎就是纯粹做公益。</p>
<p>感兴趣的小伙伴可以看看我在 2020-01-03 发的头条：<a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247486049&amp;idx=1&amp;sn=e0161b409e8f164251bdaa0c83a476bc&amp;chksm=cea245aaf9d5ccbcafdb95a546d959508814085620aabdbb4385c4b8cea6e50bf157c3697041&amp;token=1614894361&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">做了一个很久没敢做的事情</a>，去考古一下。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220311203414600.png" alt=""></p>
<p>随着时间推移，星球积累的干货资源越来越多，我花在星球上的时间也越来越多。于是，我将星球的定价慢慢调整为了 <strong>159/年</strong>！后续会将星球的价格调整为 <strong>199/年</strong>，想要加入的小伙伴一定要尽早。</p>
<p>你可以添加我的微信（没有手机号再申请微信，故使用企业微信。不过，请放心，这个号的消息也是我本人处理，平时最常看这个微信）领取星球专属优惠券，限时 <strong>130/年</strong> 加入(续费半价)！</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/IMG_3007.jpg" alt=""></p>
<p>或者你也可以直接使用下面这张 <strong>20</strong> 元的优惠券，<strong>139/年</strong> 加入。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/xingqiuyouhuijuan-20.png" alt=""></p>
<p>进入星球之后，你可以为自己制定一个目标，比如自己想要进入某某还不错的公司或者达成什么成就（一定要是还算有点挑战的目标）。待你完成目标在星球分享之后，我会将星球的门票费退还给你。</p>
<p><strong>真诚欢迎准备面试的小伙伴加入星球一起交流！真心希望能够帮助到更多小伙伴！</strong></p>
<p><strong>加入星球之后记得看<a href="https://t.zsxq.com/04iiiAqf6" target="_blank" rel="noopener noreferrer">置顶主题</a>，你会发现物超所值！</strong></p>
]]></content:encoded>
      <enclosure url="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/image-20220308100605485.png" type="image/png"/>
    </item>
    <item>
      <title>《Java 面试指北》(付费)</title>
      <link>https://javaguide.cn/zhuanlan/java-mian-shi-zhi-bei.html</link>
      <guid>https://javaguide.cn/zhuanlan/java-mian-shi-zhi-bei.html</guid>
      <source url="https://javaguide.cn/rss.xml">《Java 面试指北》(付费)</source>
      <description>介绍 《Java 面试指北》 是我的知识星球的一个内部小册，和 JavaGuide 开源版的内容互补。相比于开源版本来说，《Java 面试指北》添加了下面这些内容（不仅仅是这些内容）： 10+ 篇文章手把手教你如何准备面试。 更全面的八股文面试题（系统设计、常见框架、分布式、高并发 ......）。 优质面经精选。 技术面试题自测。 练级攻略（有助于个人成长的经验）。</description>
      <category>知识星球</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 介绍</h2>
<p><strong>《Java 面试指北》</strong> 是我的<a href="/about-the-author/zhishixingqiu-two-years.html" target="blank">知识星球</a>的一个内部小册，和 <a href="https://javaguide.cn/" target="_blank" rel="noopener noreferrer">JavaGuide 开源版</a>的内容互补。相比于开源版本来说，《Java 面试指北》添加了下面这些内容（不仅仅是这些内容）：</p>
<ul>
<li>10+ 篇文章手把手教你如何准备面试。</li>
<li>更全面的八股文面试题（系统设计、常见框架、分布式、高并发 ......）。</li>
<li>优质面经精选。</li>
<li>技术面试题自测。</li>
<li>练级攻略（有助于个人成长的经验）。</li>
</ul>
<h2> 内容概览</h2>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javamianshizhibei/javamianshizhibei-content-overview.png" alt="《Java 面试指北》内容概览"></p>
<h3> 面试准备篇</h3>
<p>在 <strong>「面试准备篇」</strong> ，我写了 10+ 篇文章手把手教你如何准备面试，涵盖项目经验、简历编写、源码学习、算法准备、面试资源等内容。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javamianshizhibei/preparation-for-interview.png" alt="《Java 面试指北》面试准备篇"></p>
<p>另外，考虑到很多小伙伴缺少项目经历，我还推荐了很多小众但优质的实战项目，有视频也有开源项目，有业务系统，也有各种含金量比较高的轮子类项目。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javamianshizhibei/practical-project-recommendation.png" alt="实战项目推荐"></p>
<h3> 技术面试题篇</h3>
<p><strong>「技术面试题篇」</strong> 的内容和 JavaGuide 开源版本互补，不仅仅包括最基本的 Java、常见框架等八股文，还包括系统设计、分布式、高并发等进阶内容。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javamianshizhibei/technical-interview-questions.png" alt="《Java 面试指北》技术面试题篇"></p>
<h3> 面经篇</h3>
<p>古人云:“<strong>他山之石，可以攻玉</strong>” 。善于学习借鉴别人的面试的成功经验或者失败的教训，可以让自己少走许多弯路。</p>
<p><strong>「面经篇」</strong> 主要会分享一些高质量的 Java 后端面经，有校招的，也有社招的，有大厂的，也有中小厂的。</p>
<p>如果你是非科班的同学，也能在这些文章中找到对应的非科班的同学写的面经。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/githubjuejinjihua/thinkimage-20220612185810480.png" alt="《Java 面试指北》面经篇"></p>
<p>并且，<a href="https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc" target="_blank" rel="noopener noreferrer">知识星球</a>还有专门分享面经和面试题的专题，里面会分享很多优质的面经和面试题。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220304120018731.png" alt=""></p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220628101743381.png" alt=""></p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220628101805897.png" alt=""></p>
<h3> 技术面试题自测篇</h3>
<p>为了让小伙伴们自测以检查自己的掌握情况，我还推出了 <strong>「技术面试题自测」</strong> 系列。不过，目前只更新了 Java 和数据库的自测，正在持续更新中。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220621095641897.png" alt="《Java 面试指北》技术面试题自测篇"></p>
<h3> 练级攻略篇</h3>
<p><strong>「练级攻略篇」</strong> 这个系列主要内容一些有助于个人成长的经验分享。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javamianshizhibei/training-strategy-articles.png" alt="《Java 面试指北》练级攻略篇"></p>
<p>每一篇内容都非常干货，不少球友看了之后表示收获漫漫。不过，最重要的还是知行合一。</p>
<h2> 星球其他资源</h2>
<p>除了 <strong>《Java 面试指北》</strong> 之外，星球还有 <strong>《Java 必读源码系列》</strong>（目前已经整理了 Dubbo 2.6.x 、Netty 4.x、SpringBoot2.1 的源码）、 <strong>《从零开始写一个 RPC 框架》</strong>（已更新完） 、<strong>《Kafka 常见面试题/知识点总结》</strong> 等多个专属小册。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220316200015412.png" alt="">
另外，星球还会有读书活动、学习打卡、简历修改、免费提问、海量 Java 优质面试资源以及各种不定时的福利。
<img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220304124333119.png" alt=""></p>
<h2> 星球限时优惠</h2>
<p>两年前，星球的定价是 <strong>50/年</strong> ，这是星球的最低定价，我还附送了 33 元优惠券。扣除了星球手续费，发了各种福利之后，几乎就是纯粹做公益。</p>
<p>感兴趣的小伙伴可以看看我在 2020-01-03 发的头条：<a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247486049&amp;idx=1&amp;sn=e0161b409e8f164251bdaa0c83a476bc&amp;chksm=cea245aaf9d5ccbcafdb95a546d959508814085620aabdbb4385c4b8cea6e50bf157c3697041&amp;token=1614894361&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">做了一个很久没敢做的事情</a>，去考古一下。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220311203414600.png" alt=""></p>
<p>随着时间推移，星球积累的干货资源越来越多，我花在星球上的时间也越来越多。于是，我将星球的定价慢慢调整为了 <strong>159/年</strong>！后续会将星球的价格调整为 <strong>199/年</strong>，想要加入的小伙伴一定要尽早。</p>
<p>你可以添加我的微信（没有手机号再申请微信，故使用企业微信。不过，请放心，这个号的消息也是我本人处理，平时最常看这个微信）领取星球专属优惠券，限时 <strong>130/年</strong> 加入(续费半价)！</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/IMG_3007.jpg" alt=""></p>
<p><strong>推荐你添加我的微信，进入星球后会发你详细的使用建议，帮助你更好地利用星球。</strong></p>
<p>或者你也可以直接使用下面这张 <strong>20</strong> 元的优惠券，<strong>139/年</strong> 加入。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/xingqiuyouhuijuan-20.png" alt=""></p>
<p>进入星球之后，你可以为自己制定一个目标，比如自己想要进入某某还不错的公司或者达成什么成就（一定要是还算有点挑战的目标）。待你完成目标在星球分享之后，我会将星球的门票费退还给你。</p>
<p><strong>真诚欢迎准备面试的小伙伴加入星球一起交流！真心希望能够帮助到更多小伙伴！</strong></p>
<p><strong>加入星球之后记得看<a href="https://t.zsxq.com/04iiiAqf6" target="_blank" rel="noopener noreferrer">置顶主题</a>，你会发现物超所值！</strong></p>
]]></content:encoded>
      <enclosure url="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javamianshizhibei/javamianshizhibei-content-overview.png" type="image/png"/>
    </item>
    <item>
      <title>星球专属优质专栏概览</title>
      <link>https://javaguide.cn/zhuanlan/</link>
      <guid>https://javaguide.cn/zhuanlan/</guid>
      <source url="https://javaguide.cn/rss.xml">星球专属优质专栏概览</source>
      <description>这部分的内容为我的知识星球专属，目前已经更新了下面这些专栏： 《Java 面试指北》 : 与 JavaGuide 开源版的内容互补！ 《手写 RPC 框架》 : 从零开始基于 Netty+Kyro+Zookeeper 实现一个简易的 RPC 框架。 《Java 必读源码系列》 ：目前已经整理了 Dubbo 2.6.x 、Netty 4.x、SpringBoot 2.1 等框架/中间件的源码 ......</description>
      <category>知识星球</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<p>这部分的内容为我的<a href="/about-the-author/zhishixingqiu-two-years.html" target="blank">知识星球</a>专属，目前已经更新了下面这些专栏：</p>
<ul>
<li><strong><a href="/zhuanlan/java-mian-shi-zhi-bei.html" target="blank">《Java 面试指北》</a></strong> : 与 JavaGuide 开源版的内容互补！</li>
<li><strong><a href="/zhuanlan/java-mian-shi-zhi-bei.html" target="blank">《手写 RPC 框架》</a></strong> : 从零开始基于 Netty+Kyro+Zookeeper 实现一个简易的 RPC 框架。</li>
<li><strong><a href="/zhuanlan/source-code-reading.html" target="blank">《Java 必读源码系列》</a></strong> ：目前已经整理了 Dubbo 2.6.x 、Netty 4.x、SpringBoot 2.1 等框架/中间件的源码</li>
<li>......</li>
</ul>
<p>欢迎准备 Java 面试以及学习 Java 的同学加入我的<a href="/about-the-author/zhishixingqiu-two-years.html" target="blank">知识星球</a>，干货非常多！收费虽然是白菜价，但星球里的内容比你参加几万的培训班质量还要高。</p>
<p>我有自己的原则，不割韭菜，用心做内容，真心希望帮助到你！</p>
<h2> 更多专栏</h2>
<p>除了上面介绍的之外，我的<a href="/about-the-author/zhishixingqiu-two-years.html" target="blank">知识星球</a>还有  <strong>《Kafka 常见面试题/知识点总结》</strong> 、**《程序员副业赚钱之路》**等多个专栏。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220211231206733.png" alt=""></p>
<p>另外，星球还会有读书活动、学习打卡、简历修改、免费提问、海量 Java 优质面试资源以及各种不定时的福利。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220304124333119.png" alt=""></p>
<h2> 星球限时优惠</h2>
<p>两年前，星球的定价是 <strong>50/年</strong> ，这是星球的最低定价，我还附送了 33 元优惠券。扣除了星球手续费，发了各种福利之后，几乎就是纯粹做公益。</p>
<p>感兴趣的小伙伴可以看看我在 2020-01-03 发的头条：<a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247486049&amp;idx=1&amp;sn=e0161b409e8f164251bdaa0c83a476bc&amp;chksm=cea245aaf9d5ccbcafdb95a546d959508814085620aabdbb4385c4b8cea6e50bf157c3697041&amp;token=1614894361&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">做了一个很久没敢做的事情</a>，去考古一下。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220311203414600.png" alt=""></p>
<p>随着时间推移，星球积累的干货资源越来越多，我花在星球上的时间也越来越多。于是，我将星球的定价慢慢调整为了 <strong>159/年</strong>！后续会将星球的价格调整为 <strong>199/年</strong>，想要加入的小伙伴一定要尽早。</p>
<p>你可以添加我的微信（没有手机号再申请微信，故使用企业微信。不过，请放心，这个号的消息也是我本人处理，平时最常看这个微信）领取星球专属优惠券，限时 <strong>130/年</strong> 加入！</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/IMG_3007.jpg" alt=""></p>
<p>或者你也可以直接使用下面这张 <strong>20</strong> 元的优惠券，<strong>139/年</strong> 加入。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/xingqiuyouhuijuan-20.png" alt=""></p>
<p>进入星球之后，你可以为自己制定一个目标，比如自己想要进入某某还不错的公司或者达成什么成就（一定要是还算有点挑战的目标）。待你完成目标在星球分享之后，我会将星球的门票费退还给你。</p>
<p><strong>真诚欢迎准备面试的小伙伴加入星球一起交流！真心希望能够帮助到更多小伙伴！</strong></p>
<p><strong>加入星球之后记得看<a href="https://t.zsxq.com/04iiiAqf6" target="_blank" rel="noopener noreferrer">置顶主题</a>，你会发现物超所值！</strong></p>
]]></content:encoded>
      <enclosure url="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220211231206733.png" type="image/png"/>
    </item>
    <item>
      <title>《Java 必读源码系列》(付费)</title>
      <link>https://javaguide.cn/zhuanlan/source-code-reading.html</link>
      <guid>https://javaguide.cn/zhuanlan/source-code-reading.html</guid>
      <source url="https://javaguide.cn/rss.xml">《Java 必读源码系列》(付费)</source>
      <description>介绍 《Java 必读源码系列》 是我的知识星球的一个内部小册，目前已经整理了 Dubbo 2.6.x 、Netty 4.x、SpringBoot 2.1 等框架/中间件的源码。 结构清晰，内容详细，非常适合想要深入学习框架/中间件源码的同学阅读。 内容概览</description>
      <category>知识星球</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 介绍</h2>
<p><strong>《Java 必读源码系列》</strong> 是我的<a href="/about-the-author/zhishixingqiu-two-years.html" target="blank">知识星球</a>的一个内部小册，目前已经整理了 Dubbo 2.6.x 、Netty 4.x、SpringBoot 2.1 等框架/中间件的源码。</p>
<p>结构清晰，内容详细，非常适合想要深入学习框架/中间件源码的同学阅读。</p>
<h2> 内容概览</h2>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220621091832348.png" alt=""></p>
<h2> 星球其他资源</h2>
<p>除了 <strong>《Java 必读源码系列》</strong> 之外，星球还有 <strong>《从零开始写一个 RPC 框架》</strong> 、 <strong>《Java 面试指北》</strong>、 <strong>《Java 必读源码系列》</strong>（目前已经整理了 Dubbo 2.6.x 、Netty 4.x、SpringBoot2.1 的源码） 、<strong>《Kafka 常见面试题/知识点总结》</strong> 等多个专栏。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220211231206733.png" alt=""></p>
<p>另外，星球还会有读书活动、学习打卡、简历修改、免费提问、海量 Java 优质面试资源以及各种不定时的福利。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220304124333119.png" alt=""></p>
<h2> 星球其他资源</h2>
<p>除了 <strong>《Java 必读源码系列》</strong> 之外，星球还有 <strong>《手写 RPC 框架》</strong>、 <strong>《Java 面试指北》</strong> 、<strong>《Kafka 常见面试题/知识点总结》</strong> 等多个专属小册。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220316200015412.png" alt="">
另外，星球还会有读书活动、学习打卡、简历修改、免费提问、海量 Java 优质面试资源以及各种不定时的福利。
<img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220304124333119.png" alt=""></p>
<h2> 星球限时优惠</h2>
<p>两年前，星球的定价是 <strong>50/年</strong> ，这是星球的最低定价，我还附送了 33 元优惠券。扣除了星球手续费，发了各种福利之后，几乎就是纯粹做公益。</p>
<p>感兴趣的小伙伴可以看看我在 2020-01-03 发的头条：<a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247486049&amp;idx=1&amp;sn=e0161b409e8f164251bdaa0c83a476bc&amp;chksm=cea245aaf9d5ccbcafdb95a546d959508814085620aabdbb4385c4b8cea6e50bf157c3697041&amp;token=1614894361&amp;lang=zh_CN#rd" target="_blank" rel="noopener noreferrer">做了一个很久没敢做的事情</a>，去考古一下。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220311203414600.png" alt=""></p>
<p>随着时间推移，星球积累的干货资源越来越多，我花在星球上的时间也越来越多。于是，我将星球的定价慢慢调整为了 <strong>159/年</strong>！后续会将星球的价格调整为 <strong>199/年</strong>，想要加入的小伙伴一定要尽早。</p>
<p>你可以添加我的微信（没有手机号再申请微信，故使用企业微信。不过，请放心，这个号的消息也是我本人处理，平时最常看这个微信）领取星球专属优惠券，限时 <strong>130/年</strong> 加入(续费半价)！</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/IMG_3007.jpg" alt=""></p>
<p>或者你也可以直接使用下面这张 <strong>20</strong> 元的优惠券，<strong>139/年</strong> 加入。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/xingqiuyouhuijuan-20.png" alt=""></p>
<p>进入星球之后，你可以为自己制定一个目标，比如自己想要进入某某还不错的公司或者达成什么成就（一定要是还算有点挑战的目标）。待你完成目标在星球分享之后，我会将星球的门票费退还给你。</p>
<p><strong>真诚欢迎准备面试的小伙伴加入星球一起交流！真心希望能够帮助到更多小伙伴！</strong></p>
<p><strong>加入星球之后记得看<a href="https://t.zsxq.com/04iiiAqf6" target="_blank" rel="noopener noreferrer">置顶主题</a>，你会发现物超所值！</strong></p>
]]></content:encoded>
      <enclosure url="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220621091832348.png" type="image/png"/>
    </item>
    <item>
      <title>十大经典排序算法总结</title>
      <link>https://javaguide.cn/cs-basics/algorithms/10-classical-sorting-algorithms.html</link>
      <guid>https://javaguide.cn/cs-basics/algorithms/10-classical-sorting-algorithms.html</guid>
      <source url="https://javaguide.cn/rss.xml">十大经典排序算法总结</source>
      <description>本文转自：http://www.guoyaohua.com/sorting.html，JavaGuide 对其做了补充完善。 引言 所谓排序，就是使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作。排序算法，就是如何使得记录按照要求排列的方法。排序算法在很多领域得到相当地重视，尤其是在大量数据的处理方面。一个优秀的算法可以节省大量的资源。在各个领域中考虑到数据的各种限制和规范，要得到一个符合实际的优秀算法，得经过大量的推理和分析。 两年前，我曾在博客园发布过一篇《十大经典排序算法最强总结（含 JAVA 代码实现）》博文，简要介绍了比较经典的十大排序算法，不过在之前的博文中，仅给出了 Java 版本的代码实现，并且有一些细节上的错误。所以，今天重新写一篇文章，深入了解下十大经典排序算法的原理及实现。</description>
      <category>计算机基础</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>本文转自：http://www.guoyaohua.com/sorting.html，JavaGuide 对其做了补充完善。</p>
</blockquote>
<h2> 引言</h2>
<p>所谓排序，就是使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作。排序算法，就是如何使得记录按照要求排列的方法。排序算法在很多领域得到相当地重视，尤其是在大量数据的处理方面。一个优秀的算法可以节省大量的资源。在各个领域中考虑到数据的各种限制和规范，要得到一个符合实际的优秀算法，得经过大量的推理和分析。</p>
<p>两年前，我曾在<a href="https://www.cnblogs.com/guoyaohua/" target="_blank" rel="noopener noreferrer">博客园</a>发布过一篇<a href="https://www.cnblogs.com/guoyaohua/p/8600214.html" target="_blank" rel="noopener noreferrer">《十大经典排序算法最强总结（含 JAVA 代码实现）》</a>博文，简要介绍了比较经典的十大排序算法，不过在之前的博文中，仅给出了 Java 版本的代码实现，并且有一些细节上的错误。所以，今天重新写一篇文章，深入了解下十大经典排序算法的原理及实现。</p>
<h2> 简介</h2>
<p>排序算法可以分为：</p>
<ul>
<li><strong>内部排序</strong> ：数据记录在内存中进行排序。</li>
<li><strong><a href="https://zh.wikipedia.org/wiki/%E5%A4%96%E6%8E%92%E5%BA%8F" target="_blank" rel="noopener noreferrer">外部排序</a></strong> ：因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。</li>
</ul>
<p>常见的内部排序算法有：<strong>插入排序</strong>、<strong>希尔排序</strong>、<strong>选择排序</strong>、<strong>冒泡排序</strong>、<strong>归并排序</strong>、<strong>快速排序</strong>、<strong>堆排序</strong>、<strong>基数排序</strong>等，本文只讲解内部排序算法。用一张图概括：</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/sorting-algorithms/sort1.png" alt="十大排序算法"></p>
<p><strong>图片名词解释：</strong></p>
<ul>
<li><strong>n</strong>：数据规模</li>
<li><strong>k</strong>：“桶” 的个数</li>
<li><strong>In-place</strong>：占用常数内存，不占用额外内存</li>
<li><strong>Out-place</strong>：占用额外内存</li>
</ul>
<h3> 术语说明</h3>
<ul>
<li><strong>稳定</strong>：如果 A 原本在 B 前面，而 A=B，排序之后 A 仍然在 B 的前面。</li>
<li><strong>不稳定</strong>：如果 A 原本在 B 的前面，而 A=B，排序之后 A 可能会出现在 B 的后面。</li>
<li><strong>内排序</strong>：所有排序操作都在内存中完成。</li>
<li><strong>外排序</strong>：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行。</li>
<li><strong>时间复杂度</strong>： 定性描述一个算法执行所耗费的时间。</li>
<li><strong>空间复杂度</strong>：定性描述一个算法执行所需内存的大小。</li>
</ul>
<h3> 算法分类</h3>
<p>十种常见排序算法可以分类两大类别：<strong>比较类排序</strong>和<strong>非比较类排序</strong>。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/sorting-algorithms/sort2.png" alt="排序算法分类"></p>
<p>常见的<strong>快速排序</strong>、<strong>归并排序</strong>、<strong>堆排序</strong>以及<strong>冒泡排序</strong>等都属于<strong>比较类排序算法</strong>。比较类排序是通过比较来决定元素间的相对次序，由于其时间复杂度不能突破 <code>O(nlogn)</code>，因此也称为非线性时间比较类排序。在冒泡排序之类的排序中，问题规模为 <code>n</code>，又因为需要比较 <code>n</code> 次，所以平均时间复杂度为 <code>O(n²)</code>。在<strong>归并排序</strong>、<strong>快速排序</strong>之类的排序中，问题规模通过<strong>分治法</strong>消减为 <code>logn</code> 次，所以时间复杂度平均 <code>O(nlogn)</code>。</p>
<p>比较类排序的优势是，适用于各种规模的数据，也不在乎数据的分布，都能进行排序。可以说，比较排序适用于一切需要排序的情况。</p>
<p>而<strong>计数排序</strong>、<strong>基数排序</strong>、<strong>桶排序</strong>则属于<strong>非比较类排序算法</strong>。非比较排序不通过比较来决定元素间的相对次序，而是通过确定每个元素之前，应该有多少个元素来排序。由于它可以突破基于比较排序的时间下界，以线性时间运行，因此称为线性时间非比较类排序。 非比较排序只要确定每个元素之前的已有的元素个数即可，所有一次遍历即可解决。算法时间复杂度 <code>O(n)</code>。</p>
<p>非比较排序时间复杂度底，但由于非比较排序需要占用空间来确定唯一位置。所以对数据规模和数据分布有一定的要求。</p>
<h2> 冒泡排序 (Bubble Sort)</h2>
<p>冒泡排序是一种简单的排序算法。它重复地遍历要排序的序列，依次比较两个元素，如果它们的顺序错误就把它们交换过来。遍历序列的工作是重复地进行直到没有再需要交换为止，此时说明该序列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢 “浮” 到数列的顶端。</p>
<h3> 算法步骤</h3>
<ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li>
<li>针对所有的元素重复以上的步骤，除了最后一个；</li>
<li>重复步骤 1~3，直到排序完成。</li>
</ol>
<h3> 图解算法</h3>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/sorting-algorithms/bubble_sort.gif" alt="冒泡排序"></p>
<h3> 代码实现</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>此处对代码做了一个小优化，加入了 <code>is_sorted</code> Flag，目的是将算法的最佳时间复杂度优化为 <code>O(n)</code>，即当原输入序列就是排序好的情况下，该算法的时间复杂度就是 <code>O(n)</code>。</strong></p>
<h3> 算法分析</h3>
<ul>
<li><strong>稳定性</strong>：稳定</li>
<li><strong>时间复杂度</strong> ：最佳：O(n) ，最差：O(n2)， 平均：O(n2)</li>
<li><strong>空间复杂度</strong> ：O(1)</li>
<li><strong>排序方式</strong> ：In-place</li>
</ul>
<h2> 选择排序 (Selection Sort)</h2>
<p>选择排序是一种简单直观的排序算法，无论什么数据进去都是 <code>O(n²)</code> 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
<h3> 算法步骤</h3>
<ol>
<li>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</li>
<li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li>
<li>重复第 2 步，直到所有元素均排序完毕。</li>
</ol>
<h3> 图解算法</h3>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/sorting-algorithms/selection_sort.gif" alt="Selection Sort"></p>
<h3> 代码实现</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 算法分析</h3>
<ul>
<li><strong>稳定性</strong>：不稳定</li>
<li><strong>时间复杂度</strong> ：最佳：O(n2) ，最差：O(n2)， 平均：O(n2)</li>
<li><strong>空间复杂度</strong> ：O(1)</li>
<li><strong>排序方式</strong> ：In-place</li>
</ul>
<h2> 插入排序 (Insertion Sort)</h2>
<p>插入排序是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用 in-place 排序（即只需用到 <code>O(1)</code> 的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p>
<p>插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>
<p>插入排序和冒泡排序一样，也有一种优化算法，叫做拆半插入。</p>
<h3> 算法步骤</h3>
<ol>
<li>从第一个元素开始，该元素可以认为已经被排序；</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li>
<li>重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置；</li>
<li>将新元素插入到该位置后；</li>
<li>重复步骤 2~5。</li>
</ol>
<h3> 图解算法</h3>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/sorting-algorithms/insertion_sort.gif" alt="insertion_sort"></p>
<h3> 代码实现</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 算法分析</h3>
<ul>
<li><strong>稳定性</strong>：稳定</li>
<li><strong>时间复杂度</strong> ：最佳：O(n) ，最差：O(n2)， 平均：O(n2)</li>
<li><strong>空间复杂度</strong> ：O(1)</li>
<li><strong>排序方式</strong> ：In-place</li>
</ul>
<h2> 希尔排序 (Shell Sort)</h2>
<p>希尔排序是希尔 (Donald Shell) 于 1959 年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为递减增量排序算法，同时该算法是冲破 <code>O(n²)</code> 的第一批算法之一。</p>
<p>希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录 “基本有序” 时，再对全体记录进行依次直接插入排序。</p>
<h3> 算法步骤</h3>
<p>我们来看下希尔排序的基本步骤，在此我们选择增量 <code>gap=length/2</code>，缩小增量继续以 <code>gap = gap/2</code> 的方式，这种增量选择我们可以用一个序列来表示，<code>{n/2, (n/2)/2, ..., 1}</code>，称为<strong>增量序列</strong>。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。</p>
<p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p>
<ul>
<li>选择一个增量序列 <code>{t1, t2, …, tk}</code>，其中 <code>(ti&gt;tj, i&lt;j, tk=1)</code>；</li>
<li>按增量序列个数 k，对序列进行 k 趟排序；</li>
<li>每趟排序，根据对应的增量 <code>t</code>，将待排序列分割成若干长度为 <code>m</code> 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li>
</ul>
<h3> 图解算法</h3>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/sorting-algorithms/shell_sort.png" alt="shell_sort"></p>
<h3> 代码实现</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 算法分析</h3>
<ul>
<li><strong>稳定性</strong>：稳定</li>
<li><strong>时间复杂度</strong> ：最佳：O(nlogn)， 最差：O(n2) 平均：O(nlogn)</li>
<li><strong>空间复杂度</strong> ：<code>O(1)</code></li>
</ul>
<h2> 归并排序 (Merge Sort)</h2>
<p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法 (Divide and Conquer) 的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为 2 - 路归并。</p>
<p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 <code>O(nlogn)</code> 的时间复杂度。代价是需要额外的内存空间。</p>
<h3> 算法步骤</h3>
<p>归并排序算法是一个递归过程，边界条件为当输入序列仅有一个元素时，直接返回，具体过程如下：</p>
<ol>
<li>如果输入内只有一个元素，则直接返回，否则将长度为 <code>n</code> 的输入序列分成两个长度为 <code>n/2</code> 的子序列；</li>
<li>分别对这两个子序列进行归并排序，使子序列变为有序状态；</li>
<li>设定两个指针，分别指向两个已经排序子序列的起始位置；</li>
<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间（用于存放排序结果），并移动指针到下一位置；</li>
<li>重复步骤 3 ~4 直到某一指针达到序列尾；</li>
<li>将另一序列剩下的所有元素直接复制到合并序列尾。</li>
</ol>
<h3> 图解算法</h3>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/sorting-algorithms/merge_sort.gif" alt="MergeSort"></p>
<h3> 代码实现</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 算法分析</h3>
<ul>
<li><strong>稳定性</strong>：稳定</li>
<li><strong>时间复杂度</strong> ：最佳：O(nlogn)， 最差：O(nlogn)， 平均：O(nlogn)</li>
<li><strong>空间复杂度</strong> ：O(n)</li>
</ul>
<h2> 快速排序 (Quick Sort)</h2>
<p>快速排序用到了分治思想，同样的还有归并排序。乍看起来快速排序和归并排序非常相似，都是将问题变小，先排序子串，最后合并。不同的是快速排序在划分子问题的时候经过多一步处理，将划分的两组数据划分为一大一小，这样在最后合并的时候就不必像归并排序那样再进行比较。但也正因为如此，划分的不定性使得快速排序的时间复杂度并不稳定。</p>
<p>快速排序的基本思想：通过一趟排序将待排序列分隔成独立的两部分，其中一部分记录的元素均比另一部分的元素小，则可分别对这两部分子序列继续进行排序，以达到整个序列有序。</p>
<h3> 算法步骤</h3>
<p>快速排序使用<a href="https://zh.wikipedia.org/wiki/%E5%88%86%E6%B2%BB%E6%B3%95" target="_blank" rel="noopener noreferrer">分治法</a>（Divide and conquer）策略来把一个序列分为较小和较大的 2 个子序列，然后递回地排序两个子序列。具体算法描述如下：</p>
<ol>
<li>从序列中<strong>随机</strong>挑出一个元素，做为 “基准”(<code>pivot</code>)；</li>
<li>重新排列序列，将所有比基准值小的元素摆放在基准前面，所有比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个操作结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li>
<li>递归地把小于基准值元素的子序列和大于基准值元素的子序列进行快速排序。</li>
</ol>
<h3> 图解算法</h3>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/sorting-algorithms/random_quick_sort.gif" alt="RandomQuickSort"></p>
<h3> 代码实现</h3>
<blockquote>
<p>来源：<a href="https://segmentfault.com/a/1190000040022056" target="_blank" rel="noopener noreferrer">使用 Java 实现快速排序（详解）</a></p>
</blockquote>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 算法分析</h3>
<ul>
<li><strong>稳定性</strong> ：不稳定</li>
<li><strong>时间复杂度</strong> ：最佳：O(nlogn)， 最差：O(nlogn)，平均：O(nlogn)</li>
<li><strong>空间复杂度</strong> ：O(nlogn)</li>
</ul>
<h2> 堆排序 (Heap Sort)</h2>
<p>堆排序是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足<strong>堆的性质</strong>：即<strong>子结点的值总是小于（或者大于）它的父节点</strong>。</p>
<h3> 算法步骤</h3>
<ol>
<li>将初始待排序列 <code>(R1, R2, ……, Rn)</code> 构建成大顶堆，此堆为初始的无序区；</li>
<li>将堆顶元素 <code>R[1]</code> 与最后一个元素 <code>R[n]</code> 交换，此时得到新的无序区 <code>(R1, R2, ……, Rn-1)</code> 和新的有序区 (Rn), 且满足 <code>R[1, 2, ……, n-1]&lt;=R[n]</code>；</li>
<li>由于交换后新的堆顶 <code>R[1]</code> 可能违反堆的性质，因此需要对当前无序区 <code>(R1, R2, ……, Rn-1)</code> 调整为新堆，然后再次将 R [1] 与无序区最后一个元素交换，得到新的无序区 <code>(R1, R2, ……, Rn-2)</code> 和新的有序区 <code>(Rn-1, Rn)</code>。不断重复此过程直到有序区的元素个数为 <code>n-1</code>，则整个排序过程完成。</li>
</ol>
<h3> 图解算法</h3>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/sorting-algorithms/heap_sort.gif" alt="HeapSort"></p>
<h3> 代码实现</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 算法分析</h3>
<ul>
<li><strong>稳定性</strong> ：不稳定</li>
<li><strong>时间复杂度</strong> ：最佳：O(nlogn)， 最差：O(nlogn)， 平均：O(nlogn)</li>
<li><strong>空间复杂度</strong> ：O(1)</li>
</ul>
<h2> 计数排序 (Counting Sort)</h2>
<p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，<strong>计数排序要求输入的数据必须是有确定范围的整数</strong>。</p>
<p>计数排序 (Counting sort) 是一种稳定的排序算法。计数排序使用一个额外的数组 <code>C</code>，其中第 <code>i</code> 个元素是待排序数组 <code>A</code> 中值等于 <code>i</code> 的元素的个数。然后根据数组 <code>C</code> 来将 <code>A</code> 中的元素排到正确的位置。<strong>它只能对整数进行排序</strong>。</p>
<h3> 算法步骤</h3>
<ol>
<li>找出数组中的最大值 <code>max</code>、最小值 <code>min</code>；</li>
<li>创建一个新数组 <code>C</code>，其长度是 <code>max-min+1</code>，其元素默认值都为 0；</li>
<li>遍历原数组 <code>A</code> 中的元素 <code>A[i]</code>，以 <code>A[i]-min</code> 作为 <code>C</code> 数组的索引，以 <code>A[i]</code> 的值在 <code>A</code> 中元素出现次数作为 <code>C[A[i]-min]</code> 的值；</li>
<li>对 <code>C</code> 数组变形，<strong>新元素的值是该元素与前一个元素值的和</strong>，即当 <code>i&gt;1</code> 时 <code>C[i] = C[i] + C[i-1]</code>；</li>
<li>创建结果数组 <code>R</code>，长度和原始数组一样。</li>
<li><strong>从后向前</strong>遍历原始数组 <code>A</code> 中的元素 <code>A[i]</code>，使用 <code>A[i]</code> 减去最小值 <code>min</code> 作为索引，在计数数组 <code>C</code> 中找到对应的值 <code>C[A[i]-min]</code>，<code>C[A[i]-min]-1</code> 就是 <code>A[i]</code> 在结果数组 <code>R</code> 中的位置，做完上述这些操作，将 <code>count[A[i]-min]</code> 减小 1。</li>
</ol>
<h3> 图解算法</h3>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/sorting-algorithms/counting_sort.gif" alt="CountingSort"></p>
<h3> 代码实现</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 算法分析</h2>
<p>当输入的元素是 <code>n</code> 个 <code>0</code> 到 <code>k</code> 之间的整数时，它的运行时间是 <code>O(n+k)</code>。计数排序不是比较排序，排序的速度快于任何比较排序算法。由于用来计数的数组 <code>C</code> 的长度取决于待排序数组中数据的范围（等于待排序数组的<strong>最大值与最小值的差加上 1</strong>），这使得计数排序对于数据范围很大的数组，需要大量额外内存空间。</p>
<ul>
<li><strong>稳定性</strong> ：稳定</li>
<li><strong>时间复杂度</strong> ：最佳：<code>O(n+k)</code> 最差：<code>O(n+k)</code> 平均：<code>O(n+k)</code></li>
<li><strong>空间复杂度</strong> ：<code>O(k)</code></li>
</ul>
<h2> 桶排序 (Bucket Sort)</h2>
<p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：</p>
<ol>
<li>在额外空间充足的情况下，尽量增大桶的数量</li>
<li>使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中</li>
</ol>
<p>桶排序的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行。</p>
<h3> 算法步骤</h3>
<ol>
<li>设置一个 BucketSize，作为每个桶所能放置多少个不同数值；</li>
<li>遍历输入数据，并且把数据依次映射到对应的桶里去；</li>
<li>对每个非空的桶进行排序，可以使用其它排序方法，也可以递归使用桶排序；</li>
<li>从非空桶里把排好序的数据拼接起来。</li>
</ol>
<h3> 图解算法</h3>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/sorting-algorithms/bucket_sort.gif" alt="BucketSort"></p>
<h3> 代码实现</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 算法分析</h3>
<ul>
<li><strong>稳定性</strong> ：稳定</li>
<li><strong>时间复杂度</strong> ：最佳：<code>O(n+k)</code> 最差：<code>O(n²)</code> 平均：<code>O(n+k)</code></li>
<li><strong>空间复杂度</strong> ：<code>O(k)</code></li>
</ul>
<h2> 基数排序 (Radix Sort)</h2>
<p>基数排序也是非比较的排序算法，对元素中的每一位数字进行排序，从最低位开始排序，复杂度为 <code>O(n×k)</code>，<code>n</code> 为数组长度，<code>k</code> 为数组中元素的最大的位数；</p>
<p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。</p>
<h3> 算法步骤</h3>
<ol>
<li>取得数组中的最大数，并取得位数，即为迭代次数 <code>N</code>（例如：数组中最大数值为 1000，则 <code>N=4</code>）；</li>
<li><code>A</code> 为原始数组，从最低位开始取每个位组成 <code>radix</code> 数组；</li>
<li>对 <code>radix</code> 进行计数排序（利用计数排序适用于小范围数的特点）；</li>
<li>将 <code>radix</code> 依次赋值给原数组；</li>
<li>重复 2~4 步骤 <code>N</code> 次</li>
</ol>
<h3> 图解算法</h3>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/sorting-algorithms/radix_sort.gif" alt="RadixSort"></p>
<h3> 代码实现</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 算法分析</h3>
<ul>
<li><strong>稳定性</strong> ：稳定</li>
<li><strong>时间复杂度</strong> ：最佳：<code>O(n×k)</code> 最差：<code>O(n×k)</code> 平均：<code>O(n×k)</code></li>
<li><strong>空间复杂度</strong> ：<code>O(n+k)</code></li>
</ul>
<p><strong>基数排序 vs 计数排序 vs 桶排序</strong></p>
<p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p>
<ul>
<li>基数排序：根据键值的每位数字来分配桶</li>
<li>计数排序：每个桶只存储单一键值</li>
<li>桶排序：每个桶存储一定范围的数值</li>
</ul>
<h2> 参考文章</h2>
<ul>
<li>https://www.cnblogs.com/guoyaohua/p/8600214.html</li>
<li>https://en.wikipedia.org/wiki/Sorting_algorithm</li>
<li>https://sort.hust.cc/</li>
</ul>
]]></content:encoded>
      <enclosure url="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/sorting-algorithms/sort1.png" type="image/png"/>
    </item>
    <item>
      <title>几道常见的链表算法题</title>
      <link>https://javaguide.cn/cs-basics/algorithms/linkedlist-algorithm-problems.html</link>
      <guid>https://javaguide.cn/cs-basics/algorithms/linkedlist-algorithm-problems.html</guid>
      <source url="https://javaguide.cn/rss.xml">几道常见的链表算法题</source>
      <description>1. 两数相加 题目描述 Leetcode:给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。 你可以假设除了数字 0 之外，这两个数字都不会以零开头。 示例： 输入：(2 -&amp;gt; 4 -&amp;gt; 3) + (5 -&amp;gt; 6 -&amp;gt; 4) 输出：7 -&amp;gt; 0 -&amp;gt; 8 原因：342 + 465 = 807</description>
      <category>计算机基础</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 1. 两数相加</h2>
<h3> 题目描述</h3>
<blockquote>
<p>Leetcode:给定两个非空链表来表示两个非负整数。位数按照逆序方式存储，它们的每个节点只存储单个数字。将两数相加返回一个新的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p>
</blockquote>
<p>示例：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 问题分析</h3>
<p>Leetcode官方详细解答地址：</p>
<p>https://leetcode-cn.com/problems/add-two-numbers/solution/</p>
<blockquote>
<p>要对头结点进行操作时，考虑创建哑节点dummy，使用dummy-&gt;next表示真正的头节点。这样可以避免处理头节点为空的边界问题。</p>
</blockquote>
<p>我们使用变量来跟踪进位，并从包含最低有效位的表头开始模拟逐
位相加的过程。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-20/34910956.jpg" alt="图1，对两数相加方法的可视化: 342 + 465 = 807342+465=807， 每个结点都包含一个数字，并且数字按位逆序存储。"></p>
<h3> Solution</h3>
<p><strong>我们首先从最低有效位也就是列表 l1和 l2 的表头开始相加。注意需要考虑到进位的情况！</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 2. 翻转链表</h2>
<h3> 题目描述</h3>
<blockquote>
<p>剑指 offer:输入一个链表，反转链表后，输出链表的所有元素。</p>
</blockquote>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-20/81431871.jpg" alt="翻转链表"></p>
<h3> 问题分析</h3>
<p>这道算法题，说直白点就是：如何让后一个节点指向前一个节点！在下面的代码中定义了一个 next 节点，该节点主要是保存要反转到头的那个节点，防止链表 “断裂”。</p>
<h3> Solution</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>测试方法：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 3. 链表中倒数第k个节点</h2>
<h3> 题目描述</h3>
<blockquote>
<p>剑指offer: 输入一个链表，输出该链表中倒数第k个结点。</p>
</blockquote>
<h3> 问题分析</h3>
<blockquote>
<p><strong>链表中倒数第k个节点也就是正数第(L-K+1)个节点，知道了只一点，这一题基本就没问题！</strong></p>
</blockquote>
<p>首先两个节点/指针，一个节点 node1 先开始跑，指针 node1 跑到 k-1 个节点后，另一个节点 node2 开始跑，当 node1 跑到最后时，node2 所指的节点就是倒数第k个节点也就是正数第(L-K+1)个节点。</p>
<h3> Solution</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 4. 删除链表的倒数第N个节点</h2>
<blockquote>
<p>Leetcode:给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p>
</blockquote>
<p><strong>示例：</strong></p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>说明：</strong></p>
<p>给定的 n 保证是有效的。</p>
<p><strong>进阶：</strong></p>
<p>你能尝试使用一趟扫描实现吗？</p>
<p>该题在 leetcode 上有详细解答，具体可参考 Leetcode.</p>
<h3> 问题分析</h3>
<p>我们注意到这个问题可以容易地简化成另一个问题：删除从列表开头数起的第 (L - n + 1)个结点，其中 L是列表的长度。只要我们找到列表的长度 L，这个问题就很容易解决。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-20/94354387.jpg" alt="图 1. 删除列表中的第 L - n + 1 个元素"></p>
<h3> Solution</h3>
<p><strong>两次遍历法</strong></p>
<p>首先我们将添加一个 <strong>哑结点</strong> 作为辅助，该结点位于列表头部。哑结点用来简化某些极端情况，例如列表中只含有一个结点，或需要删除列表的头部。在第一次遍历中，我们找出列表的长度 L。然后设置一个指向哑结点的指针，并移动它遍历列表，直至它到达第 (L - n) 个结点那里。<strong>我们把第 (L - n)个结点的 next 指针重新链接至第 (L - n + 2)个结点，完成这个算法。</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>复杂度分析：</strong></p>
<ul>
<li><strong>时间复杂度 O(L)</strong> ：该算法对列表进行了两次遍历，首先计算了列表的长度 LL 其次找到第 (L - n)(L−n) 个结点。 操作执行了 2L-n2L−n 步，时间复杂度为 O(L)O(L)。</li>
<li><strong>空间复杂度 O(1)</strong> ：我们只用了常量级的额外空间。</li>
</ul>
<p><strong>进阶——一次遍历法：</strong></p>
<blockquote>
<p>链表中倒数第N个节点也就是正数第(L-N+1)个节点。</p>
</blockquote>
<p>其实这种方法就和我们上面第四题找“链表中倒数第k个节点”所用的思想是一样的。<strong>基本思路就是：</strong>  定义两个节点 node1、node2;node1 节点先跑，node1节点 跑到第 n+1 个节点的时候,node2 节点开始跑.当node1 节点跑到最后一个节点时，node2 节点所在的位置就是第 （L-n ） 个节点（L代表总链表长度，也就是倒数第 n+1 个节点）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 5. 合并两个排序的链表</h2>
<h3> 题目描述</h3>
<blockquote>
<p>剑指offer:输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p>
</blockquote>
<h3> 问题分析</h3>
<p>我们可以这样分析:</p>
<ol>
<li>假设我们有两个链表 A,B；</li>
<li>A的头节点A1的值与B的头结点B1的值比较，假设A1小，则A1为头节点；</li>
<li>A2再和B1比较，假设B1小,则，A1指向B1；</li>
<li>A2再和B2比较
就这样循环往复就行了，应该还算好理解。</li>
</ol>
<p>考虑通过递归的方式实现！</p>
<h3> Solution</h3>
<p><strong>递归版本：</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
      <enclosure url="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-20/34910956.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>几道常见的字符串算法题</title>
      <link>https://javaguide.cn/cs-basics/algorithms/string-algorithm-problems.html</link>
      <guid>https://javaguide.cn/cs-basics/algorithms/string-algorithm-problems.html</guid>
      <source url="https://javaguide.cn/rss.xml">几道常见的字符串算法题</source>
      <description>作者：wwwxmu 原文地址:https://www.weiweiblog.cn/13string/ 1. KMP 算法 谈到字符串问题，不得不提的就是 KMP 算法，它是用来解决字符串查找的问题，可以在一个字符串（S）中查找一个子串（W）出现的位置。KMP 算法把字符匹配的时间复杂度缩小到 O(m+n) ,而空间复杂度也只有O(m)。因为“暴力搜索”的方法会反复回溯主串，导致效率低下，而KMP算法可以利用已经部分匹配这个有效信息，保持主串上的指针不回溯，通过修改子串的指针，让模式串尽量地移动到有效的位置。</description>
      <category>计算机基础</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>作者：wwwxmu</p>
<p>原文地址:https://www.weiweiblog.cn/13string/</p>
</blockquote>
<h2> 1. KMP 算法</h2>
<p>谈到字符串问题，不得不提的就是 KMP 算法，它是用来解决字符串查找的问题，可以在一个字符串（S）中查找一个子串（W）出现的位置。KMP 算法把字符匹配的时间复杂度缩小到 O(m+n) ,而空间复杂度也只有O(m)。因为“暴力搜索”的方法会反复回溯主串，导致效率低下，而KMP算法可以利用已经部分匹配这个有效信息，保持主串上的指针不回溯，通过修改子串的指针，让模式串尽量地移动到有效的位置。</p>
<p>具体算法细节请参考：</p>
<ul>
<li><strong>字符串匹配的KMP算法:</strong> http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html</li>
<li><strong>从头到尾彻底理解KMP:</strong> https://blog.csdn.net/v_july_v/article/details/7041827</li>
<li><strong>如何更好的理解和掌握 KMP 算法?:</strong> https://www.zhihu.com/question/21923021</li>
<li><strong>KMP 算法详细解析:</strong>  https://blog.sengxian.com/algorithms/kmp</li>
<li><strong>图解 KMP 算法:</strong> http://blog.jobbole.com/76611/</li>
<li><strong>汪都能听懂的KMP字符串匹配算法【双语字幕】:</strong> https://www.bilibili.com/video/av3246487/?from=search&amp;seid=17173603269940723925</li>
<li><strong>KMP字符串匹配算法1:</strong> https://www.bilibili.com/video/av11866460?from=search&amp;seid=12730654434238709250</li>
</ul>
<p><strong>除此之外，再来了解一下BM算法！</strong></p>
<blockquote>
<p>BM算法也是一种精确字符串匹配算法，它采用从右向左比较的方法，同时应用到了两种启发式规则，即坏字符规则 和好后缀规则 ，来决定向右跳跃的距离。基本思路就是从右往左进行字符匹配，遇到不匹配的字符后从坏字符表和好后缀表找一个最大的右移值，将模式串右移继续匹配。
《字符串匹配的KMP算法》:http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html</p>
</blockquote>
<h2> 2. 替换空格</h2>
<blockquote>
<p>剑指offer：请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
</blockquote>
<p>这里我提供了两种方法：①常规方法；②利用 API 解决。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于替换固定字符（比如空格）的情况，第二种方法其实可以使用 <code>replace</code> 方法替换，性能更好!</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> 3. 最长公共前缀</h2>
<blockquote>
<p>Leetcode:  编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 ""。</p>
</blockquote>
<p>示例 1:</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>示例 2:</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>思路很简单！先利用Arrays.sort(strs)为数组排序，再将数组第一个元素和最后一个元素的字符从前往后对比即可！</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 4. 回文串</h2>
<h3> 4.1. 最长回文串</h3>
<blockquote>
<p>LeetCode:  给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。在构造过程中，请注意区分大小写。比如<code>"Aa"</code>不能当做一个回文字符串。注
意:假设字符串的长度不会超过 1010。</p>
</blockquote>
<blockquote>
<p>回文串：“回文串”是一个正读和反读都一样的字符串，比如“level”或者“noon”等等就是回文串。——百度百科  地址：https://baike.baidu.com/item/%E5%9B%9E%E6%96%87%E4%B8%B2/1274921?fr=aladdin</p>
</blockquote>
<p>示例 1:</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们上面已经知道了什么是回文串？现在我们考虑一下可以构成回文串的两种情况：</p>
<ul>
<li>字符出现次数为双数的组合</li>
<li><strong>字符出现次数为偶数的组合+单个字符中出现次数最多且为奇数次的字符</strong> （参见 <strong><a href="https://github.com/Snailclimb/JavaGuide/issues/665" target="_blank" rel="noopener noreferrer">issue665</a></strong> ）</li>
</ul>
<p>统计字符出现的次数即可，双数才能构成回文。因为允许中间一个数单独出现，比如“abcba”，所以如果最后有字母落单，总长度可以加 1。首先将字符串转变为字符数组。然后遍历该数组，判断对应字符是否在hashset中，如果不在就加进去，如果在就让count++，然后移除该字符！这样就能找到出现次数为双数的字符个数。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4.2. 验证回文串</h3>
<blockquote>
<p>LeetCode: 给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。 说明：本题中，我们将空字符串定义为有效的回文串。</p>
</blockquote>
<p>示例 1:</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>示例 2:</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4.3. 最长回文子串</h3>
<blockquote>
<p>Leetcode: LeetCode: 最长回文子串 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。</p>
</blockquote>
<p>示例 1：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>示例 2：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>以某个元素为中心，分别计算偶数长度的回文最大长度和奇数长度的回文最大长度。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 4.4. 最长回文子序列</h3>
<blockquote>
<p>LeetCode: 最长回文子序列
给定一个字符串s，找到其中最长的回文子序列。可以假设s的最大长度为1000。
<strong>最长回文子序列和上一题最长回文子串的区别是，子串是字符串中连续的一个序列，而子序列是字符串中保持相对位置的字符序列，例如，"bbbb"可以是字符串"bbbab"的子序列但不是子串。</strong></p>
</blockquote>
<p>给定一个字符串s，找到其中最长的回文子序列。可以假设s的最大长度为1000。</p>
<p>示例 1:</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>一个可能的最长回文子序列为 "bbbb"。</p>
<p>示例 2:</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>一个可能的最长回文子序列为 "bb"。</p>
<p><strong>动态规划：</strong>  dp[i][j] = dp[i+1][j-1] + 2 if s.charAt(i) == s.charAt(j) otherwise, dp[i][j] = Math.max(dp[i+1][j], dp[i][j-1])</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 5. 括号匹配深度</h2>
<blockquote>
<p>爱奇艺 2018 秋招 Java：
一个合法的括号匹配序列有以下定义:</p>
<ol>
<li>空串""是一个合法的括号匹配序列</li>
<li>如果"X"和"Y"都是合法的括号匹配序列,"XY"也是一个合法的括号匹配序列</li>
<li>如果"X"是一个合法的括号匹配序列,那么"(X)"也是一个合法的括号匹配序列</li>
<li>每个合法的括号序列都可以由以上规则生成。</li>
</ol>
</blockquote>
<blockquote>
<p>例如: "","()","()()","((()))"都是合法的括号序列
对于一个合法的括号序列我们又有以下定义它的深度:</p>
<ol>
<li>空串""的深度是0</li>
<li>如果字符串"X"的深度是x,字符串"Y"的深度是y,那么字符串"XY"的深度为max(x,y)</li>
<li>如果"X"的深度是x,那么字符串"(X)"的深度是x+1</li>
</ol>
</blockquote>
<blockquote>
<p>例如: "()()()"的深度是1,"((()))"的深度是3。牛牛现在给你一个合法的括号序列,需要你计算出其深度。</p>
</blockquote>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>示例：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>代码如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 6. 把字符串转换成整数</h2>
<blockquote>
<p>剑指offer:  将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。</p>
</blockquote>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>剑指offer部分编程题</title>
      <link>https://javaguide.cn/cs-basics/algorithms/the-sword-refers-to-offer.html</link>
      <guid>https://javaguide.cn/cs-basics/algorithms/the-sword-refers-to-offer.html</guid>
      <source url="https://javaguide.cn/rss.xml">剑指offer部分编程题</source>
      <description>斐波那契数列 题目描述： 大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。 n&amp;lt;=39 问题分析： 可以肯定的是这一题通过递归的方式是肯定能做出来，但是这样会有一个很大的问题，那就是递归大量的重复计算会导致内存溢出。另外可以使用迭代法，用fn1和fn2保存计算过程中的结果，并复用起来。下面我会把两个方法示例代码都给出来并给出两个方法的运行时间对比。 示例代码： 采用迭代法：</description>
      <category>计算机基础</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 斐波那契数列</h2>
<p><strong>题目描述：</strong></p>
<p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。
n&lt;=39</p>
<p><strong>问题分析：</strong></p>
<p>可以肯定的是这一题通过递归的方式是肯定能做出来，但是这样会有一个很大的问题，那就是递归大量的重复计算会导致内存溢出。另外可以使用迭代法，用fn1和fn2保存计算过程中的结果，并复用起来。下面我会把两个方法示例代码都给出来并给出两个方法的运行时间对比。</p>
<p><strong>示例代码：</strong></p>
<p>采用迭代法：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>采用递归：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 跳台阶问题</h2>
<p><strong>题目描述：</strong></p>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
<p><strong>问题分析：</strong></p>
<p>正常分析法：</p>
<blockquote>
<p>a.如果两种跳法，1阶或者2阶，那么假定第一次跳的是一阶，那么剩下的是n-1个台阶，跳法是f(n-1);
b.假定第一次跳的是2阶，那么剩下的是n-2个台阶，跳法是f(n-2)
c.由a，b假设可以得出总跳法为: f(n) = f(n-1) + f(n-2)
d.然后通过实际的情况可以得出：只有一阶的时候 f(1) = 1 ,只有两阶的时候可以有 f(2) = 2</p>
</blockquote>
<p>找规律分析法：</p>
<blockquote>
<p>f(1) = 1, f(2) = 2, f(3) = 3, f(4) = 5，  可以总结出f(n) = f(n-1) + f(n-2)的规律。但是为什么会出现这样的规律呢？假设现在6个台阶，我们可以从第5跳一步到6，这样的话有多少种方案跳到5就有多少种方案跳到6，另外我们也可以从4跳两步跳到6，跳到4有多少种方案的话，就有多少种方案跳到6，其他的不能从3跳到6什么的啦，所以最后就是f(6) = f(5) + f(4)；这样子也很好理解变态跳台阶的问题了。</p>
</blockquote>
<p><strong>所以这道题其实就是斐波那契数列的问题。</strong></p>
<p>代码只需要在上一题的代码稍做修改即可。和上一题唯一不同的就是这一题的初始元素变为 1 2 3 5 8.....而上一题为1 1 2  3 5 .......。另外这一题也可以用递归做，但是递归效率太低，所以我这里只给出了迭代方式的代码。</p>
<p><strong>示例代码：</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 变态跳台阶问题</h2>
<p><strong>题目描述：</strong></p>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
<p><strong>问题分析：</strong></p>
<p>假设n&gt;=2，第一步有n种跳法：跳1级、跳2级、到跳n级
跳1级，剩下n-1级，则剩下跳法是f(n-1)
跳2级，剩下n-2级，则剩下跳法是f(n-2)
......
跳n-1级，剩下1级，则剩下跳法是f(1)
跳n级，剩下0级，则剩下跳法是f(0)
所以在n&gt;=2的情况下：
f(n)=f(n-1)+f(n-2)+...+f(1)
因为f(n-1)=f(n-2)+f(n-3)+...+f(1)
所以f(n)=2*f(n-1) 又f(1)=1,所以可得<strong>f(n)=2^(number-1)</strong></p>
<p><strong>示例代码：</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>补充：</strong></p>
<p>java中有三种移位运算符：</p>
<ol>
<li>“&lt;&lt;” :     <strong>左移运算符</strong>，等同于乘2的n次方</li>
<li>“&gt;&gt;”:     <strong>右移运算符</strong>，等同于除2的n次方</li>
<li>“&gt;&gt;&gt;” :  <strong>无符号右移运算符</strong>，不管移动前最高位是0还是1，右移后左侧产生的空位部分都以0来填充。与&gt;&gt;类似。</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 二维数组查找</h2>
<p><strong>题目描述：</strong></p>
<p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<p><strong>问题解析：</strong></p>
<p>这一道题还是比较简单的，我们需要考虑的是如何做，效率最快。这里有一种很好理解的思路：</p>
<blockquote>
<p>矩阵是有序的，从左下角来看，向上数字递减，向右数字递增，
因此从左下角开始查找，当要查找数字比左下角数字大时。右移
要查找数字比左下角数字小时，上移。这样找的速度最快。</p>
</blockquote>
<p><strong>示例代码：</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 替换空格</h2>
<p><strong>题目描述：</strong></p>
<p>请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
<p><strong>问题分析：</strong></p>
<p>这道题不难，我们可以通过循环判断字符串的字符是否为空格，是的话就利用append()方法添加追加“%20”，否则还是追加原字符。</p>
<p>或者最简单的方法就是利用：replaceAll(String regex,String replacement)方法了，一行代码就可以解决。</p>
<p><strong>示例代码：</strong></p>
<p>常规做法：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>一行代码解决：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 数值的整数次方</h2>
<p><strong>题目描述：</strong></p>
<p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p>
<p><strong>问题解析：</strong></p>
<p>这道题算是比较麻烦和难一点的一个了。我这里采用的是<strong>二分幂</strong>思想，当然也可以采用<strong>快速幂</strong>。
更具剑指offer书中细节，该题的解题思路如下：
1.当底数为0且指数&lt;0时，会出现对0求倒数的情况，需进行错误处理，设置一个全局变量；
2.判断底数是否等于0，由于base为double型，所以不能直接用==判断
3.优化求幂函数（二分幂）。
当n为偶数，a^n =（a^n/2）*（a^n/2）；
当n为奇数，a^n = a^[(n-1)/2] * a^[(n-1)/2] * a。时间复杂度O(logn)</p>
<p><strong>时间复杂度</strong>：O(logn)</p>
<p><strong>示例代码：</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当然这一题也可以采用笨方法：累乘。不过这种方法的时间复杂度为O（n），这样没有前一种方法效率高。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 调整数组顺序使奇数位于偶数前面</h2>
<p><strong>题目描述：</strong></p>
<p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p>
<p><strong>问题解析：</strong></p>
<p>这道题有挺多种解法的，给大家介绍一种我觉得挺好理解的方法：
我们首先统计奇数的个数假设为n,然后新建一个等长数组，然后通过循环判断原数组中的元素为偶数还是奇数。如果是则从数组下标0的元素开始，把该奇数添加到新数组；如果是偶数则从数组下标为n的元素开始把该偶数添加到新数组中。</p>
<p><strong>示例代码：</strong></p>
<p>时间复杂度为O（n），空间复杂度为O（n）的算法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 链表中倒数第k个节点</h2>
<p><strong>题目描述：</strong></p>
<p>输入一个链表，输出该链表中倒数第k个结点</p>
<p><strong>问题分析：</strong></p>
<p><strong>一句话概括：</strong>
两个指针一个指针p1先开始跑，指针p1跑到k-1个节点后，另一个节点p2开始跑，当p1跑到最后时，p2所指的指针就是倒数第k个节点。</p>
<p><strong>思想的简单理解：</strong>
前提假设：链表的结点个数(长度)为n。
规律一：要找到倒数第k个结点，需要向前走多少步呢？比如倒数第一个结点，需要走n步，那倒数第二个结点呢？很明显是向前走了n-1步，所以可以找到规律是找到倒数第k个结点，需要向前走n-k+1步。</p>
<p><strong>算法开始：</strong></p>
<ol>
<li>设两个都指向head的指针p1和p2，当p1走了k-1步的时候，停下来。p2之前一直不动。</li>
<li>p1的下一步是走第k步，这个时候，p2开始一起动了。至于为什么p2这个时候动呢？看下面的分析。</li>
<li>当p1走到链表的尾部时，即p1走了n步。由于我们知道p2是在p1走了k-1步才开始动的，也就是说p1和p2永远差k-1步。所以当p1走了n步时，p2走的应该是在n-(k-1)步。即p2走了n-k+1步，此时巧妙的是p2正好指向的是规律一的倒数第k个结点处。
这样是不是很好理解了呢？</li>
</ol>
<p><strong>考察内容：</strong></p>
<p>链表+代码的鲁棒性</p>
<p><strong>示例代码：</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 反转链表</h2>
<p><strong>题目描述：</strong></p>
<p>输入一个链表，反转链表后，输出链表的所有元素。</p>
<p><strong>问题分析：</strong></p>
<p>链表的很常规的一道题，这一道题思路不算难，但自己实现起来真的可能会感觉无从下手，我是参考了别人的代码。
思路就是我们根据链表的特点，前一个节点指向下一个节点的特点，把后面的节点移到前面来。
就比如下图：我们把1节点和2节点互换位置，然后再将3节点指向2节点，4节点指向3节点，这样以来下面的链表就被反转了。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/844773c7300e4373922bb1a6ae2a55a3~tplv-k3u1fbpfcp-zoom-1.image" alt="链表"></p>
<p><strong>考察内容：</strong></p>
<p>链表+代码的鲁棒性</p>
<p><strong>示例代码：</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 合并两个排序的链表</h2>
<p><strong>题目描述：</strong></p>
<p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p>
<p><strong>问题分析：</strong></p>
<p>我们可以这样分析:</p>
<ol>
<li>假设我们有两个链表 A,B；</li>
<li>A的头节点A1的值与B的头结点B1的值比较，假设A1小，则A1为头节点；</li>
<li>A2再和B1比较，假设B1小,则，A1指向B1；</li>
<li>A2再和B2比较。。。。。。。
就这样循环往复就行了，应该还算好理解。</li>
</ol>
<p><strong>考察内容：</strong></p>
<p>链表+代码的鲁棒性</p>
<p><strong>示例代码：</strong></p>
<p>非递归版本：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>递归版本：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 用两个栈实现队列</h2>
<p><strong>题目描述：</strong></p>
<p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p>
<p><strong>问题分析：</strong></p>
<p>先来回顾一下栈和队列的基本特点：
**栈：**后进先出（LIFO）
<strong>队列：</strong> 先进先出
很明显我们需要根据JDK给我们提供的栈的一些基本方法来实现。先来看一下Stack类的一些基本方法：
<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-4-4/5985000.jpg" alt="Stack类的一些常见方法"></p>
<p>既然题目给了我们两个栈，我们可以这样考虑当push的时候将元素push进stack1，pop的时候我们先把stack1的元素pop到stack2，然后再对stack2执行pop操作，这样就可以保证是先进先出的。（负[pop]负[pop]得正[先进先出]）</p>
<p><strong>考察内容：</strong></p>
<p>队列+栈</p>
<p>示例代码：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 栈的压入,弹出序列</h2>
<p><strong>题目描述：</strong></p>
<p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4，5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p>
<p><strong>题目分析：</strong></p>
<p>这道题想了半天没有思路，参考了Alias的答案，他的思路写的也很详细应该很容易看懂。
作者：Alias
https://www.nowcoder.com/questionTerminal/d77d11405cc7470d82554cb392585106
来源：牛客网</p>
<p>【思路】借用一个辅助的栈，遍历压栈顺序，先讲第一个放入栈中，这里是1，然后判断栈顶元素是不是出栈顺序的第一个元素，这里是4，很显然1≠4，所以我们继续压栈，直到相等以后开始出栈，出栈一个元素，则将出栈顺序向后移动一位，直到不相等，这样循环等压栈顺序遍历完成，如果辅助栈还不为空，说明弹出序列不是该栈的弹出顺序。</p>
<p>举例：</p>
<p>入栈1,2,3,4,5</p>
<p>出栈4,5,3,2,1</p>
<p>首先1入辅助栈，此时栈顶1≠4，继续入栈2</p>
<p>此时栈顶2≠4，继续入栈3</p>
<p>此时栈顶3≠4，继续入栈4</p>
<p>此时栈顶4＝4，出栈4，弹出序列向后一位，此时为5，,辅助栈里面是1,2,3</p>
<p>此时栈顶3≠5，继续入栈5</p>
<p>此时栈顶5=5，出栈5,弹出序列向后一位，此时为3，,辅助栈里面是1,2,3</p>
<p>….
依次执行，最后辅助栈为空。如果不为空说明弹出序列不是该栈的弹出顺序。</p>
<p><strong>考察内容：</strong></p>
<p>栈</p>
<p><strong>示例代码：</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
      <enclosure url="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/844773c7300e4373922bb1a6ae2a55a3~tplv-k3u1fbpfcp-zoom-1.image" type="image/"/>
    </item>
    <item>
      <title>布隆过滤器</title>
      <link>https://javaguide.cn/cs-basics/data-structure/bloom-filter.html</link>
      <guid>https://javaguide.cn/cs-basics/data-structure/bloom-filter.html</guid>
      <source url="https://javaguide.cn/rss.xml">布隆过滤器</source>
      <description>布隆过滤器 海量数据处理以及缓存穿透这两个场景让我认识了 布隆过滤器 ，我查阅了一些资料来了解它，但是很多现成资料并不满足我的需求，所以就决定自己总结一篇关于布隆过滤器的文章。希望通过这篇文章让更多人了解布隆过滤器，并且会实际去使用它！ 下面我们将分为几个方面来介绍布隆过滤器： 什么是布隆过滤器？ 布隆过滤器的原理介绍。 布隆过滤器使用场景。 通过 Java 编程手动实现布隆过滤器。 利用 Google 开源的 Guava 中自带的布隆过滤器。 Redis 中的布隆过滤器。</description>
      <category>计算机基础</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 布隆过滤器</h1>
<p>海量数据处理以及缓存穿透这两个场景让我认识了 布隆过滤器 ，我查阅了一些资料来了解它，但是很多现成资料并不满足我的需求，所以就决定自己总结一篇关于布隆过滤器的文章。希望通过这篇文章让更多人了解布隆过滤器，并且会实际去使用它！</p>
<p>下面我们将分为几个方面来介绍布隆过滤器：</p>
<ol>
<li>什么是布隆过滤器？</li>
<li>布隆过滤器的原理介绍。</li>
<li>布隆过滤器使用场景。</li>
<li>通过 Java 编程手动实现布隆过滤器。</li>
<li>利用 Google 开源的 Guava 中自带的布隆过滤器。</li>
<li>Redis 中的布隆过滤器。</li>
</ol>
<h2> 什么是布隆过滤器？</h2>
<p>首先，我们需要了解布隆过滤器的概念。</p>
<p>布隆过滤器（Bloom Filter）是一个叫做 Bloom 的老哥于 1970 年提出的。我们可以把它看作由二进制向量（或者说位数组）和一系列随机映射函数（哈希函数）两部分组成的数据结构。相比于我们平时常用的的 List、Map 、Set 等数据结构，它占用空间更少并且效率更高，但是缺点是其返回的结果是概率性的，而不是非常准确的。理论情况下添加到集合中的元素越多，误报的可能性就越大。并且，存放在布隆过滤器的数据不容易删除。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/布隆过滤器-bit数组.png" alt="布隆过滤器示意图"></p>
<p>位数组中的每个元素都只占用 1 bit ，并且每个元素只能是 0 或者 1。这样申请一个 100w 个元素的位数组只占用 1000000Bit / 8 = 125000 Byte = 125000/1024 kb ≈ 122kb 的空间。</p>
<p>总结：<strong>一个名叫 Bloom 的人提出了一种来检索元素是否在给定大集合中的数据结构，这种数据结构是高效且性能很好的，但缺点是具有一定的错误识别率和删除难度。并且，理论情况下，添加到集合中的元素越多，误报的可能性就越大。</strong></p>
<h2> 布隆过滤器的原理介绍</h2>
<p><strong>当一个元素加入布隆过滤器中的时候，会进行如下操作：</strong></p>
<ol>
<li>使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。</li>
<li>根据得到的哈希值，在位数组中把对应下标的值置为 1。</li>
</ol>
<p><strong>当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行如下操作：</strong></p>
<ol>
<li>对给定元素再次进行相同的哈希计算；</li>
<li>得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。</li>
</ol>
<p>举个简单的例子：</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/布隆过滤器-hash运算.png" alt="布隆过滤器hash计算"></p>
<p>如图所示，当字符串存储要加入到布隆过滤器中时，该字符串首先由多个哈希函数生成不同的哈希值，然后将对应的位数组的下标设置为 1（当位数组初始化时，所有位置均为 0）。当第二次存储相同字符串时，因为先前的对应位置已设置为 1，所以很容易知道此值已经存在（去重非常方便）。</p>
<p>如果我们需要判断某个字符串是否在布隆过滤器中时，只需要对给定字符串再次进行相同的哈希计算，得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。</p>
<p><strong>不同的字符串可能哈希出来的位置相同，这种情况我们可以适当增加位数组大小或者调整我们的哈希函数。</strong></p>
<p>综上，我们可以得出：<strong>布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。</strong></p>
<h2> 布隆过滤器使用场景</h2>
<ol>
<li>判断给定数据是否存在：比如判断一个数字是否存在于包含大量数字的数字集中（数字集很大，5 亿以上！）、 防止缓存穿透（判断请求的数据是否有效避免直接绕过缓存请求数据库）等等、邮箱的垃圾邮件过滤、黑名单功能等等。</li>
<li>去重：比如爬给定网址的时候对已经爬取过的 URL 去重。</li>
</ol>
<h2> 编码实战</h2>
<h3> 通过 Java 编程手动实现布隆过滤器</h3>
<p>我们上面已经说了布隆过滤器的原理，知道了布隆过滤器的原理之后就可以自己手动实现一个了。</p>
<p>如果你想要手动实现一个的话，你需要：</p>
<ol>
<li>一个合适大小的位数组保存数据</li>
<li>几个不同的哈希函数</li>
<li>添加元素到位数组（布隆过滤器）的方法实现</li>
<li>判断给定元素是否存在于位数组（布隆过滤器）的方法实现。</li>
</ol>
<p>下面给出一个我觉得写的还算不错的代码（参考网上已有代码改进得到，对于所有类型对象皆适用）：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>测试：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Output:</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>测试：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Output:</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 利用 Google 开源的 Guava 中自带的布隆过滤器</h3>
<p>自己实现的目的主要是为了让自己搞懂布隆过滤器的原理，Guava 中布隆过滤器的实现算是比较权威的，所以实际项目中我们不需要手动实现一个布隆过滤器。</p>
<p>首先我们需要在项目中引入 Guava 的依赖：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实际使用如下：</p>
<p>我们创建了一个最多存放 最多 1500 个整数的布隆过滤器，并且我们可以容忍误判的概率为百分之（0.01）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在我们的示例中，当 <code>mightContain()</code> 方法返回 <em>true</em> 时，我们可以 99％确定该元素在过滤器中，当过滤器返回 <em>false</em> 时，我们可以 100％确定该元素不存在于过滤器中。</p>
<p><strong>Guava 提供的布隆过滤器的实现还是很不错的（想要详细了解的可以看一下它的源码实现），但是它有一个重大的缺陷就是只能单机使用（另外，容量扩展也不容易），而现在互联网一般都是分布式的场景。为了解决这个问题，我们就需要用到 Redis 中的布隆过滤器了。</strong></p>
<h2> Redis 中的布隆过滤器</h2>
<h3> 介绍</h3>
<p>Redis v4.0 之后有了 Module（模块/插件） 功能，Redis Modules 让 Redis 可以使用外部模块扩展其功能 。布隆过滤器就是其中的 Module。详情可以查看 Redis 官方对 Redis Modules 的介绍 ：https://redis.io/modules</p>
<p>另外，官网推荐了一个 RedisBloom 作为 Redis 布隆过滤器的 Module，地址：https://github.com/RedisBloom/RedisBloom
其他还有：</p>
<ul>
<li>redis-lua-scaling-bloom-filter（lua 脚本实现）：https://github.com/erikdubbelboer/redis-lua-scaling-bloom-filter</li>
<li>pyreBloom（Python 中的快速 Redis 布隆过滤器） ：https://github.com/seomoz/pyreBloom</li>
<li>......</li>
</ul>
<p>RedisBloom 提供了多种语言的客户端支持，包括：Python、Java、JavaScript 和 PHP。</p>
<h3> 使用 Docker 安装</h3>
<p>如果我们需要体验 Redis 中的布隆过滤器非常简单，通过 Docker 就可以了！我们直接在 Google 搜索 <strong>docker redis bloomfilter</strong> 然后在排除广告的第一条搜素结果就找到了我们想要的答案（这是我平常解决问题的一种方式，分享一下），具体地址：https://hub.docker.com/r/redislabs/rebloom/ （介绍的很详细 ）。</p>
<p><strong>具体操作如下：</strong></p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 常用命令一览</h3>
<blockquote>
<p>注意： key : 布隆过滤器的名称，item : 添加的元素。</p>
</blockquote>
<ol>
<li><strong><code>BF.ADD</code></strong>：将元素添加到布隆过滤器中，如果该过滤器尚不存在，则创建该过滤器。格式：<code>BF.ADD {key} {item}</code>。</li>
<li><strong><code>BF.MADD</code></strong> : 将一个或多个元素添加到“布隆过滤器”中，并创建一个尚不存在的过滤器。该命令的操作方式<code>BF.ADD</code>与之相同，只不过它允许多个输入并返回多个值。格式：<code>BF.MADD {key} {item} [item ...]</code> 。</li>
<li><strong><code>BF.EXISTS</code></strong> : 确定元素是否在布隆过滤器中存在。格式：<code>BF.EXISTS {key} {item}</code>。</li>
<li><strong><code>BF.MEXISTS</code></strong> ： 确定一个或者多个元素是否在布隆过滤器中存在格式：<code>BF.MEXISTS {key} {item} [item ...]</code>。</li>
</ol>
<p>另外， <code>BF. RESERVE</code> 命令需要单独介绍一下：</p>
<p>这个命令的格式如下：</p>
<p><code>BF. RESERVE {key} {error_rate} {capacity} [EXPANSION expansion]</code> 。</p>
<p>下面简单介绍一下每个参数的具体含义：</p>
<ol>
<li>key：布隆过滤器的名称</li>
<li>error_rate : 期望的误报率。该值必须介于 0 到 1 之间。例如，对于期望的误报率 0.1％（1000 中为 1），error_rate 应该设置为 0.001。该数字越接近零，则每个项目的内存消耗越大，并且每个操作的 CPU 使用率越高。</li>
<li>capacity: 过滤器的容量。当实际存储的元素个数超过这个值之后，性能将开始下降。实际的降级将取决于超出限制的程度。随着过滤器元素数量呈指数增长，性能将线性下降。</li>
</ol>
<p>可选参数：</p>
<ul>
<li>expansion：如果创建了一个新的子过滤器，则其大小将是当前过滤器的大小乘以<code>expansion</code>。默认扩展值为 2。这意味着每个后续子过滤器将是前一个子过滤器的两倍。</li>
</ul>
<h3> 实际使用</h3>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
      <enclosure url="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/布隆过滤器-bit数组.png" type="image/png"/>
    </item>
    <item>
      <title>图</title>
      <link>https://javaguide.cn/cs-basics/data-structure/graph.html</link>
      <guid>https://javaguide.cn/cs-basics/data-structure/graph.html</guid>
      <source url="https://javaguide.cn/rss.xml">图</source>
      <description>图 开头还是求点赞，求转发！原创优质公众号，希望大家能让更多人看到我们的文章。 图片都是我们手绘的，可以说非常用心了！ 图是一种较为复杂的非线性结构。 为啥说其较为复杂呢？ 根据前面的内容，我们知道： 线性数据结构的元素满足唯一的线性关系，每个元素(除第一个和最后一个外)只有一个直接前趋和一个直接后继。 树形数据结构的元素之间有着明显的层次关系。 但是，图形结构的元素之间的关系是任意的。</description>
      <category>计算机基础</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 图</h1>
<blockquote>
<p>开头还是求点赞，求转发！原创优质公众号，希望大家能让更多人看到我们的文章。</p>
<p>图片都是我们手绘的，可以说非常用心了！</p>
</blockquote>
<p>图是一种较为复杂的非线性结构。 <strong>为啥说其较为复杂呢？</strong></p>
<p>根据前面的内容，我们知道：</p>
<ul>
<li>线性数据结构的元素满足唯一的线性关系，每个元素(除第一个和最后一个外)只有一个直接前趋和一个直接后继。</li>
<li>树形数据结构的元素之间有着明显的层次关系。</li>
</ul>
<p>但是，图形结构的元素之间的关系是任意的。</p>
<p><strong>何为图呢？</strong> 简单来说，图就是由顶点的有穷非空集合和顶点之间的边组成的集合。通常表示为：<strong>G(V,E)</strong>，其中，G表示一个图，V表示顶点的集合，E表示边的集合。</p>
<p>下图所展示的就是图这种数据结构，并且还是一张有向图。</p>
<p><img src="https://img-blog.csdnimg.cn/7f232c9660c54ee1ac182b7c0bf267a3.png" alt=""></p>
<p>图在我们日常生活中的例子很多！比如我们在社交软件上好友关系就可以用图来表示。</p>
<h2> 图的基本概念</h2>
<h3> 顶点</h3>
<p>图中的数据元素，我们称之为顶点，图至少有一个顶点（非空有穷集合）</p>
<p>对应到好友关系图，每一个用户就代表一个顶点。</p>
<h3> 边</h3>
<p>顶点之间的关系用边表示。</p>
<p>对应到好友关系图，两个用户是好友的话，那两者之间就存在一条边。</p>
<h3> 度</h3>
<p>度表示一个顶点包含多少条边，在有向图中，还分为出度和入度，出度表示从该顶点出去的边的条数，入度表示进入该顶点的边的条数。</p>
<p>对应到好友关系图，度就代表了某个人的好友数量。</p>
<h3> 无向图和有向图</h3>
<p>边表示的是顶点之间的关系，有的关系是双向的，比如同学关系，A是B的同学，那么B也肯定是A的同学，那么在表示A和B的关系时，就不用关注方向，用不带箭头的边表示，这样的图就是无向图。</p>
<p>有的关系是有方向的，比如父子关系，师生关系，微博的关注关系，A是B的爸爸，但B肯定不是A的爸爸，A关注B，B不一定关注A。在这种情况下，我们就用带箭头的边表示二者的关系，这样的图就是有向图。</p>
<h3> 无权图和带权图</h3>
<p>对于一个关系，如果我们只关心关系的有无，而不关心关系有多强，那么就可以用无权图表示二者的关系。</p>
<p>对于一个关系，如果我们既关心关系的有无，也关心关系的强度，比如描述地图上两个城市的关系，需要用到距离，那么就用带权图来表示，带权图中的每一条边一个数值表示权值，代表关系的强度。</p>
<p>下图就是一个带权有向图。</p>
<p></p>
<h2> 图的存储</h2>
<h3> 邻接矩阵存储</h3>
<p>邻接矩阵将图用二维矩阵存储，是一种较为直观的表示方式。</p>
<p>如果第i个顶点和第j个顶点之间有关系，且关系权值为n，则 <code>A[i][j]=n</code> 。</p>
<p>在无向图中，我们只关心关系的有无，所以当顶点i和顶点j有关系时，<code>A[i][j]</code>=1，当顶点i和顶点j没有关系时，<code>A[i][j]</code>=0。如下图所示：</p>
<p></p>
<p>值得注意的是：<strong>无向图的邻接矩阵是一个对称矩阵，因为在无向图中，顶点i和顶点j有关系，则顶点j和顶点i必有关系。</strong></p>
<p></p>
<p>邻接矩阵存储的方式优点是简单直接（直接使用一个二维数组即可），并且，在获取两个定点之间的关系的时候也非常高效（直接获取指定位置的数组元素的值即可）。但是，这种存储方式的缺点也比较明显，那就是比较浪费空间，</p>
<h3> 邻接表存储</h3>
<p>针对上面邻接矩阵比较浪费内存空间的问题，诞生了图的另外一种存储方法—<strong>邻接表</strong> 。</p>
<p>邻接链表使用一个链表来存储某个顶点的所有后继相邻顶点。对于图中每个顶点Vi，把所有邻接于Vi的顶点Vj链成一个单链表，这个单链表称为顶点Vi的 <strong>邻接表</strong>。如下图所示：</p>
<p></p>
<p></p>
<p>大家可以数一数邻接表中所存储的元素的个数以及图中边的条数，你会发现：</p>
<ul>
<li>在无向图中，邻接表元素个数等于边的条数的两倍，如左图所示的无向图中，边的条数为7，邻接表存储的元素个数为14。</li>
<li>在有向图中，邻接表元素个数等于边的条数，如右图所示的有向图中，边的条数为8，邻接表存储的元素个数为8。</li>
</ul>
<h2> 图的搜索</h2>
<h3> 广度优先搜索</h3>
<p>广度优先搜索就像水面上的波纹一样一层一层向外扩展，如下图所示：</p>
<p></p>
<p><strong>广度优先搜索的具体实现方式用到了之前所学过的线性数据结构——队列</strong> 。具体过程如下图所示：</p>
<p><strong>第1步：</strong></p>
<p></p>
<p><strong>第2步：</strong></p>
<p></p>
<p><strong>第3步：</strong></p>
<p></p>
<p><strong>第4步：</strong></p>
<p></p>
<p><strong>第5步：</strong></p>
<p></p>
<p><strong>第6步：</strong></p>
<p></p>
<h3> 深度优先搜索</h3>
<p>深度优先搜索就是“一条路走到黑”，从源顶点开始，一直走到没有后继节点，才回溯到上一顶点，然后继续“一条路走到黑”，如下图所示：</p>
<p></p>
<p><strong>和广度优先搜索类似，深度优先搜索的具体实现用到了另一种线性数据结构——栈</strong> 。具体过程如下图所示：</p>
<p><strong>第1步：</strong></p>
<p></p>
<p><strong>第2步：</strong></p>
<p></p>
<p><strong>第3步：</strong></p>
<p></p>
<p><strong>第4步：</strong></p>
<p></p>
<p><strong>第5步：</strong></p>
<p></p>
<p><strong>第6步：</strong></p>
<p></p>
]]></content:encoded>
      <enclosure url="https://img-blog.csdnimg.cn/7f232c9660c54ee1ac182b7c0bf267a3.png" type="image/png"/>
    </item>
    <item>
      <title>堆</title>
      <link>https://javaguide.cn/cs-basics/data-structure/heap.html</link>
      <guid>https://javaguide.cn/cs-basics/data-structure/heap.html</guid>
      <source url="https://javaguide.cn/rss.xml">堆</source>
      <description>堆 什么是堆 堆是一种满足以下条件的树： 堆中的每一个节点值都大于等于（或小于等于）子树中所有节点的值。或者说，任意一个节点的值都大于等于（或小于等于）所有子节点的值。 大家可以把堆(最大堆)理解为一个公司,这个公司很公平,谁能力强谁就当老大,不存在弱的人当老大,老大手底下的人一定不会比他强。这样有助于理解后续堆的操作。 !!!特别提示： 很多博客说堆是完全二叉树，其实并非如此，堆不一定是完全二叉树，只是为了方便存储和索引，我们通常用完全二叉树的形式来表示堆，事实上，广为人知的斐波那契堆和二项堆就不是完全二叉树,它们甚至都不是二叉树。 （二叉）堆是一个数组，它可以被看成是一个 近似的完全二叉树。——《算法导论》第三版</description>
      <category>计算机基础</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 堆</h1>
<h2> 什么是堆</h2>
<p>堆是一种满足以下条件的树：</p>
<p>堆中的每一个节点值都大于等于（或小于等于）子树中所有节点的值。或者说，任意一个节点的值都大于等于（或小于等于）所有子节点的值。</p>
<blockquote>
<p>大家可以把堆(最大堆)理解为一个公司,这个公司很公平,谁能力强谁就当老大,不存在弱的人当老大,老大手底下的人一定不会比他强。这样有助于理解后续堆的操作。</p>
</blockquote>
<p><strong>!!!特别提示：</strong></p>
<ul>
<li>很多博客说堆是完全二叉树，其实并非如此，<strong>堆不一定是完全二叉树</strong>，只是为了方便存储和索引，我们通常用完全二叉树的形式来表示堆，事实上，广为人知的斐波那契堆和二项堆就不是完全二叉树,它们甚至都不是二叉树。</li>
<li>（<strong>二叉</strong>）堆是一个数组，它可以被看成是一个 <strong>近似的完全二叉树</strong>。——《算法导论》第三版</li>
</ul>
<p>大家可以尝试判断下面给出的图是否是堆？</p>
<p></p>
<p>第1个和第2个是堆。第1个是最大堆，每个节点都比子树中所有节点大。第2个是最小堆，每个节点都比子树中所有节点小。</p>
<p>第3个不是，第三个中，根结点1比2和15小，而15却比3大，19比5大，不满足堆的性质。</p>
<h2> 堆的用途</h2>
<p>当我们只关心所有数据中的最大值或者最小值，存在多次获取最大值或者最小值，多次插入或删除数据时，就可以使用堆。</p>
<p>有小伙伴可能会想到用有序数组，初始化一个有序数组时间复杂度是 <code>O(nlog(n))</code>，查找最大值或者最小值时间复杂度都是 <code>O(1)</code>，但是，涉及到更新（插入或删除）数据时，时间复杂度为 <code>O(n)</code>，即使是使用复杂度为 <code>O(log(n))</code> 的二分法找到要插入或者删除的数据，在移动数据时也需要 <code>O(n)</code> 的时间复杂度。</p>
<p><strong>相对于有序数组而言，堆的主要优势在于更新数据效率较高。</strong> 堆的初始化时间复杂度为 <code>O(nlog(n))</code>，堆可以做到<code>O(1)</code>时间复杂度取出最大值或者最小值，<code>O(log(n))</code>时间复杂度插入或者删除数据，具体操作在后续章节详细介绍。</p>
<h2> 堆的分类</h2>
<p>堆分为 <strong>最大堆</strong> 和 <strong>最小堆</strong>。二者的区别在于节点的排序方式。</p>
<ul>
<li><strong>最大堆</strong> ：堆中的每一个节点的值都大于等于子树中所有节点的值</li>
<li><strong>最小堆</strong> ：堆中的每一个节点的值都小于等于子树中所有节点的值</li>
</ul>
<p>如下图所示，图1是最大堆，图2是最小堆</p>
<p></p>
<h2> 堆的存储</h2>
<p>之前介绍树的时候说过，由于完全二叉树的优秀性质，利用数组存储二叉树即节省空间，又方便索引（若根结点的序号为1，那么对于树中任意节点i，其左子节点序号为 <code>2*i</code>，右子节点序号为 <code>2*i+1</code>）。</p>
<p>为了方便存储和索引，（二叉）堆可以用完全二叉树的形式进行存储。存储的方式如下图所示：</p>
<p></p>
<h2> 堆的操作</h2>
<p>堆的更新操作主要包括两种 :  <strong>插入元素</strong> 和 <strong>删除堆顶元素</strong>。操作过程需要着重掌握和理解。</p>
<blockquote>
<p>在进入正题之前，再重申一遍，堆是一个公平的公司，有能力的人自然会走到与他能力所匹配的位置</p>
</blockquote>
<h3> 插入元素</h3>
<blockquote>
<p>插入元素，作为一个新入职的员工，初来乍到，这个员工需要从基层做起</p>
</blockquote>
<p><strong>1.将要插入的元素放到最后</strong></p>
<p></p>
<blockquote>
<p>有能力的人会逐渐升职加薪，是金子总会发光的！！！</p>
</blockquote>
<p><strong>2.从底向上，如果父结点比该元素小，则该节点和父结点交换，直到无法交换</strong></p>
<p></p>
<p></p>
<h3> 删除堆顶元素</h3>
<p>根据堆的性质可知，最大堆的堆顶元素为所有元素中最大的，最小堆的堆顶元素是所有元素中最小的。当我们需要多次查找最大元素或者最小元素的时候，可以利用堆来实现。</p>
<p>删除堆顶元素后，为了保持堆的性质，需要对堆的结构进行调整，我们将这个过程称之为"<strong>堆化</strong>"，堆化的方法分为两种：</p>
<ul>
<li>一种是自底向上的堆化，上述的插入元素所使用的就是自底向上的堆化，元素从最底部向上移动。</li>
<li>另一种是自顶向下堆化，元素由最顶部向下移动。在讲解删除堆顶元素的方法时，我将阐述这两种操作的过程，大家可以体会一下二者的不同。</li>
</ul>
<h4> 自底向上堆化</h4>
<blockquote>
<p>在堆这个公司中，会出现老大离职的现象，老大离职之后，他的位置就空出来了</p>
</blockquote>
<p>首先删除堆顶元素，使得数组中下标为1的位置空出。</p>
<p></p>
<blockquote>
<p>那么他的位置由谁来接替呢，当然是他的直接下属了，谁能力强就让谁上呗</p>
</blockquote>
<p>比较根结点的左子节点和右子节点，也就是下标为2,3的数组元素，将较大的元素填充到根结点(下标为1)的位置。</p>
<p></p>
<blockquote>
<p>这个时候又空出一个位置了，老规矩，谁有能力谁上</p>
</blockquote>
<p>一直循环比较空出位置的左右子节点，并将较大者移至空位，直到堆的最底部</p>
<p></p>
<p>这个时候已经完成了自底向上的堆化，没有元素可以填补空缺了，但是，我们可以看到数组中出现了“气泡”，这会导致存储空间的浪费。接下来我们试试自顶向下堆化。</p>
<h4> 自顶向下堆化</h4>
<p>自顶向下的堆化用一个词形容就是“石沉大海”，那么第一件事情，就是把石头抬起来，从海面扔下去。这个石头就是堆的最后一个元素，我们将最后一个元素移动到堆顶。</p>
<p></p>
<p>然后开始将这个石头沉入海底，不停与左右子节点的值进行比较，和较大的子节点交换位置，直到无法交换位置。</p>
<p></p>
<p></p>
<h3> 堆的操作总结</h3>
<ul>
<li><strong>插入元素</strong> ：先将元素放至数组末尾，再自底向上堆化，将末尾元素上浮</li>
<li><strong>删除堆顶元素</strong> ：删除堆顶元素，将末尾元素放至堆顶，再自顶向下堆化，将堆顶元素下沉。也可以自底向上堆化，只是会产生“气泡”，浪费存储空间。最好采用自顶向下堆化的方式。</li>
</ul>
<h2> 堆排序</h2>
<p>堆排序的过程分为两步：</p>
<ul>
<li>第一步是建堆，将一个无序的数组建立为一个堆</li>
<li>第二步是排序，将堆顶元素取出，然后对剩下的元素进行堆化，反复迭代，直到所有元素被取出为止。</li>
</ul>
<h3> 建堆</h3>
<p>如果你已经足够了解堆化的过程，那么建堆的过程掌握起来就比较容易了。建堆的过程就是一个对所有非叶节点的自顶向下堆化过程。</p>
<p>首先要了解哪些是非叶节点，最后一个节点的父结点及它之前的元素，都是非叶节点。也就是说，如果节点个数为n，那么我们需要对n/2到1的节点进行自顶向下（沉底）堆化。</p>
<p>具体过程如下图：</p>
<p></p>
<p>将初始的无序数组抽象为一棵树，图中的节点个数为6，所以4,5,6节点为叶节点，1,2,3节点为非叶节点，所以要对1-3号节点进行自顶向下（沉底）堆化，注意，顺序是从后往前堆化，从3号节点开始，一直到1号节点。
3号节点堆化结果：</p>
<p></p>
<p>2号节点堆化结果：</p>
<p></p>
<p>1号节点堆化结果：</p>
<p></p>
<p>至此，数组所对应的树已经成为了一个最大堆，建堆完成！</p>
<h3> 排序</h3>
<p>由于堆顶元素是所有元素中最大的，所以我们重复取出堆顶元素，将这个最大的堆顶元素放至数组末尾，并对剩下的元素进行堆化即可。</p>
<p>现在思考两个问题：</p>
<ul>
<li>删除堆顶元素后需要执行自顶向下（沉底）堆化还是自底向上（上浮）堆化？</li>
<li>取出的堆顶元素存在哪，新建一个数组存？</li>
</ul>
<p>先回答第一个问题，我们需要执行自顶向下（沉底）堆化，这个堆化一开始要将末尾元素移动至堆顶，这个时候末尾的位置就空出来了，由于堆中元素已经减小，这个位置不会再被使用，所以我们可以将取出的元素放在末尾。</p>
<p>机智的小伙伴已经发现了，这其实是做了一次交换操作，将堆顶和末尾元素调换位置，从而将取出堆顶元素和堆化的第一步(将末尾元素放至根结点位置)进行合并。</p>
<p>详细过程如下图所示：</p>
<p>取出第一个元素并堆化：</p>
<p></p>
<p>取出第二个元素并堆化：</p>
<p></p>
<p>取出第三个元素并堆化：</p>
<p></p>
<p>取出第四个元素并堆化：</p>
<p></p>
<p>取出第五个元素并堆化：</p>
<p></p>
<p>取出第六个元素并堆化：</p>
<p></p>
<p>堆排序完成！</p>
]]></content:encoded>
    </item>
    <item>
      <title>线性数据结构 :数组、链表、栈、队列</title>
      <link>https://javaguide.cn/cs-basics/data-structure/linear-data-structure.html</link>
      <guid>https://javaguide.cn/cs-basics/data-structure/linear-data-structure.html</guid>
      <source url="https://javaguide.cn/rss.xml">线性数据结构 :数组、链表、栈、队列</source>
      <description>线性数据结构 :数组、链表、栈、队列 开头还是求点赞，求转发！原创优质公众号，希望大家能让更多人看到我们的文章。 图片都是我们手绘的，可以说非常用心了！ 1. 数组 数组（Array） 是一种很常见的数据结构。它由相同类型的元素（element）组成，并且是使用一块连续的内存来存储。 我们直接可以利用元素的索引（index）可以计算出该元素对应的存储地址。 数组的特点是：提供随机访问 并且容量有限。</description>
      <category>计算机基础</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 线性数据结构 :数组、链表、栈、队列</h1>
<blockquote>
<p>开头还是求点赞，求转发！原创优质公众号，希望大家能让更多人看到我们的文章。</p>
<p>图片都是我们手绘的，可以说非常用心了！</p>
</blockquote>
<h2> 1. 数组</h2>
<p><strong>数组（Array）</strong> 是一种很常见的数据结构。它由相同类型的元素（element）组成，并且是使用一块连续的内存来存储。</p>
<p>我们直接可以利用元素的索引（index）可以计算出该元素对应的存储地址。</p>
<p>数组的特点是：<strong>提供随机访问</strong> 并且容量有限。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/数组.png" alt="数组"></p>
<h2> 2. 链表</h2>
<h3> 2.1. 链表简介</h3>
<p><strong>链表（LinkedList）</strong> 虽然是一种线性表，但是并不会按线性的顺序存储数据，使用的不是连续的内存空间来存储数据。</p>
<p>链表的插入和删除操作的复杂度为 O(1) ，只需要知道目标位置元素的上一个元素即可。但是，在查找一个节点或者访问特定位置的节点的时候复杂度为 O(n) 。</p>
<p>使用链表结构可以克服数组需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间,实现灵活的内存动态管理。但链表不会节省空间，相比于数组会占用更多的空间，因为链表中每个节点存放的还有指向其他节点的指针。除此之外，链表不具有数组随机读取的优点。</p>
<h3> 2.2. 链表分类</h3>
<p><strong>常见链表分类：</strong></p>
<ol>
<li>单链表</li>
<li>双向链表</li>
<li>循环链表</li>
<li>双向循环链表</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 2.2.1. 单链表</h4>
<p><strong>单链表</strong> 单向链表只有一个方向，结点只有一个后继指针 next 指向后面的节点。因此，链表这种数据结构通常在物理内存上是不连续的。我们习惯性地把第一个结点叫作头结点，链表通常有一个不保存任何值的 head 节点(头结点)，通过头结点我们可以遍历整个链表。尾结点通常指向 null。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/单链表2.png" alt="单链表"></p>
<h4> 2.2.2. 循环链表</h4>
<p><strong>循环链表</strong> 其实是一种特殊的单链表，和单链表不同的是循环链表的尾结点不是指向 null，而是指向链表的头结点。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/循环链表2.png" alt="循环链表"></p>
<h4> 2.2.3. 双向链表</h4>
<p><strong>双向链表</strong> 包含两个指针，一个 prev 指向前一个节点，一个 next 指向后一个节点。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/双向链表.png" alt="双向链表"></p>
<h4> 2.2.4. 双向循环链表</h4>
<p><strong>双向循环链表</strong> 最后一个节点的 next 指向 head，而 head 的 prev 指向最后一个节点，构成一个环。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/双向循环链表.png" alt="双向循环链表"></p>
<h3> 2.3. 应用场景</h3>
<ul>
<li>如果需要支持随机访问的话，链表没办法做到。</li>
<li>如果需要存储的数据元素的个数不确定，并且需要经常添加和删除数据的话，使用链表比较合适。</li>
<li>如果需要存储的数据元素的个数确定，并且不需要经常添加和删除数据的话，使用数组比较合适。</li>
</ul>
<h3> 2.4. 数组 vs 链表</h3>
<ul>
<li>数组支持随机访问，而链表不支持。</li>
<li>数组使用的是连续内存空间对 CPU 的缓存机制友好，链表则相反。</li>
<li>数组的大小固定，而链表则天然支持动态扩容。如果声明的数组过小，需要另外申请一个更大的内存空间存放数组元素，然后将原数组拷贝进去，这个操作是比较耗时的！</li>
</ul>
<h2> 3. 栈</h2>
<h3> 3.1. 栈简介</h3>
<p><strong>栈</strong> (stack)只允许在有序的线性数据集合的一端（称为栈顶 top）进行加入数据（push）和移除数据（pop）。因而按照 <strong>后进先出（LIFO, Last In First Out）</strong> 的原理运作。<strong>在栈中，push 和 pop 的操作都发生在栈顶。</strong></p>
<p>栈常用一维数组或链表来实现，用数组实现的栈叫作 <strong>顺序栈</strong> ，用链表实现的栈叫作 <strong>链式栈</strong> 。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/栈.png" alt="栈"></p>
<h3> 3.2. 栈的常见应用常见应用场景</h3>
<p>当我们我们要处理的数据只涉及在一端插入和删除数据，并且满足 <strong>后进先出（LIFO, Last In First Out）</strong> 的特性时，我们就可以使用栈这个数据结构。</p>
<h4> 3.2.1. 实现浏览器的回退和前进功能</h4>
<p>我们只需要使用两个栈(Stack1 和 Stack2)和就能实现这个功能。比如你按顺序查看了 1,2,3,4 这四个页面，我们依次把 1,2,3,4 这四个页面压入 Stack1 中。当你想回头看 2 这个页面的时候，你点击回退按钮，我们依次把 4,3 这两个页面从 Stack1 弹出，然后压入 Stack2 中。假如你又想回到页面 3，你点击前进按钮，我们将 3 页面从 Stack2 弹出，然后压入到 Stack1 中。示例图如下:</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/栈实现浏览器倒退和前进.png" alt="栈实现浏览器倒退和前进"></p>
<h4> 3.2.2. 检查符号是否成对出现</h4>
<blockquote>
<p>给定一个只包括 <code>'('</code>，<code>')'</code>，<code>'{'</code>，<code>'}'</code>，<code>'['</code>，<code>']'</code> 的字符串，判断该字符串是否有效。</p>
<p>有效字符串需满足：</p>
<ol>
<li>左括号必须用相同类型的右括号闭合。</li>
<li>左括号必须以正确的顺序闭合。</li>
</ol>
<p>比如 "()"、"()[]{}"、"{[]}" 都是有效字符串，而 "(]" 、"([)]" 则不是。</p>
</blockquote>
<p>这个问题实际是 Leetcode 的一道题目，我们可以利用栈 <code>Stack</code> 来解决这个问题。</p>
<ol>
<li>首先我们将括号间的对应规则存放在 <code>Map</code> 中，这一点应该毋容置疑；</li>
<li>创建一个栈。遍历字符串，如果字符是左括号就直接加入<code>stack</code>中，否则将<code>stack</code> 的栈顶元素与这个括号做比较，如果不相等就直接返回 false。遍历结束，如果<code>stack</code>为空，返回 <code>true</code>。</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 3.2.3. 反转字符串</h4>
<p>将字符串中的每个字符先入栈再出栈就可以了。</p>
<h4> 3.2.4. 维护函数调用</h4>
<p>最后一个被调用的函数必须先完成执行，符合栈的 <strong>后进先出（LIFO, Last In First Out）</strong> 特性。</p>
<h3> 3.3. 栈的实现</h3>
<p>栈既可以通过数组实现，也可以通过链表来实现。不管基于数组还是链表，入栈、出栈的时间复杂度都为 O(1)。</p>
<p>下面我们使用数组来实现一个栈，并且这个栈具有<code>push()</code>、<code>pop()</code>（返回栈顶元素并出栈）、<code>peek()</code> （返回栈顶元素不出栈）、<code>isEmpty()</code>、<code>size()</code>这些基本的方法。</p>
<blockquote>
<p>提示：每次入栈之前先判断栈的容量是否够用，如果不够用就用<code>Arrays.copyOf()</code>进行扩容；</p>
</blockquote>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>验证</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 4. 队列</h2>
<h3> 4.1. 队列简介</h3>
<p><strong>队列</strong> 是 <strong>先进先出( FIFO，First In, First Out)</strong> 的线性表。在具体应用中通常用链表或者数组来实现，用数组实现的队列叫作 <strong>顺序队列</strong> ，用链表实现的队列叫作 <strong>链式队列</strong> 。<strong>队列只允许在后端（rear）进行插入操作也就是 入队 enqueue，在前端（front）进行删除操作也就是出队 dequeue</strong></p>
<p>队列的操作方式和堆栈类似，唯一的区别在于队列只允许新数据在后端进行添加。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/队列.png" alt="队列"></p>
<h3> 4.2. 队列分类</h3>
<h4> 4.2.1. 单队列</h4>
<p>单队列就是常见的队列, 每次添加元素时，都是添加到队尾。单队列又分为 <strong>顺序队列（数组实现）</strong> 和 <strong>链式队列（链表实现）</strong>。</p>
<p><strong>顺序队列存在“假溢出”的问题也就是明明有位置却不能添加的情况。</strong></p>
<p>假设下图是一个顺序队列，我们将前两个元素 1,2 出队，并入队两个元素 7,8。当进行入队、出队操作的时候，front 和 rear 都会持续往后移动，当 rear 移动到最后的时候,我们无法再往队列中添加数据，即使数组中还有空余空间，这种现象就是 <strong>”假溢出“</strong> 。除了假溢出问题之外，如下图所示，当添加元素 8 的时候，rear 指针移动到数组之外（越界）。</p>
<blockquote>
<p>为了避免当只有一个元素的时候，队头和队尾重合使处理变得麻烦，所以引入两个指针，front 指针指向对头元素，rear 指针指向队列最后一个元素的下一个位置，这样当 front 等于 rear 时，此队列不是还剩一个元素，而是空队列。——From 《大话数据结构》</p>
</blockquote>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/顺序队列假溢出1.png" alt="顺序队列假溢出"></p>
<h4> 4.2.2. 循环队列</h4>
<p>循环队列可以解决顺序队列的假溢出和越界问题。解决办法就是：从头开始，这样也就会形成头尾相接的循环，这也就是循环队列名字的由来。</p>
<p>还是用上面的图，我们将 rear 指针指向数组下标为 0 的位置就不会有越界问题了。当我们再向队列中添加元素的时候， rear 向后移动。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/循环队列.png" alt="循环队列"></p>
<p>顺序队列中，我们说 <code>front==rear</code> 的时候队列为空，循环队列中则不一样，也可能为满，如上图所示。解决办法有两种：</p>
<ol>
<li>可以设置一个标志变量 <code>flag</code>,当 <code>front==rear</code> 并且 <code>flag=0</code> 的时候队列为空，当<code>front==rear</code> 并且 <code>flag=1</code> 的时候队列为满。</li>
<li>队列为空的时候就是 <code>front==rear</code> ，队列满的时候，我们保证数组还有一个空闲的位置，rear 就指向这个空闲位置，如下图所示，那么现在判断队列是否为满的条件就是： <code>(rear+1) % QueueSize= front</code> 。</li>
</ol>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/循环队列-堆满.png" alt="循环队列-队满"></p>
<h3> 4.3. 常见应用场景</h3>
<p>当我们需要按照一定顺序来处理数据的时候可以考虑使用队列这个数据结构。</p>
<ul>
<li><strong>阻塞队列：</strong> 阻塞队列可以看成在队列基础上加了阻塞操作的队列。当队列为空的时候，出队操作阻塞，当队列满的时候，入队操作阻塞。使用阻塞队列我们可以很容易实现“生产者 - 消费者“模型。</li>
<li><strong>线程池中的请求/任务队列：</strong> 线程池中没有空闲线程时，新的任务请求线程资源时，线程池该如何处理呢？答案是将这些请求放在队列中，当有空闲线程的时候，会循环中反复从队列中获取任务来执行。队列分为无界队列(基于链表)和有界队列(基于数组)。无界队列的特点就是可以一直入列，除非系统资源耗尽，比如 ：<code>FixedThreadPool</code> 使用无界队列 <code>LinkedBlockingQueue</code>。但是有界队列就不一样了，当队列满的话后面再有任务/请求就会拒绝，在 Java 中的体现就是会抛出<code>java.util.concurrent.RejectedExecutionException</code> 异常。</li>
<li>Linux 内核进程队列（按优先级排队）</li>
<li>现实生活中的派对，播放器上的播放列表;</li>
<li>消息队列</li>
<li>等等......</li>
</ul>
]]></content:encoded>
      <enclosure url="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/数组.png" type="image/png"/>
    </item>
    <item>
      <title>红黑树</title>
      <link>https://javaguide.cn/cs-basics/data-structure/red-black-tree.html</link>
      <guid>https://javaguide.cn/cs-basics/data-structure/red-black-tree.html</guid>
      <source url="https://javaguide.cn/rss.xml">红黑树</source>
      <description>红黑树 红黑树特点 : 每个节点非红即黑； 根节点总是黑色的； 每个叶子节点都是黑色的空节点（NIL节点）； 如果节点是红色的，则它的子节点必须是黑色的（反之不一定）； 从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）。 红黑树的应用 ：TreeMap、TreeSet以及JDK1.8的HashMap底层都用到了红黑树。 为什么要用红黑树？ 简单来说红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。详细了解可以查看 漫画：什么是红黑树？（也介绍到了二叉查找树，非常推荐）</description>
      <category>计算机基础</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 红黑树</h1>
<p><strong>红黑树特点</strong> :</p>
<ol>
<li>每个节点非红即黑；</li>
<li>根节点总是黑色的；</li>
<li>每个叶子节点都是黑色的空节点（NIL节点）；</li>
<li>如果节点是红色的，则它的子节点必须是黑色的（反之不一定）；</li>
<li>从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）。</li>
</ol>
<p><strong>红黑树的应用</strong> ：TreeMap、TreeSet以及JDK1.8的HashMap底层都用到了红黑树。</p>
<p><strong>为什么要用红黑树？</strong> 简单来说红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。详细了解可以查看 <a href="https://juejin.im/post/5a27c6946fb9a04509096248#comment" target="_blank" rel="noopener noreferrer">漫画：什么是红黑树？</a>（也介绍到了二叉查找树，非常推荐）</p>
<p><strong>相关阅读</strong> ：<a href="https://zhuanlan.zhihu.com/p/24367771" target="_blank" rel="noopener noreferrer">《红黑树深入剖析及Java实现》</a>（美团点评技术团队）</p>
]]></content:encoded>
    </item>
    <item>
      <title>树</title>
      <link>https://javaguide.cn/cs-basics/data-structure/tree.html</link>
      <guid>https://javaguide.cn/cs-basics/data-structure/tree.html</guid>
      <source url="https://javaguide.cn/rss.xml">树</source>
      <description>树 树就是一种类似现实生活中的树的数据结构（倒置的树）。任何一颗非空树只有一个根节点。 一棵树具有以下特点： 一棵树中的任意两个结点有且仅有唯一的一条路径连通。 一棵树如果有 n 个结点，那么它一定恰好有 n-1 条边。 一棵树不包含回路。 下图就是一颗树，并且是一颗二叉树。</description>
      <category>计算机基础</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 树</h1>
<p>树就是一种类似现实生活中的树的数据结构（倒置的树）。任何一颗非空树只有一个根节点。</p>
<p>一棵树具有以下特点：</p>
<ol>
<li>一棵树中的任意两个结点有且仅有唯一的一条路径连通。</li>
<li>一棵树如果有 n 个结点，那么它一定恰好有 n-1 条边。</li>
<li>一棵树不包含回路。</li>
</ol>
<p>下图就是一颗树，并且是一颗二叉树。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/二叉树-2.png" alt="二叉树"></p>
<p>如上图所示，通过上面这张图说明一下树中的常用概念：</p>
<ul>
<li><strong>节点</strong> ：树中的每个元素都可以统称为节点。</li>
<li><strong>根节点</strong> ：顶层节点或者说没有父节点的节点。上图中 A 节点就是根节点。</li>
<li><strong>父节点</strong> ：若一个节点含有子节点，则这个节点称为其子节点的父节点。上图中的 B 节点是 D 节点、E 节点的父节点。</li>
<li><strong>子节点</strong> ：一个节点含有的子树的根节点称为该节点的子节点。上图中 D 节点、E 节点是 B 节点的子节点。</li>
<li><strong>兄弟节点</strong> ：具有相同父节点的节点互称为兄弟节点。上图中 D 节点、E 节点的共同父节点是 B 节点，故 D 和 E 为兄弟节点。</li>
<li><strong>叶子节点</strong> ：没有子节点的节点。上图中的 D、F、H、I 都是叶子节点。</li>
<li><strong>节点的高度</strong> ：该节点到叶子节点的最长路径所包含的边数。</li>
<li><strong>节点的深度</strong> ：根节点到该节点的路径所包含的边数</li>
<li><strong>节点的层数</strong> ：节点的深度+1。</li>
<li><strong>树的高度</strong> ：根节点的高度。</li>
</ul>
<blockquote>
<p>关于树的深度和高度的定义可以看 stackoverflow 上的这个问题：<a href="https://stackoverflow.com/questions/2603692/what-is-the-difference-between-tree-depth-and-height" target="_blank" rel="noopener noreferrer">What is the difference between tree depth and height?</a> 。</p>
</blockquote>
<h2> 二叉树的分类</h2>
<p><strong>二叉树</strong>（Binary tree）是每个节点最多只有两个分支（即不存在分支度大于 2 的节点）的树结构。</p>
<p><strong>二叉树</strong> 的分支通常被称作“<strong>左子树</strong>”或“<strong>右子树</strong>”。并且，<strong>二叉树</strong> 的分支具有左右次序，不能随意颠倒。</p>
<p><strong>二叉树</strong> 的第 i 层至多拥有 <code>2^(i-1)</code> 个节点，深度为 k 的二叉树至多总共有 <code>2^(k+1)-1</code> 个节点（满二叉树的情况），至少有 2^(k) 个节点（关于节点的深度的定义国内争议比较多，我个人比较认可维基百科对<a href="https://zh.wikipedia.org/wiki/%E6%A0%91_(%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)#/%E6%9C%AF%E8%AF%AD" target="_blank" rel="noopener noreferrer">节点深度的定义</a>）。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/image-20220119112736158.png" alt=""></p>
<h3> 满二叉树</h3>
<p>一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是 <strong>满二叉树</strong>。也就是说，如果一个二叉树的层数为 K，且结点总数是(2^k) -1 ，则它就是 <strong>满二叉树</strong>。如下图所示：</p>
<p></p>
<h3> 完全二叉树</h3>
<p>除最后一层外，若其余层都是满的，并且最后一层或者是满的，或者是在右边缺少连续若干节点，则这个二叉树就是 <strong>完全二叉树</strong> 。</p>
<p>大家可以想象为一棵树从根结点开始扩展，扩展完左子节点才能开始扩展右子节点，每扩展完一层，才能继续扩展下一层。如下图所示：</p>
<p></p>
<p>完全二叉树有一个很好的性质：<strong>父结点和子节点的序号有着对应关系。</strong></p>
<p>细心的小伙伴可能发现了，当根节点的值为 1 的情况下，若父结点的序号是 i，那么左子节点的序号就是 2i，右子节点的序号是 2i+1。这个性质使得完全二叉树利用数组存储时可以极大地节省空间，以及利用序号找到某个节点的父结点和子节点，后续二叉树的存储会详细介绍。</p>
<h3> 平衡二叉树</h3>
<p><strong>平衡二叉树</strong> 是一棵二叉排序树，且具有以下性质：</p>
<ol>
<li>可以是一棵空树</li>
<li>如果不是空树，它的左右两个子树的高度差的绝对值不超过 1，并且左右两个子树都是一棵平衡二叉树。</li>
</ol>
<p>平衡二叉树的常用实现方法有 <strong>红黑树</strong>、<strong>AVL 树</strong>、<strong>替罪羊树</strong>、<strong>加权平衡树</strong>、<strong>伸展树</strong> 等。</p>
<p>在给大家展示平衡二叉树之前，先给大家看一棵树：</p>
<p></p>
<p><strong>你管这玩意儿叫树？？？</strong></p>
<p>没错，这玩意儿还真叫树，只不过这棵树已经退化为一个链表了，我们管它叫 <strong>斜树</strong>。</p>
<p><strong>如果这样，那我为啥不直接用链表呢?</strong></p>
<p>谁说不是呢？</p>
<p>二叉树相比于链表，由于父子节点以及兄弟节点之间往往具有某种特殊的关系，这种关系使得我们在树中对数据进行<strong>搜索</strong>和<strong>修改</strong>时，相对于链表更加快捷便利。</p>
<p>但是，如果二叉树退化为一个链表了，那么那么树所具有的优秀性质就难以表现出来，效率也会大打折，为了避免这样的情况，我们希望每个做 “家长”（父结点） 的，都 <strong>一碗水端平</strong>，分给左儿子和分给右儿子的尽可能一样多，相差最多不超过一层，如下图所示：</p>
<p></p>
<h2> 二叉树的存储</h2>
<p>二叉树的存储主要分为 <strong>链式存储</strong> 和 <strong>顺序存储</strong> 两种：</p>
<h3> 链式存储</h3>
<p>和链表类似，二叉树的链式存储依靠指针将各个节点串联起来，不需要连续的存储空间。</p>
<p>每个节点包括三个属性：</p>
<ul>
<li>数据 data。data 不一定是单一的数据，根据不同情况，可以是多个具有不同类型的数据。</li>
<li>左节点指针 left</li>
<li>右节点指针 right。</li>
</ul>
<p>可是 JAVA 没有指针啊！</p>
<p>那就直接引用对象呗（别问我对象哪里找）</p>
<p></p>
<h3> 顺序存储</h3>
<p>顺序存储就是利用数组进行存储，数组中的每一个位置仅存储节点的 data，不存储左右子节点的指针，子节点的索引通过数组下标完成。根结点的序号为 1，对于每个节点 Node，假设它存储在数组中下标为 i 的位置，那么它的左子节点就存储在 2i 的位置，它的右子节点存储在下标为 2i+1 的位置。</p>
<p>一棵完全二叉树的数组顺序存储如下图所示：</p>
<p></p>
<p>大家可以试着填写一下存储如下二叉树的数组，比较一下和完全二叉树的顺序存储有何区别：</p>
<p></p>
<p>可以看到，如果我们要存储的二叉树不是完全二叉树，在数组中就会出现空隙，导致内存利用率降低</p>
<h2> 二叉树的遍历</h2>
<h3> 先序遍历</h3>
<p></p>
<p>二叉树的先序遍历，就是先输出根结点，再遍历左子树，最后遍历右子树，遍历左子树和右子树的时候，同样遵循先序遍历的规则，也就是说，我们可以递归实现先序遍历。</p>
<p>代码如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 中序遍历</h3>
<p></p>
<p>二叉树的中序遍历，就是先递归中序遍历左子树，再输出根结点的值，再递归中序遍历右子树，大家可以想象成一巴掌把树压扁，父结点被拍到了左子节点和右子节点的中间，如下图所示：</p>
<p></p>
<p>代码如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 后序遍历</h3>
<p></p>
<p>二叉树的后序遍历，就是先递归后序遍历左子树，再递归后序遍历右子树，最后输出根结点的值</p>
<p>代码如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
      <enclosure url="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/二叉树-2.png" type="image/png"/>
    </item>
    <item>
      <title>Linux 基础知识总结</title>
      <link>https://javaguide.cn/cs-basics/operating-system/linux-intro.html</link>
      <guid>https://javaguide.cn/cs-basics/operating-system/linux-intro.html</guid>
      <source url="https://javaguide.cn/rss.xml">Linux 基础知识总结</source>
      <description>简单介绍一下 Java 程序员必知的 Linux 的一些概念以及常见命令。 从认识操作系统开始 正式开始 Linux 之前，简单花一点点篇幅科普一下操作系统相关的内容。 操作系统简介 我通过以下四点介绍什么是操作系统： 操作系统（Operating System，简称 OS）是管理计算机硬件与软件资源的程序，是计算机的基石。 操作系统本质上是一个运行在计算机上的软件程序 ，用于管理计算机硬件和软件资源。 举例：运行在你电脑上的所有应用程序都通过操作系统来调用系统内存以及磁盘等等硬件。 操作系统存在屏蔽了硬件层的复杂性。 操作系统就像是硬件使用的负责人，统筹着各种相关事项。 操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理。</description>
      <category>计算机基础</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<p>简单介绍一下 Java 程序员必知的 Linux 的一些概念以及常见命令。</p>
<h2> 从认识操作系统开始</h2>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-8/image-20200807161118901.png" alt=""></p>
<p>正式开始 Linux 之前，简单花一点点篇幅科普一下操作系统相关的内容。</p>
<h3> 操作系统简介</h3>
<p>我通过以下四点介绍什么是操作系统：</p>
<ol>
<li><strong>操作系统（Operating System，简称 OS）是管理计算机硬件与软件资源的程序，是计算机的基石。</strong></li>
<li><strong>操作系统本质上是一个运行在计算机上的软件程序 ，用于管理计算机硬件和软件资源。</strong> 举例：运行在你电脑上的所有应用程序都通过操作系统来调用系统内存以及磁盘等等硬件。</li>
<li><strong>操作系统存在屏蔽了硬件层的复杂性。</strong> 操作系统就像是硬件使用的负责人，统筹着各种相关事项。</li>
<li><strong>操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理</strong>。</li>
</ol>
<blockquote>
<p>内核（Kernel）在后文中会提到。</p>
</blockquote>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-8/Kernel_Layout.png" alt="Kernel_Layout"></p>
<h3> 操作系统简单分类</h3>
<h4> Windows</h4>
<p>目前最流行的个人桌面操作系统 ，不做多的介绍，大家都清楚。界面简单易操作，软件生态非常好。</p>
<p><em>玩玩电脑游戏还是必须要有 Windows 的，所以我现在是一台 Windows 用于玩游戏，一台 Mac 用于平时日常开发和学习使用。</em></p>
<p></p>
<h4> Unix</h4>
<p>最早的多用户、多任务操作系统 。后面崛起的 Linux 在很多方面都参考了 Unix。</p>
<p>目前这款操作系统已经逐渐逐渐退出操作系统的舞台。</p>
<p></p>
<h4> Linux</h4>
<p><strong>Linux 是一套免费使用、开源的类 Unix 操作系统。</strong> Linux 存在着许多不同的发行版本，但它们都使用了 <strong>Linux 内核</strong> 。</p>
<blockquote>
<p>严格来讲，Linux 这个词本身只表示 Linux 内核，在 GNU/Linux 系统中，Linux 实际就是 Linux 内核，而该系统的其余部分主要是由 GNU 工程编写和提供的程序组成。单独的 Linux 内核并不能成为一个可以正常工作的操作系统。</p>
<p><strong>很多人更倾向使用 “GNU/Linux” 一词来表达人们通常所说的 “Linux”。</strong></p>
</blockquote>
<p></p>
<h4> Mac OS</h4>
<p>苹果自家的操作系统，编程体验和 Linux 相当，但是界面、软件生态以及用户体验各方面都要比 Linux 操作系统更好。</p>
<p></p>
<h3> 操作系统的内核（Kernel）</h3>
<p>我们先来看看维基百科对于内核的解释，我觉得总结的非常好！</p>
<blockquote>
<p><strong>内核</strong>（英语：Kernel，又称核心）在计算机科学中是一个用来管理软件发出的数据 I/O（输入与输出）要求的电脑程序，将这些要求转译为数据处理的指令并交由中央处理器（CPU）及电脑中其他电子组件进行处理，是现代操作系统中最基本的部分。它是为众多应用程序提供对计算机硬件的安全访问的一部分软件，这种访问是有限的，并由内核决定一个程序在什么时候对某部分硬件操作多长时间。 <strong>直接对硬件操作是非常复杂的。所以内核通常提供一种硬件抽象的方法，来完成这些操作。有了这个，通过进程间通信机制及系统调用，应用进程可间接控制所需的硬件资源（特别是处理器及 IO 设备）。</strong></p>
<p>早期计算机系统的设计中，还没有操作系统的内核这个概念。随着计算机系统的发展，操作系统内核的概念才渐渐明晰起来了!</p>
</blockquote>
<p>简单概括两点：</p>
<ol>
<li><strong>操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理。</strong></li>
<li><strong>操作系统的内核是连接应用程序和硬件的桥梁，决定着操作系统的性能和稳定性。</strong></li>
</ol>
<h3> 中央处理器（CPU，Central Processing Unit）</h3>
<p>关于 CPU 简单概括三点：</p>
<ol>
<li><strong>CPU 是一台计算机的运算核心（Core）+控制核心（ Control Unit），可以称得上是计算机的大脑。</strong></li>
<li><strong>CPU 主要包括两个部分：控制器+运算器。</strong></li>
<li><strong>CPU 的根本任务就是执行指令，对计算机来说最终都是一串由“0”和“1”组成的序列。</strong></li>
</ol>
<h3> CPU vs Kernel(内核)</h3>
<p>很多人容易无法区分操作系统的内核（Kernel）和中央处理器（CPU），你可以简单从下面两点来区别：</p>
<ol>
<li>操作系统的内核（Kernel）属于操作系统层面，而 CPU 属于硬件。</li>
<li>CPU 主要提供运算，处理各种指令的能力。内核（Kernel）主要负责系统管理比如内存管理，它屏蔽了对硬件的操作。</li>
</ol>
<p>下图清晰说明了应用程序、内核、CPU 这三者的关系。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-8/Kernel_Layout.png" alt="Kernel_Layout"></p>
<h3> 系统调用</h3>
<p>介绍系统调用之前，我们先来了解一下用户态和系统态。</p>
<p>根据进程访问资源的特点，我们可以把进程在系统上的运行分为两个级别：</p>
<ol>
<li><strong>用户态(user mode)</strong> : 用户态运行的进程或可以直接读取用户程序的数据。</li>
<li><strong>系统态(kernel mode)</strong>: 可以简单的理解系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制。</li>
</ol>
<p><strong>说了用户态和系统态之后，那么什么是系统调用呢？</strong></p>
<p>我们运行的程序基本都是运行在用户态，如果我们调用操作系统提供的系统态级别的子功能咋办呢？那就需要系统调用了！</p>
<p>也就是说在我们运行的用户程序中，凡是与系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。</p>
<p>这些系统调用按功能大致可分为如下几类：</p>
<ul>
<li><strong>设备管理</strong> ：完成设备的请求或释放，以及设备启动等功能。</li>
<li><strong>文件管理</strong> ：完成文件的读、写、创建及删除等功能。</li>
<li><strong>进程控制</strong> ：完成进程的创建、撤销、阻塞及唤醒等功能。</li>
<li><strong>进程通信</strong> ：完成进程之间的消息传递或信号传递等功能。</li>
<li><strong>内存管理</strong> ：完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。</li>
</ul>
<p>我在网上找了一个图，通过这个图可以很清晰的说明用户程序、系统调用、内核和硬件之间的关系。（<em>太难了~木有自己画</em>）</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-8/L181kk2Eou-compress.jpg" alt=""></p>
<h2> 初探 Linux</h2>
<h3> Linux 简介</h3>
<p>我们上面已经简单了 Linux，这里只强调三点。</p>
<ul>
<li><strong>类 Unix 系统</strong> ： Linux 是一种自由、开放源码的类似 Unix 的操作系统</li>
<li><strong>Linux 本质是指 Linux 内核</strong> ： 严格来讲，Linux 这个词本身只表示 Linux 内核，单独的 Linux 内核并不能成为一个可以正常工作的操作系统。所以，就有了各种 Linux 发行版。</li>
<li><strong>Linux 之父(林纳斯·本纳第克特·托瓦兹 Linus Benedict Torvalds)</strong> ： 一个编程领域的传奇式人物，真大佬！我辈崇拜敬仰之楷模。他是 <strong>Linux 内核</strong> 的最早作者，随后发起了这个开源项目，担任 Linux 内核的首要架构师。他还发起了 Git 这个开源项目，并为主要的开发者。</li>
</ul>
<p></p>
<h3> Linux 诞生</h3>
<p>1989 年，Linus Torvalds 进入芬兰陆军新地区旅，服 11 个月的国家义务兵役，军衔为少尉，主要服务于计算机部门，任务是弹道计算。服役期间，购买了安德鲁·斯图尔特·塔能鲍姆所著的教科书及 minix 源代码，开始研究操作系统。1990 年，他退伍后回到大学，开始接触 Unix。</p>
<blockquote>
<p><strong>Minix</strong> 是一个迷你版本的类 Unix 操作系统，由塔能鲍姆教授为了教学之用而创作，采用微核心设计。它启发了 Linux 内核的创作。</p>
</blockquote>
<p>1991 年，Linus Torvalds 开源了 Linux 内核。Linux 以一只可爱的企鹅作为标志，象征着敢作敢为、热爱生活。</p>
<p></p>
<h3> 常见 Linux 发行版本有哪些？</h3>
<p>Linus Torvalds 开源的只是 Linux 内核，我们上面也提到了操作系统内核的作用。一些组织或厂商将 Linux 内核与各种软件和文档包装起来，并提供系统安装界面和系统配置、设定与管理工具，就构成了 Linux 的发行版本。</p>
<blockquote>
<p>内核主要负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理。</p>
</blockquote>
<p>Linux 的发行版本可以大体分为两类：</p>
<ul>
<li>商业公司维护的发行版本，以著名的 Red Hat 为代表，比较典型的有 CentOS 。</li>
<li>社区组织维护的发行版本，以 Debian 为代表，比较典型的有 Ubuntu、Debian。</li>
</ul>
<p>对于初学者学习 Linux ,推荐选择 CentOS 。</p>
<h2> Linux 文件系统概览</h2>
<h3> Linux 文件系统简介</h3>
<p><strong>在 Linux 操作系统中，所有被操作系统管理的资源，例如网络接口卡、磁盘驱动器、打印机、输入输出设备、普通文件或是目录都被看作是一个文件。</strong> 也就是说在 Linux 系统中有一个重要的概念：<strong>一切都是文件</strong>。</p>
<p>其实这是 UNIX 哲学的一个体现，在 UNIX 系统中，把一切资源都看作是文件，Linux 的文件系统也是借鉴 UNIX 文件系统而来。</p>
<h3> inode 介绍</h3>
<p><strong>inode 是 linux/unix 文件系统的基础。那么，inode 是什么?有什么作用呢?</strong></p>
<p>硬盘的最小存储单位是扇区(Sector)，块(block)由多个扇区组成。文件数据存储在块中。块的最常见的大小是 4kb，约为 8 个连续的扇区组成（每个扇区存储 512 字节）。一个文件可能会占用多个 block，但是一个块只能存放一个文件。</p>
<p>虽然，我们将文件存储在了块(block)中，但是我们还需要一个空间来存储文件的 <strong>元信息 metadata</strong> ：如某个文件被分成几块、每一块在的地址、文件拥有者，创建时间，权限，大小等。这种 <strong>存储文件元信息的区域就叫 inode</strong>，译为索引节点：<strong>i（index）+node</strong>。 每个文件都有一个 inode，存储文件的元信息。</p>
<p>可以使用 <code>stat</code> 命令可以查看文件的 inode 信息。每个 inode 都有一个号码，Linux/Unix 操作系统不使用文件名来区分文件，而是使用 inode 号码区分不同的文件。</p>
<p>简单来说：inode 就是用来维护某个文件被分成几块、每一块在的地址、文件拥有者，创建时间，权限，大小等信息。</p>
<p>简单总结一下：</p>
<ul>
<li><strong>inode</strong> ：记录文件的属性信息，可以使用 stat 命令查看 inode 信息。</li>
<li><strong>block</strong> ：实际文件的内容，如果一个文件大于一个块时候，那么将占用多个 block，但是一个块只能存放一个文件。（因为数据是由 inode 指向的，如果有两个文件的数据存放在同一个块中，就会乱套了）</li>
</ul>
<p></p>
<h3> Linux 文件类型</h3>
<p>Linux 支持很多文件类型，其中非常重要的文件类型有: <strong>普通文件</strong>，<strong>目录文件</strong>，<strong>链接文件</strong>，<strong>设备文件</strong>，<strong>管道文件</strong>，<strong>Socket 套接字文件</strong>等。</p>
<ul>
<li><strong>普通文件（-）</strong> ： 用于存储信息和数据， Linux 用户可以根据访问权限对普通文件进行查看、更改和删除。比如：图片、声音、PDF、text、视频、源代码等等。</li>
<li><strong>目录文件（d，directory file）</strong> ：目录也是文件的一种，用于表示和管理系统中的文件，目录文件中包含一些文件名和子目录名。打开目录事实上就是打开目录文件。</li>
<li><strong>符号链接文件（l，symbolic link）</strong> ：保留了指向文件的地址而不是文件本身。</li>
<li><strong>字符设备（c，char）</strong> ：用来访问字符设备比如键盘。</li>
<li><strong>设备文件（b，block）</strong> ： 用来访问块设备比如硬盘、软盘。</li>
<li><strong>管道文件(p,pipe)</strong> : 一种特殊类型的文件，用于进程之间的通信。</li>
<li><strong>套接字(s,socket)</strong> ：用于进程间的网络通信，也可以用于本机之间的非网络通信。</li>
</ul>
<h3> Linux 目录树</h3>
<p>所有可操作的计算机资源都存在于目录树这个结构中，对计算资源的访问，可以看做是对这棵目录树的访问。</p>
<p><strong>Linux 的目录结构如下：</strong></p>
<p>Linux 文件系统的结构层次鲜明，就像一棵倒立的树，最顶层是其根目录：
</p>
<p><strong>常见目录说明：</strong></p>
<ul>
<li><strong>/bin：</strong> 存放二进制可执行文件(ls、cat、mkdir 等)，常用命令一般都在这里；</li>
<li><strong>/etc：</strong> 存放系统管理和配置文件；</li>
<li><strong>/home：</strong> 存放所有用户文件的根目录，是用户主目录的基点，比如用户 user 的主目录就是/home/user，可以用~user 表示；</li>
<li><strong>/usr ：</strong> 用于存放系统应用程序；</li>
<li><strong>/opt：</strong> 额外安装的可选应用程序包所放置的位置。一般情况下，我们可以把 tomcat 等都安装到这里；</li>
<li><strong>/proc：</strong> 虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息；</li>
<li><strong>/root：</strong> 超级用户（系统管理员）的主目录（特权阶级^o^）；</li>
<li><strong>/sbin:</strong> 存放二进制可执行文件，只有 root 才能访问。这里存放的是系统管理员使用的系统级别的管理命令和程序。如 ifconfig 等；</li>
<li><strong>/dev：</strong> 用于存放设备文件；</li>
<li><strong>/mnt：</strong> 系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系统；</li>
<li><strong>/boot：</strong> 存放用于系统引导时使用的各种文件；</li>
<li><strong>/lib ：</strong> 存放着和系统运行相关的库文件 ；</li>
<li><strong>/tmp：</strong> 用于存放各种临时文件，是公用的临时文件存储点；</li>
<li><strong>/var：</strong> 用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说各种服务的日志文件（系统启动日志等。）等；</li>
<li><strong>/lost+found：</strong> 这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows 下叫什么.chk）就在这里。</li>
</ul>
<h2> Linux 基本命令</h2>
<p>下面只是给出了一些比较常用的命令。</p>
<p>推荐一个 Linux 命令快查网站，非常不错，大家如果遗忘某些命令或者对某些命令不理解都可以在这里得到解决。Linux 命令在线速查手册：https://www.w3xue.com/manual/linux/ 。</p>
<p>另外，<a href="https://www.shell.how/" target="_blank" rel="noopener noreferrer">shell.how</a> 这个网站可以用来解释常见命令的意思，对你学习 Linux 基本命令以及其他常用命令（如 Git、NPM）。</p>
<h3> 目录切换命令</h3>
<ul>
<li><strong><code>cd usr</code>：</strong> 切换到该目录下 usr 目录</li>
<li><strong><code>cd ..（或cd../）</code>：</strong> 切换到上一层目录</li>
<li><strong><code>cd /</code>：</strong> 切换到系统根目录</li>
<li><strong><code>cd ~</code>：</strong> 切换到用户主目录</li>
<li><strong><code>cd -</code>：</strong> 切换到上一个操作所在目录</li>
</ul>
<h3> 目录的操作命令(增删改查)</h3>
<ul>
<li><strong><code>mkdir 目录名称</code>：</strong> 增加目录。</li>
<li><strong><code>ls/ll</code></strong>（ll 是 ls -l 的别名，ll 命令可以看到该目录下的所有目录和文件的详细信息）：查看目录信息。</li>
<li><strong><code>find 目录 参数</code>：</strong> 寻找目录（查）。示例：① 列出当前目录及子目录下所有文件和文件夹: <code>find .</code>；② 在<code>/home</code>目录下查找以.txt 结尾的文件名:<code>find /home -name "*.txt"</code> ,忽略大小写: <code>find /home -iname "*.txt"</code> ；③ 当前目录及子目录下查找所有以.txt 和.pdf 结尾的文件:<code>find . \( -name "*.txt" -o -name "*.pdf" \)</code>或<code>find . -name "*.txt" -o -name "*.pdf"</code>。</li>
<li><strong><code>mv 目录名称 新目录名称</code>：</strong> 修改目录的名称（改）。注意：mv 的语法不仅可以对目录进行重命名而且也可以对各种文件，压缩包等进行 重命名的操作。mv 命令用来对文件或目录重新命名，或者将文件从一个目录移到另一个目录中。后面会介绍到 mv 命令的另一个用法。</li>
<li><strong><code>mv 目录名称 目录的新位置</code>：</strong> 移动目录的位置---剪切（改）。注意：mv 语法不仅可以对目录进行剪切操作，对文件和压缩包等都可执行剪切操作。另外 mv 与 cp 的结果不同，mv 好像文件“搬家”，文件个数并未增加。而 cp 对文件进行复制，文件个数增加了。</li>
<li><strong><code>cp -r 目录名称 目录拷贝的目标位置</code>：</strong> 拷贝目录（改），-r 代表递归拷贝 。注意：cp 命令不仅可以拷贝目录还可以拷贝文件，压缩包等，拷贝文件和压缩包时不 用写-r 递归。</li>
<li><strong><code>rm [-rf] 目录</code> :</strong> 删除目录（删）。注意：rm 不仅可以删除目录，也可以删除其他文件或压缩包，为了增强大家的记忆， 无论删除任何目录或文件，都直接使用<code>rm -rf</code> 目录/文件/压缩包。</li>
</ul>
<h3> 文件的操作命令(增删改查)</h3>
<ul>
<li><strong><code>touch 文件名称</code>:</strong> 文件的创建（增）。</li>
<li><strong><code>cat/more/less/tail 文件名称</code></strong> ：文件的查看（查） 。命令 <code>tail -f 文件</code> 可以对某个文件进行动态监控，例如 tomcat 的日志文件， 会随着程序的运行，日志会变化，可以使用 <code>tail -f catalina-2016-11-11.log</code> 监控 文 件的变化 。</li>
<li><strong><code>vim 文件</code>：</strong> 修改文件的内容（改）。vim 编辑器是 Linux 中的强大组件，是 vi 编辑器的加强版，vim 编辑器的命令和快捷方式有很多，但此处不一一阐述，大家也无需研究的很透彻，使用 vim 编辑修改文件的方式基本会使用就可以了。在实际开发中，使用 vim 编辑器主要作用就是修改配置文件，下面是一般步骤： <code>vim 文件------&gt;进入文件-----&gt;命令模式------&gt;按i进入编辑模式-----&gt;编辑文件 -------&gt;按Esc进入底行模式-----&gt;输入：wq/q!</code> （输入 wq 代表写入内容并退出，即保存；输入 q!代表强制退出不保存）。</li>
<li><strong><code>rm -rf 文件</code>：</strong> 删除文件（删）。</li>
</ul>
<h3> 压缩文件的操作命令</h3>
<p><strong>1）打包并压缩文件：</strong></p>
<p>Linux 中的打包文件一般是以.tar 结尾的，压缩的命令一般是以.gz 结尾的。而一般情况下打包和压缩是一起进行的，打包并压缩后的文件的后缀名一般.tar.gz。
命令：<code>tar -zcvf 打包压缩后的文件名 要打包压缩的文件</code> ，其中：</p>
<ul>
<li>z：调用 gzip 压缩命令进行压缩</li>
<li>c：打包文件</li>
<li>v：显示运行过程</li>
<li>f：指定文件名</li>
</ul>
<p>比如：假如 test 目录下有三个文件分别是：aaa.txt bbb.txt ccc.txt，如果我们要打包 test 目录并指定压缩后的压缩包名称为 test.tar.gz 可以使用命令：<strong><code>tar -zcvf test.tar.gz aaa.txt bbb.txt ccc.txt</code> 或 <code>tar -zcvf test.tar.gz /test/</code></strong></p>
<p><strong>2）解压压缩包：</strong></p>
<p>命令：<code>tar [-xvf] 压缩文件</code></p>
<p>其中：x：代表解压</p>
<p>示例：</p>
<ul>
<li>将 /test 下的 test.tar.gz 解压到当前目录下可以使用命令：<strong><code>tar -xvf test.tar.gz</code></strong></li>
<li>将 /test 下的 test.tar.gz 解压到根目录/usr 下:<strong><code>tar -xvf test.tar.gz -C /usr</code></strong>（- C 代表指定解压的位置）</li>
</ul>
<h3> Linux 的权限命令</h3>
<p>操作系统中每个文件都拥有特定的权限、所属用户和所属组。权限是操作系统用来限制资源访问的机制，在 Linux 中权限一般分为读(readable)、写(writable)和执行(excutable)，分为三组。分别对应文件的属主(owner)，属组(group)和其他用户(other)，通过这样的机制来限制哪些用户、哪些组可以对特定的文件进行什么样的操作。</p>
<p>通过 <strong><code>ls -l</code></strong> 命令我们可以 查看某个目录下的文件或目录的权限</p>
<p>示例：在随意某个目录下<code>ls -l</code></p>
<p></p>
<p>第一列的内容的信息解释如下：</p>
<p></p>
<blockquote>
<p>下面将详细讲解文件的类型、Linux 中权限以及文件有所有者、所在组、其它组具体是什么？</p>
</blockquote>
<p><strong>文件的类型：</strong></p>
<ul>
<li>d： 代表目录</li>
<li>-： 代表文件</li>
<li>l： 代表软链接（可以认为是 window 中的快捷方式）</li>
</ul>
<p><strong>Linux 中权限分为以下几种：</strong></p>
<ul>
<li>r：代表权限是可读，r 也可以用数字 4 表示</li>
<li>w：代表权限是可写，w 也可以用数字 2 表示</li>
<li>x：代表权限是可执行，x 也可以用数字 1 表示</li>
</ul>
<p><strong>文件和目录权限的区别：</strong></p>
<p>对文件和目录而言，读写执行表示不同的意义。</p>
<p>对于文件：</p>
<table>
<thead>
<tr>
<th style="text-align:left">权限名称</th>
<th style="text-align:right">可执行操作</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">r</td>
<td style="text-align:right">可以使用 cat 查看文件的内容</td>
</tr>
<tr>
<td style="text-align:left">w</td>
<td style="text-align:right">可以修改文件的内容</td>
</tr>
<tr>
<td style="text-align:left">x</td>
<td style="text-align:right">可以将其运行为二进制文件</td>
</tr>
</tbody>
</table>
<p>对于目录：</p>
<table>
<thead>
<tr>
<th style="text-align:left">权限名称</th>
<th style="text-align:right">可执行操作</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">r</td>
<td style="text-align:right">可以查看目录下列表</td>
</tr>
<tr>
<td style="text-align:left">w</td>
<td style="text-align:right">可以创建和删除目录下文件</td>
</tr>
<tr>
<td style="text-align:left">x</td>
<td style="text-align:right">可以使用 cd 进入目录</td>
</tr>
</tbody>
</table>
<p>需要注意的是： <strong>超级用户可以无视普通用户的权限，即使文件目录权限是 000，依旧可以访问。</strong></p>
<p><strong>在 linux 中的每个用户必须属于一个组，不能独立于组外。在 linux 中每个文件有所有者、所在组、其它组的概念。</strong></p>
<ul>
<li><strong>所有者(u)</strong> ：一般为文件的创建者，谁创建了该文件，就天然的成为该文件的所有者，用 <code>ls ‐ahl</code> 命令可以看到文件的所有者 也可以使用 chown 用户名 文件名来修改文件的所有者 。</li>
<li><strong>文件所在组(g)</strong> ：当某个用户创建了一个文件后，这个文件的所在组就是该用户所在的组用 <code>ls ‐ahl</code>命令可以看到文件的所有组也可以使用 chgrp 组名 文件名来修改文件所在的组。</li>
<li><strong>其它组(o)</strong> ：除开文件的所有者和所在组的用户外，系统的其它用户都是文件的其它组。</li>
</ul>
<blockquote>
<p>我们再来看看如何修改文件/目录的权限。</p>
</blockquote>
<p><strong>修改文件/目录的权限的命令：<code>chmod</code></strong></p>
<p>示例：修改/test 下的 aaa.txt 的权限为文件所有者有全部权限，文件所有者所在的组有读写权限，其他用户只有读的权限。</p>
<p><strong><code>chmod u=rwx,g=rw,o=r aaa.txt</code></strong> 或者 <strong><code>chmod 764 aaa.txt</code></strong></p>
<p></p>
<p><strong>补充一个比较常用的东西:</strong></p>
<p>假如我们装了一个 zookeeper，我们每次开机到要求其自动启动该怎么办？</p>
<ol>
<li>新建一个脚本 zookeeper</li>
<li>为新建的脚本 zookeeper 添加可执行权限，命令是:<code>chmod +x zookeeper</code></li>
<li>把 zookeeper 这个脚本添加到开机启动项里面，命令是：<code>chkconfig --add zookeeper</code></li>
<li>如果想看看是否添加成功，命令是：<code>chkconfig --list</code></li>
</ol>
<h3> Linux 用户管理</h3>
<p>Linux 系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。</p>
<p>用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。</p>
<p><strong>Linux 用户管理相关命令:</strong></p>
<ul>
<li><code>useradd 选项 用户名</code>:添加用户账号</li>
<li><code>userdel 选项 用户名</code>:删除用户帐号</li>
<li><code>usermod 选项 用户名</code>:修改帐号</li>
<li><code>passwd 用户名</code>:更改或创建用户的密码</li>
<li><code>passwd -S 用户名</code> :显示用户账号密码信息</li>
<li><code>passwd -d 用户名</code>: 清除用户密码</li>
</ul>
<p><code>useradd</code> 命令用于 Linux 中创建的新的系统用户。<code>useradd</code>可用来建立用户帐号。帐号建好之后，再用<code>passwd</code>设定帐号的密码．而可用<code>userdel</code>删除帐号。使用<code>useradd</code>指令所建立的帐号，实际上是保存在 <code>/etc/passwd</code>文本文件中。</p>
<p><code>passwd</code>命令用于设置用户的认证信息，包括用户密码、密码过期时间等。系统管理者则能用它管理系统用户的密码。只有管理者可以指定用户名称，一般用户只能变更自己的密码。</p>
<h3> Linux 系统用户组的管理</h3>
<p>每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同 Linux 系统对用户组的规定有所不同，如 Linux 下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。</p>
<p>用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对<code>/etc/group</code>文件的更新。</p>
<p><strong>Linux 系统用户组的管理相关命令:</strong></p>
<ul>
<li><code>groupadd 选项 用户组</code> :增加一个新的用户组</li>
<li><code>groupdel 用户组</code>:要删除一个已有的用户组</li>
<li><code>groupmod 选项 用户组</code> : 修改用户组的属性</li>
</ul>
<h3> 其他常用命令</h3>
<ul>
<li>
<p><strong><code>pwd</code>：</strong> 显示当前所在位置</p>
</li>
<li>
<p><code>sudo + 其他命令</code>：以系统管理者的身份执行指令，也就是说，经由 sudo 所执行的指令就好像是 root 亲自执行。</p>
</li>
<li>
<p><strong><code>grep 要搜索的字符串 要搜索的文件 --color</code>：</strong> 搜索命令，--color 代表高亮显示</p>
</li>
<li>
<p><strong><code>ps -ef</code>/<code>ps -aux</code>：</strong> 这两个命令都是查看当前系统正在运行进程，两者的区别是展示格式不同。如果想要查看特定的进程可以使用这样的格式：<strong><code>ps aux|grep redis</code></strong> （查看包括 redis 字符串的进程），也可使用 <code>pgrep redis -a</code>。</p>
<p>注意：如果直接用 ps（（Process Status））命令，会显示所有进程的状态，通常结合 grep 命令查看某进程的状态。</p>
</li>
<li>
<p><strong><code>kill -9 进程的pid</code>：</strong> 杀死进程（-9 表示强制终止。）</p>
<p>先用 ps 查找进程，然后用 kill 杀掉</p>
</li>
<li>
<p><strong>网络通信命令：</strong></p>
<ul>
<li>查看当前系统的网卡信息：ifconfig</li>
<li>查看与某台机器的连接情况：ping</li>
<li>查看当前系统的端口使用：netstat -an</li>
</ul>
</li>
<li>
<p><strong>net-tools 和 iproute2 ：</strong>
<code>net-tools</code>起源于 BSD 的 TCP/IP 工具箱，后来成为老版本 LinuxLinux 中配置网络功能的工具。但自 2001 年起，Linux 社区已经对其停止维护。同时，一些 Linux 发行版比如 Arch Linux 和 CentOS/RHEL 7 则已经完全抛弃了 net-tools，只支持<code>iproute2</code>。linux ip 命令类似于 ifconfig，但功能更强大，旨在替代它。更多详情请阅读<a href="https://linoxide.com/linux-command/use-ip-command-linux" target="_blank" rel="noopener noreferrer">如何在 Linux 中使用 IP 命令和示例</a></p>
</li>
<li>
<p><strong><code>shutdown</code>：</strong> <code>shutdown -h now</code>： 指定现在立即关机；<code>shutdown +5 "System will shutdown after 5 minutes"</code>：指定 5 分钟后关机，同时送出警告信息给登入用户。</p>
</li>
<li>
<p><strong><code>reboot</code>：</strong> <strong><code>reboot</code>：</strong> 重开机。<strong><code>reboot -w</code>：</strong> 做个重开机的模拟（只有纪录并不会真的重开机）。</p>
</li>
</ul>
<h2> Linux 环境变量</h2>
<p>在 Linux 系统中，环境变量是用来定义系统运行环境的一些参数，比如每个用户不同的主目录（HOME）。</p>
<h3> 环境变量分类</h3>
<p>按照作用域来分，环境变量可以简单的分成:</p>
<ul>
<li>用户级别环境变量 : <code>~/.bashrc</code>、<code>~/.bash_profile</code>。</li>
<li>系统级别环境变量 : <code>/etc/bashrc</code>、<code>/etc/environment</code>、<code>/etc/profile</code>、<code>/etc/profile.d</code>。</li>
</ul>
<p>上述配置文件执行先后顺序为：<code>/etc/enviroment</code> –&gt; <code>/etc/profile</code> –&gt; <code>/etc/profile.d</code> –&gt; <code>~/.bash_profile</code> –&gt; <code>/etc/bashrc</code> –&gt; <code>~/.bashrc</code></p>
<p>如果要修改系统级别环境变量文件，需要管理员具备对该文件的写入权限。</p>
<p>建议用户级别环境变量在 <code>~/.bash_profile</code>中配置，系统级别环境变量在 <code>/etc/profile.d</code> 中配置。</p>
<p>按照生命周期来分，环境变量可以简单的分成:</p>
<ul>
<li>永久的：需要用户修改相关的配置文件，变量永久生效。</li>
<li>临时的：用户利用 <code>export</code> 命令，在当前终端下声明环境变量，关闭 shell 终端失效。</li>
</ul>
<h3> 读取环境变量</h3>
<p>通过 <code>export</code> 命令可以输出当前系统定义的所有环境变量。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>除了 <code>export</code> 命令之外， <code>env</code> 命令也可以列出所有环境变量。</p>
<p><code>echo</code> 命令可以输出指定环境变量的值。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 环境变量修改</h3>
<p>通过 <code>export</code>命令可以修改指定的环境变量。不过，这种方式修改环境变量仅仅对当前 shell 终端生效，关闭 shell 终端就会失效。修改完成之后，立即生效。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>通过 <code>vim</code> 命令修改环境变量配置文件。这种方式修改环境变量永久有效。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果修改的是系统级别环境变量则对所有用户生效，如果修改的是用户级别环境变量则仅对当前用户生效。</p>
<p>修改完成之后，需要 <code>source</code> 命令让其生效或者关闭 shell 终端重新登录。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>]]></content:encoded>
      <enclosure url="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-8/image-20200807161118901.png" type="image/png"/>
    </item>
    <item>
      <title>操作系统常见面试题总结</title>
      <link>https://javaguide.cn/cs-basics/operating-system/operating-system-basic-questions-01.html</link>
      <guid>https://javaguide.cn/cs-basics/operating-system/operating-system-basic-questions-01.html</guid>
      <source url="https://javaguide.cn/rss.xml">操作系统常见面试题总结</source>
      <description>很多读者抱怨计算操作系统的知识点比较繁杂，自己也没有多少耐心去看，但是面试的时候又经常会遇到。所以，我带着我整理好的操作系统的常见问题来啦！这篇文章总结了一些我觉得比较重要的操作系统相关的问题比如进程管理、内存管理、虚拟内存等等。 文章形式通过大部分同学比较喜欢的面试官和求职者之间的对话形式展开。另外，我也只是在大学的时候学习过操作系统，不过基本都忘了，为了写这篇文章这段时间看了很多相关的书籍和博客。 这篇文章只是对一些操作系统比较重要概念的一个概览，深入学习的话，建议大家还是老老实实地去看书。另外， 这篇文章的很多内容参考了《现代操作系统》第三版这本书，非常感谢。</description>
      <category>计算机基础</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<p>很多读者抱怨计算操作系统的知识点比较繁杂，自己也没有多少耐心去看，但是面试的时候又经常会遇到。所以，我带着我整理好的操作系统的常见问题来啦！这篇文章总结了一些我觉得比较重要的操作系统相关的问题比如<strong>进程管理</strong>、<strong>内存管理</strong>、<strong>虚拟内存</strong>等等。</p>
<p>文章形式通过大部分同学比较喜欢的面试官和求职者之间的对话形式展开。另外，我也只是在大学的时候学习过操作系统，不过基本都忘了，为了写这篇文章这段时间看了很多相关的书籍和博客。</p>
<p>这篇文章只是对一些操作系统比较重要概念的一个概览，深入学习的话，建议大家还是老老实实地去看书。另外， 这篇文章的很多内容参考了《现代操作系统》第三版这本书，非常感谢。</p>
<p>开始本文的内容之前，我们先聊聊为什么要学习操作系统。</p>
<ul>
<li><strong>从对个人能力方面提升来说</strong> ：操作系统中的很多思想、很多经典的算法，你都可以在我们日常开发使用的各种工具或者框架中找到它们的影子。比如说我们开发的系统使用的缓存（比如 Redis）和操作系统的高速缓存就很像。CPU 中的高速缓存有很多种，不过大部分都是为了解决 CPU 处理速度和内存处理速度不对等的问题。我们还可以把内存看作外存的高速缓存，程序运行的时候我们把外存的数据复制到内存，由于内存的处理速度远远高于外存，这样提高了处理速度。同样地，我们使用的 Redis 缓存就是为了解决程序处理速度和访问常规关系型数据库速度不对等的问题。高速缓存一般会按照局部性原理（2-8 原则）根据相应的淘汰算法保证缓存中的数据是经常会被访问的。我们平常使用的 Redis 缓存很多时候也会按照 2-8 原则去做，很多淘汰算法都和操作系统中的类似。既说了 2-8 原则，那就不得不提命中率了，这是所有缓存概念都通用的。简单来说也就是你要访问的数据有多少能直接在缓存中直接找到。命中率高的话，一般表明你的缓存设计比较合理，系统处理速度也相对较快。</li>
<li><strong>从面试角度来说</strong> ：尤其是校招，对于操作系统方面知识的考察是非常非常多的。</li>
</ul>
<p><strong>简单来说，学习操作系统能够提高自己思考的深度以及对技术的理解力，并且，操作系统方面的知识也是面试必备。</strong></p>
<p>关于如何学习操作系统，可以看这篇回答：<a href="https://www.zhihu.com/question/270998611/answer/1640198217" target="_blank" rel="noopener noreferrer">https://www.zhihu.com/question/270998611/answer/1640198217</a>。</p>
<h2> 操作系统基础</h2>
<p>面试官顶着蓬松的假发向我走来，只见他一手拿着厚重的 Thinkpad ，一手提着他那淡黄的长裙。</p>
<h3> 什么是操作系统？</h3>
<p>👨‍💻<strong>面试官</strong> ： 先来个简单问题吧！<strong>什么是操作系统？</strong></p>
<p>🙋 <strong>我</strong> ：我通过以下四点向您介绍一下什么是操作系统吧！</p>
<ol>
<li><strong>操作系统（Operating System，简称 OS）是管理计算机硬件与软件资源的程序，是计算机的基石。</strong></li>
<li><strong>操作系统本质上是一个运行在计算机上的软件程序 ，用于管理计算机硬件和软件资源。</strong> 举例：运行在你电脑上的所有应用程序都通过操作系统来调用系统内存以及磁盘等等硬件。</li>
<li><strong>操作系统存在屏蔽了硬件层的复杂性。</strong> 操作系统就像是硬件使用的负责人，统筹着各种相关事项。</li>
<li><strong>操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理</strong>。 内核是连接应用程序和硬件的桥梁，决定着系统的性能和稳定性。</li>
</ol>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-8/Kernel_Layout.png" alt="Kernel_Layout"></p>
<h3> 系统调用</h3>
<p>👨‍💻<strong>面试官</strong> ：<strong>什么是系统调用呢？</strong> 能不能详细介绍一下。</p>
<p>🙋 <strong>我</strong> ：介绍系统调用之前，我们先来了解一下用户态和系统态。</p>
<p>根据进程访问资源的特点，我们可以把进程在系统上的运行分为两个级别：</p>
<ol>
<li>用户态(user mode) : 用户态运行的进程可以直接读取用户程序的数据。</li>
<li>系统态(kernel mode):可以简单的理解系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制。</li>
</ol>
<p>说了用户态和系统态之后，那么什么是系统调用呢？</p>
<p>我们运行的程序基本都是运行在用户态，如果我们调用操作系统提供的系统态级别的子功能咋办呢？那就需要系统调用了！</p>
<p>也就是说在我们运行的用户程序中，凡是与系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。</p>
<p>这些系统调用按功能大致可分为如下几类：</p>
<ul>
<li>设备管理。完成设备的请求或释放，以及设备启动等功能。</li>
<li>文件管理。完成文件的读、写、创建及删除等功能。</li>
<li>进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。</li>
<li>进程通信。完成进程之间的消息传递或信号传递等功能。</li>
<li>内存管理。完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。</li>
</ul>
<h2> 进程和线程</h2>
<h3> 进程和线程的区别</h3>
<p>👨‍💻<strong>面试官</strong>: 好的！我明白了！那你再说一下： <strong>进程和线程的区别</strong>。</p>
<p>🙋 <strong>我：</strong> 好的！ 下图是 Java 内存区域，我们从 JVM 的角度来说一下线程和进程之间的关系吧！</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/java/jvm/java-runtime-data-areas-jdk1.8.png" alt="Java 运行时数据区域（JDK1.8 之后）"></p>
<p>从上图可以看出：一个进程中可以有多个线程，多个线程共享进程的<strong>堆</strong>和<strong>方法区 (JDK1.8 之后的元空间)<strong>资源，但是每个线程有自己的</strong>程序计数器</strong>、<strong>虚拟机栈</strong> 和 <strong>本地方法栈</strong>。</p>
<p><strong>总结：</strong> 线程是进程划分成的更小的运行单位,一个进程在其执行的过程中可以产生多个线程。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反。</p>
<h3> 进程有哪几种状态?</h3>
<p>👨‍💻<strong>面试官</strong> ： 那你再说说<strong>进程有哪几种状态?</strong></p>
<p>🙋 <strong>我</strong> ：我们一般把进程大致分为 5 种状态，这一点和<a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/Multithread/JavaConcurrencyBasicsCommonInterviewQuestionsSummary.md#6-%E8%AF%B4%E8%AF%B4%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E7%8A%B6%E6%80%81" target="_blank" rel="noopener noreferrer">线程</a>很像！</p>
<ul>
<li><strong>创建状态(new)</strong> ：进程正在被创建，尚未到就绪状态。</li>
<li><strong>就绪状态(ready)</strong> ：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行。</li>
<li><strong>运行状态(running)</strong> ：进程正在处理器上上运行(单核 CPU 下任意时刻只有一个进程处于运行状态)。</li>
<li><strong>阻塞状态(waiting)</strong> ：又称为等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行。</li>
<li><strong>结束状态(terminated)</strong> ：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。</li>
</ul>
<blockquote>
<p>订正：下图中 running 状态被 interrupt 向 ready 状态转换的箭头方向反了。</p>
</blockquote>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/d38202593012b457debbcd74994c6292.png" alt="process-state"></p>
<h3> 进程间的通信方式</h3>
<p>👨‍💻<strong>面试官</strong> ：<strong>进程间的通信常见的的有哪几种方式呢?</strong></p>
<p>🙋 <strong>我</strong> ：大概有 7 种常见的进程间的通信方式。</p>
<blockquote>
<p>下面这部分总结参考了:<a href="https://www.jianshu.com/p/c1015f5ffa74" target="_blank" rel="noopener noreferrer">《进程间通信 IPC (InterProcess Communication)》</a> 这篇文章，推荐阅读，总结的非常不错。</p>
</blockquote>
<ol>
<li><strong>管道/匿名管道(Pipes)</strong> ：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。</li>
<li><strong>有名管道(Named Pipes)</strong> : 匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循<strong>先进先出(first in first out)</strong>。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。</li>
<li><strong>信号(Signal)</strong> ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；</li>
<li><strong>消息队列(Message Queuing)</strong> ：消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显式地删除一个消息队列时，该消息队列才会被真正的删除。消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比 FIFO 更有优势。<strong>消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺点。</strong></li>
<li><strong>信号量(Semaphores)</strong> ：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。</li>
<li><strong>共享内存(Shared memory)</strong> ：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。</li>
<li><strong>套接字(Sockets)</strong> : 此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。</li>
</ol>
<h3> 线程间的同步的方式</h3>
<p>👨‍💻<strong>面试官</strong> ：<strong>那线程间的同步的方式有哪些呢?</strong></p>
<p>🙋 <strong>我</strong> ：线程同步是两个或多个共享关键资源的线程的并发执行。应该同步线程以避免关键的资源使用冲突。操作系统一般有下面三种线程同步的方式：</p>
<ol>
<li><strong>互斥量(Mutex)</strong>：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制。</li>
<li><strong>信号量(Semaphore)</strong> ：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。</li>
<li><strong>事件(Event)</strong> :Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。</li>
</ol>
<h3> 进程的调度算法</h3>
<p>👨‍💻<strong>面试官</strong> ：<strong>你知道操作系统中进程的调度算法有哪些吗?</strong></p>
<p>🙋 <strong>我</strong> ：嗯嗯！这个我们大学的时候学过，是一个很重要的知识点！</p>
<p>为了确定首先执行哪个进程以及最后执行哪个进程以实现最大 CPU 利用率，计算机科学家已经定义了一些算法，它们是：</p>
<ul>
<li><strong>先到先服务(FCFS)调度算法</strong> : 从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</li>
<li><strong>短作业优先(SJF)的调度算法</strong> : 从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。</li>
<li><strong>时间片轮转调度算法</strong> : 时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法，又称 RR(Round robin)调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。</li>
<li><strong>多级反馈队列调度算法</strong> ：前面介绍的几种进程调度的算法都有一定的局限性。如<strong>短进程优先的调度算法，仅照顾了短进程而忽略了长进程</strong> 。多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成。，因而它是目前<strong>被公认的一种较好的进程调度算法</strong>，UNIX 操作系统采取的便是这种调度算法。</li>
<li><strong>优先级调度</strong> ： 为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。</li>
</ul>
<h3> 什么是死锁</h3>
<p>👨‍💻<strong>面试官</strong> ：<strong>你知道什么是死锁吗?</strong></p>
<p>🙋 <strong>我</strong> ：死锁描述的是这样一种情况：多个进程/线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于进程/线程被无限期地阻塞，因此程序不可能正常终止。</p>
<h3> 死锁的四个必要条件</h3>
<p>👨‍💻<strong>面试官</strong> ：<strong>产生死锁的四个必要条件是什么?</strong></p>
<p>🙋 <strong>我</strong> ：</p>
<ul>
<li><strong>互斥</strong>：资源必须处于非共享模式，即一次只有一个进程可以使用。如果另一进程申请该资源，那么必须等待直到该资源被释放为止。</li>
<li><strong>占有并等待</strong>：一个进程至少应该占有一个资源，并等待另一资源，而该资源被其他进程所占有。</li>
<li><strong>非抢占</strong>：资源不能被抢占。只能在持有资源的进程完成任务后，该资源才会被释放。</li>
<li><strong>循环等待</strong>：有一组等待进程 <code>{P0, P1,..., Pn}</code>， <code>P0</code> 等待的资源被 <code>P1</code> 占有，<code>P1</code> 等待的资源被 <code>P2</code> 占有，......，<code>Pn-1</code> 等待的资源被 <code>Pn</code> 占有，<code>Pn</code> 等待的资源被 <code>P0</code> 占有。</li>
</ul>
<p><strong>注意 ⚠️</strong> ：这四个条件是产生死锁的 <strong>必要条件</strong> ，也就是说只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生产生死锁。</p>
<p>下面是百度百科对必要条件的解释：</p>
<blockquote>
<p>如果没有事物情况 A，则必然没有事物情况 B，也就是说如果有事物情况 B 则一定有事物情况 A，那么 A 就是 B 的必要条件。从逻辑学上看，B 能推导出 A，A 就是 B 的必要条件，等价于 B 是 A 的充分条件。</p>
</blockquote>
<h3> 解决死锁的方法</h3>
<p>解决死锁的方法可以从多个角度去分析，一般的情况下，有<strong>预防，避免，检测和解除四种</strong>。</p>
<ul>
<li>
<p><strong>预防</strong> 是采用某种策略，<strong>限制并发进程对资源的请求</strong>，从而使得死锁的必要条件在系统执行的任何时间上都不满足。</p>
</li>
<li>
<p><strong>避免</strong>则是系统在分配资源时，根据资源的使用情况<strong>提前做出预测</strong>，从而<strong>避免死锁的发生</strong></p>
</li>
<li>
<p><strong>检测</strong>是指系统设有<strong>专门的机构</strong>，当死锁发生时，该机构能够检测死锁的发生，并精确地确定与死锁有关的进程和资源。</p>
</li>
<li>
<p><strong>解除</strong> 是与检测相配套的一种措施，用于<strong>将进程从死锁状态下解脱出来</strong>。</p>
</li>
</ul>
<h4> 死锁的预防</h4>
<p>死锁四大必要条件上面都已经列出来了，很显然，只要破坏四个必要条件中的任何一个就能够预防死锁的发生。</p>
<p>破坏第一个条件 <strong>互斥条件</strong>：使得资源是可以同时访问的，这是种简单的方法，磁盘就可以用这种方法管理，但是我们要知道，有很多资源 <strong>往往是不能同时访问的</strong> ，所以这种做法在大多数的场合是行不通的。</p>
<p>破坏第三个条件 <strong>非抢占</strong> ：也就是说可以采用 <strong>剥夺式调度算法</strong>，但剥夺式调度方法目前一般仅适用于 <strong>主存资源</strong> 和 <strong>处理器资源</strong> 的分配，并不适用于所以的资源，会导致 <strong>资源利用率下降</strong>。</p>
<p>所以一般比较实用的 <strong>预防死锁的方法</strong>，是通过考虑破坏第二个条件和第四个条件。</p>
<p><strong>1、静态分配策略</strong></p>
<p>静态分配策略可以破坏死锁产生的第二个条件（占有并等待）。所谓静态分配策略，就是指一个进程必须在执行前就申请到它所需要的全部资源，并且知道它所要的资源都得到满足之后才开始执行。进程要么占有所有的资源然后开始执行，要么不占有资源，不会出现占有一些资源等待一些资源的情况。</p>
<p>静态分配策略逻辑简单，实现也很容易，但这种策略 <strong>严重地降低了资源利用率</strong>，因为在每个进程所占有的资源中，有些资源是在比较靠后的执行时间里采用的，甚至有些资源是在额外的情况下才是用的，这样就可能造成了一个进程占有了一些 <strong>几乎不用的资源而使其他需要该资源的进程产生等待</strong> 的情况。</p>
<p><strong>2、层次分配策略</strong></p>
<p>层次分配策略破坏了产生死锁的第四个条件(循环等待)。在层次分配策略下，所有的资源被分成了多个层次，一个进程得到某一次的一个资源后，它只能再申请较高一层的资源；当一个进程要释放某层的一个资源时，必须先释放所占用的较高层的资源，按这种策略，是不可能出现循环等待链的，因为那样的话，就出现了已经申请了较高层的资源，反而去申请了较低层的资源，不符合层次分配策略，证明略。</p>
<h4> 死锁的避免</h4>
<p>上面提到的 <strong>破坏</strong> 死锁产生的四个必要条件之一就可以成功 <strong>预防系统发生死锁</strong> ，但是会导致 <strong>低效的进程运行</strong> 和 <strong>资源使用率</strong> 。而死锁的避免相反，它的角度是允许系统中<strong>同时存在四个必要条件</strong> ，只要掌握并发进程中与每个进程有关的资源动态申请情况，做出 <strong>明智和合理的选择</strong> ，仍然可以避免死锁，因为四大条件仅仅是产生死锁的必要条件。</p>
<p>我们将系统的状态分为 <strong>安全状态</strong> 和 <strong>不安全状态</strong> ，每当在未申请者分配资源前先测试系统状态，若把系统资源分配给申请者会产生死锁，则拒绝分配，否则接受申请，并为它分配资源。</p>
<blockquote>
<p>如果操作系统能够保证所有的进程在有限的时间内得到需要的全部资源，则称系统处于安全状态，否则说系统是不安全的。很显然，系统处于安全状态则不会发生死锁，系统若处于不安全状态则可能发生死锁。</p>
</blockquote>
<p>那么如何保证系统保持在安全状态呢？通过算法，其中最具有代表性的 <strong>避免死锁算法</strong> 就是 Dijkstra 的银行家算法，银行家算法用一句话表达就是：当一个进程申请使用资源的时候，<strong>银行家算法</strong> 通过先 <strong>试探</strong> 分配给该进程资源，然后通过 <strong>安全性算法</strong> 判断分配后系统是否处于安全状态，若不安全则试探分配作废，让该进程继续等待，若能够进入到安全的状态，则就 <strong>真的分配资源给该进程</strong>。</p>
<p>银行家算法详情可见：<a href="https://blog.csdn.net/qq_33414271/article/details/80245715" target="_blank" rel="noopener noreferrer">《一句话+一张图说清楚——银行家算法》</a> 。</p>
<p>操作系统教程树中讲述的银行家算法也比较清晰，可以一看.</p>
<p>死锁的避免(银行家算法)改善解决了 <strong>资源使用率低的问题</strong> ，但是它要不断地检测每个进程对各类资源的占用和申请情况，以及做 <strong>安全性检查</strong> ，需要花费较多的时间。</p>
<h4> 死锁的检测</h4>
<p>对资源的分配加以限制可以 <strong>预防和避免</strong> 死锁的发生，但是都不利于各进程对系统资源的<strong>充分共享</strong>。解决死锁问题的另一条途径是 <strong>死锁检测和解除</strong> (这里突然联想到了乐观锁和悲观锁，感觉死锁的检测和解除就像是 <strong>乐观锁</strong> ，分配资源时不去提前管会不会发生死锁了，等到真的死锁出现了再来解决嘛，而 <strong>死锁的预防和避免</strong> 更像是悲观锁，总是觉得死锁会出现，所以在分配资源的时候就很谨慎)。</p>
<p>这种方法对资源的分配不加以任何限制，也不采取死锁避免措施，但系统 <strong>定时地运行一个 “死锁检测”</strong> 的程序，判断系统内是否出现死锁，如果检测到系统发生了死锁，再采取措施去解除它。</p>
<h5> 进程-资源分配图</h5>
<p>操作系统中的每一刻时刻的<strong>系统状态</strong>都可以用<strong>进程-资源分配图</strong>来表示，进程-资源分配图是描述进程和资源申请及分配关系的一种有向图，可用于<strong>检测系统是否处于死锁状态</strong>。</p>
<p>用一个方框表示每一个资源类，方框中的黑点表示该资源类中的各个资源，每个键进程用一个圆圈表示，用 <strong>有向边</strong> 来表示<strong>进程申请资源和资源被分配的情况</strong>。</p>
<p>图中 2-21 是<strong>进程-资源分配图</strong>的一个例子，其中共有三个资源类，每个进程的资源占有和申请情况已清楚地表示在图中。在这个例子中，由于存在 <strong>占有和等待资源的环路</strong> ，导致一组进程永远处于等待资源的状态，发生了 <strong>死锁</strong>。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/operating-system/process-resource-allocation-diagram.jpg" alt="进程-资源分配图"></p>
<p>进程-资源分配图中存在环路并不一定是发生了死锁。因为循环等待资源仅仅是死锁发生的必要条件，而不是充分条件。图 2-22 便是一个有环路而无死锁的例子。虽然进程 P1 和进程 P3 分别占用了一个资源 R1 和一个资源 R2，并且因为等待另一个资源 R2 和另一个资源 R1 形成了环路，但进程 P2 和进程 P4 分别占有了一个资源 R1 和一个资源 R2，它们申请的资源得到了满足，在有限的时间里会归还资源，于是进程 P1 或 P3 都能获得另一个所需的资源，环路自动解除，系统也就不存在死锁状态了。</p>
<h5> 死锁检测步骤</h5>
<p>知道了死锁检测的原理，我们可以利用下列步骤编写一个 <strong>死锁检测</strong> 程序，检测系统是否产生了死锁。</p>
<ol>
<li>如果进程-资源分配图中无环路，则此时系统没有发生死锁</li>
<li>如果进程-资源分配图中有环路，且每个资源类仅有一个资源，则系统中已经发生了死锁。</li>
<li>如果进程-资源分配图中有环路，且涉及到的资源类有多个资源，此时系统未必会发生死锁。如果能在进程-资源分配图中找出一个 <strong>既不阻塞又非独立的进程</strong> ，该进程能够在有限的时间内归还占有的资源，也就是把边给消除掉了，重复此过程，直到能在有限的时间内 <strong>消除所有的边</strong> ，则不会发生死锁，否则会发生死锁。(消除边的过程类似于 <strong>拓扑排序</strong>)</li>
</ol>
<h4> 死锁的解除</h4>
<p>当死锁检测程序检测到存在死锁发生时，应设法让其解除，让系统从死锁状态中恢复过来，常用的解除死锁的方法有以下四种：</p>
<ol>
<li><strong>立即结束所有进程的执行，重新启动操作系统</strong> ：这种方法简单，但以前所在的工作全部作废，损失很大。</li>
<li><strong>撤销涉及死锁的所有进程，解除死锁后继续运行</strong> ：这种方法能彻底打破<strong>死锁的循环等待</strong>条件，但将付出很大代价，例如有些进程可能已经计算了很长时间，由于被撤销而使产生的部分结果也被消除了，再重新执行时还要再次进行计算。</li>
<li><strong>逐个撤销涉及死锁的进程，回收其资源直至死锁解除。</strong></li>
<li><strong>抢占资源</strong> ：从涉及死锁的一个或几个进程中抢占资源，把夺得的资源再分配给涉及死锁的进程直至死锁解除。</li>
</ol>
<h2> 操作系统内存管理基础</h2>
<h3> 内存管理介绍</h3>
<p>👨‍💻 <strong>面试官</strong>: <strong>操作系统的内存管理主要是做什么？</strong></p>
<p>🙋 <strong>我：</strong> 操作系统的内存管理主要负责内存的分配与回收（malloc 函数：申请内存，free 函数：释放内存），另外地址转换也就是将逻辑地址转换成相应的物理地址等功能也是操作系统内存管理做的事情。</p>
<h3> 常见的几种内存管理机制</h3>
<p>👨‍💻 <strong>面试官</strong>: <strong>操作系统的内存管理机制了解吗？内存管理有哪几种方式?</strong></p>
<p>🙋 <strong>我：</strong> 这个在学习操作系统的时候有了解过。</p>
<p>简单分为<strong>连续分配管理方式</strong>和<strong>非连续分配管理方式</strong>这两种。连续分配管理方式是指为一个用户程序分配一个连续的内存空间，常见的如 <strong>块式管理</strong> 。同样地，非连续分配管理方式允许一个程序使用的内存分布在离散或者说不相邻的内存中，常见的如<strong>页式管理</strong> 和 <strong>段式管理</strong>。</p>
<ol>
<li><strong>块式管理</strong> ： 远古时代的计算机操作系统的内存管理方式。将内存分为几个固定大小的块，每个块中只包含一个进程。如果程序运行需要内存的话，操作系统就分配给它一块，如果程序运行只需要很小的空间的话，分配的这块内存很大一部分几乎被浪费了。这些在每个块中未被利用的空间，我们称之为碎片。</li>
<li><strong>页式管理</strong> ：把主存分为大小相等且固定的一页一页的形式，页较小，相比于块式管理的划分粒度更小，提高了内存利用率，减少了碎片。页式管理通过页表对应逻辑地址和物理地址。</li>
<li><strong>段式管理</strong> ： 页式管理虽然提高了内存利用率，但是页式管理其中的页并无任何实际意义。 段式管理把主存分为一段段的，段是有实际意义的，每个段定义了一组逻辑信息，例如,有主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等。 段式管理通过段表对应逻辑地址和物理地址。</li>
</ol>
<p>简单来说：页是物理单位，段是逻辑单位。分页可以有效提高内存利用率，分段可以更好满足用户需求。</p>
<p>👨‍💻<strong>面试官</strong> ： 回答的还不错！不过漏掉了一个很重要的 <strong>段页式管理机制</strong> 。段页式管理机制结合了段式管理和页式管理的优点。简单来说段页式管理机制就是把主存先分成若干段，每个段又分成若干页，也就是说 <strong>段页式管理机制</strong> 中段与段之间以及段的内部的都是离散的。</p>
<p>🙋 <strong>我</strong> ：谢谢面试官！刚刚把这个给忘记了～</p>
<h3> 快表和多级页表</h3>
<p>👨‍💻<strong>面试官</strong> ： 页表管理机制中有两个很重要的概念：快表和多级页表，这两个东西分别解决了页表管理中很重要的两个问题。你给我简单介绍一下吧！</p>
<p>🙋 <strong>我</strong> ：在分页内存管理中，很重要的两点是：</p>
<ol>
<li>虚拟地址到物理地址的转换要快。</li>
<li>解决虚拟地址空间大，页表也会很大的问题。</li>
</ol>
<h4> 快表</h4>
<p>为了提高虚拟地址到物理地址的转换速度，操作系统在 <strong>页表方案</strong> 基础之上引入了 <strong>快表</strong> 来加速虚拟地址到物理地址的转换。我们可以把快表理解为一种特殊的高速缓冲存储器（Cache），其中的内容是页表的一部分或者全部内容。作为页表的 Cache，它的作用与页表相似，但是提高了访问速率。由于采用页表做地址转换，读写内存数据时 CPU 要访问两次主存。有了快表，有时只要访问一次高速缓冲存储器，一次主存，这样可加速查找并提高指令执行速度。</p>
<p>使用快表之后的地址转换流程是这样的：</p>
<ol>
<li>根据虚拟地址中的页号查快表；</li>
<li>如果该页在快表中，直接从快表中读取相应的物理地址；</li>
<li>如果该页不在快表中，就访问内存中的页表，再从页表中得到物理地址，同时将页表中的该映射表项添加到快表中；</li>
<li>当快表填满后，又要登记新页时，就按照一定的淘汰策略淘汰掉快表中的一个页。</li>
</ol>
<p>看完了之后你会发现快表和我们平时经常在我们开发的系统使用的缓存（比如 Redis）很像，的确是这样的，操作系统中的很多思想、很多经典的算法，你都可以在我们日常开发使用的各种工具或者框架中找到它们的影子。</p>
<h4> 多级页表</h4>
<p>引入多级页表的主要目的是为了避免把全部页表一直放在内存中占用过多空间，特别是那些根本就不需要的页表就不需要保留在内存中。</p>
<p>多级页表属于时间换空间的典型场景。</p>
<h4> 总结</h4>
<p>为了提高内存的空间性能，提出了多级页表的概念；但是提到空间性能是以浪费时间性能为基础的，因此为了补充损失的时间性能，提出了快表（即 TLB）的概念。 不论是快表还是多级页表实际上都利用到了程序的局部性原理，局部性原理在后面的虚拟内存这部分会介绍到。</p>
<h3> 分页机制和分段机制的共同点和区别</h3>
<p>👨‍💻<strong>面试官</strong> ： <strong>分页机制和分段机制有哪些共同点和区别呢？</strong></p>
<p>🙋 <strong>我</strong> ：</p>
<ol>
<li><strong>共同点</strong> ：
<ul>
<li>分页机制和分段机制都是为了提高内存利用率，减少内存碎片。</li>
<li>页和段都是离散存储的，所以两者都是离散分配内存的方式。但是，每个页和段中的内存是连续的。</li>
</ul>
</li>
<li><strong>区别</strong> ：
<ul>
<li>页的大小是固定的，由操作系统决定；而段的大小不固定，取决于我们当前运行的程序。</li>
<li>分页仅仅是为了满足操作系统内存管理的需求，而段是逻辑信息的单位，在程序中可以体现为代码段，数据段，能够更好满足用户的需要。</li>
</ul>
</li>
</ol>
<h3> 逻辑(虚拟)地址和物理地址</h3>
<p>👨‍💻<strong>面试官</strong> ：你刚刚还提到了<strong>逻辑地址和物理地址</strong>这两个概念，我不太清楚，你能为我解释一下不？</p>
<p>🙋 <strong>我：</strong> em...好的嘛！我们编程一般只有可能和逻辑地址打交道，比如在 C 语言中，指针里面存储的数值就可以理解成为内存里的一个地址，这个地址也就是我们说的逻辑地址，逻辑地址由操作系统决定。物理地址指的是真实物理内存中地址，更具体一点来说就是内存地址寄存器中的地址。物理地址是内存单元真正的地址。</p>
<h3> CPU 寻址了解吗?为什么需要虚拟地址空间?</h3>
<p>👨‍💻<strong>面试官</strong> ：<strong>CPU 寻址了解吗?为什么需要虚拟地址空间?</strong></p>
<p>🙋 <strong>我</strong> ：这部分我真不清楚！</p>
<p>于是面试完之后我默默去查阅了相关文档！留下了没有技术的泪水。。。</p>
<blockquote>
<p>这部分内容参考了 Microsoft 官网的介绍，地址：<a href="https://docs.microsoft.com/zh-cn/windows-hardware/drivers/gettingstarted/virtual-address-spaces?redirectedfrom=MSDN" target="_blank" rel="noopener noreferrer">https://docs.microsoft.com/zh-cn/windows-hardware/drivers/gettingstarted/virtual-address-spaces?redirectedfrom=MSDN</a></p>
</blockquote>
<p>现代处理器使用的是一种称为 <strong>虚拟寻址(Virtual Addressing)</strong> 的寻址方式。<strong>使用虚拟寻址，CPU 需要将虚拟地址翻译成物理地址，这样才能访问到真实的物理内存。</strong> 实际上完成虚拟地址转换为物理地址转换的硬件是 CPU 中含有一个被称为 <strong>内存管理单元（Memory Management Unit, MMU）</strong> 的硬件。如下图所示：</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/2b27dac8cc647f8aac989da2d1166db2.png" alt="MMU_principle_updated"></p>
<p><strong>为什么要有虚拟地址空间呢？</strong></p>
<p>先从没有虚拟地址空间的时候说起吧！没有虚拟地址空间的时候，<strong>程序直接访问和操作的都是物理内存</strong> 。但是这样有什么问题呢？</p>
<ol>
<li>用户程序可以访问任意内存，寻址内存的每个字节，这样就很容易（有意或者无意）破坏操作系统，造成操作系统崩溃。</li>
<li>想要同时运行多个程序特别困难，比如你想同时运行一个微信和一个 QQ 音乐都不行。为什么呢？举个简单的例子：微信在运行的时候给内存地址 1xxx 赋值后，QQ 音乐也同样给内存地址 1xxx 赋值，那么 QQ 音乐对内存的赋值就会覆盖微信之前所赋的值，这就造成了微信这个程序就会崩溃。</li>
</ol>
<p><strong>总结来说：如果直接把物理地址暴露出来的话会带来严重问题，比如可能对操作系统造成伤害以及给同时运行多个程序造成困难。</strong></p>
<p>通过虚拟地址访问内存有以下优势：</p>
<ul>
<li>程序可以使用一系列相邻的虚拟地址来访问物理内存中不相邻的大内存缓冲区。</li>
<li>程序可以使用一系列虚拟地址来访问大于可用物理内存的内存缓冲区。当物理内存的供应量变小时，内存管理器会将物理内存页（通常大小为 4 KB）保存到磁盘文件。数据或代码页会根据需要在物理内存与磁盘之间移动。</li>
<li>不同进程使用的虚拟地址彼此隔离。一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存。</li>
</ul>
<h2> 虚拟内存</h2>
<h3> 什么是虚拟内存(Virtual Memory)?</h3>
<p>👨‍💻<strong>面试官</strong> ：再问你一个常识性的问题！<strong>什么是虚拟内存(Virtual Memory)?</strong></p>
<p>🙋 <strong>我</strong> ：这个在我们平时使用电脑特别是 Windows 系统的时候太常见了。很多时候我们使用了很多占内存的软件，这些软件占用的内存可能已经远远超出了我们电脑本身具有的物理内存。<strong>为什么可以这样呢？</strong> 正是因为 <strong>虚拟内存</strong> 的存在，通过 <strong>虚拟内存</strong> 可以让程序可以拥有超过系统物理内存大小的可用内存空间。另外，<strong>虚拟内存为每个进程提供了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享主存的错觉（每个进程拥有一片连续完整的内存空间）</strong>。这样会更加有效地管理内存并减少出错。</p>
<p><strong>虚拟内存</strong>是计算机系统内存管理的一种技术，我们可以手动设置自己电脑的虚拟内存。不要单纯认为虚拟内存只是“使用硬盘空间来扩展内存“的技术。<strong>虚拟内存的重要意义是它定义了一个连续的虚拟地址空间</strong>，并且 <strong>把内存扩展到硬盘空间</strong>。推荐阅读：<a href="https://juejin.im/post/59f8691b51882534af254317" target="_blank" rel="noopener noreferrer">《虚拟内存的那点事儿》</a></p>
<p>维基百科中有几句话是这样介绍虚拟内存的。</p>
<blockquote>
<p><strong>虚拟内存</strong> 使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。与没有使用虚拟内存技术的系统相比，使用这种技术的系统使得大型程序的编写变得更容易，对真正的物理内存（例如 RAM）的使用也更有效率。目前，大多数操作系统都使用了虚拟内存，如 Windows 家族的“虚拟内存”；Linux 的“交换空间”等。From:<a href="https://zh.wikipedia.org/wiki/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98" target="_blank" rel="noopener noreferrer">https://zh.wikipedia.org/wiki/虚拟内存</a></p>
</blockquote>
<h3> 局部性原理</h3>
<p>👨‍💻<strong>面试官</strong> ：要想更好地理解虚拟内存技术，必须要知道计算机中著名的<strong>局部性原理</strong>。另外，局部性原理既适用于程序结构，也适用于数据结构，是非常重要的一个概念。</p>
<p>🙋 <strong>我</strong> ：局部性原理是虚拟内存技术的基础，正是因为程序运行具有局部性原理，才可以只装入部分程序到内存就开始运行。</p>
<blockquote>
<p>以下内容摘自《计算机操作系统教程》 第 4 章存储器管理。</p>
</blockquote>
<p>早在 1968 年的时候，就有人指出我们的程序在执行的时候往往呈现局部性规律，也就是说在某个较短的时间段内，程序执行局限于某一小部分，程序访问的存储空间也局限于某个区域。</p>
<p>局部性原理表现在以下两个方面：</p>
<ol>
<li><strong>时间局部性</strong> ：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问。产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作。</li>
<li><strong>空间局部性</strong> ：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。</li>
</ol>
<p>时间局部性是通过将近来使用的指令和数据保存到高速缓存存储器中，并使用高速缓存的层次结构实现。空间局部性通常是使用较大的高速缓存，并将预取机制集成到高速缓存控制逻辑中实现。虚拟内存技术实际上就是建立了 “内存一外存”的两级存储器的结构，利用局部性原理实现髙速缓存。</p>
<h3> 虚拟存储器</h3>
<blockquote>
<p><strong>勘误：虚拟存储器又叫做虚拟内存，都是 Virtual Memory 的翻译，属于同一个概念。</strong></p>
</blockquote>
<p>👨‍💻<strong>面试官</strong> ：<s>都说了虚拟内存了。你再讲讲<strong>虚拟存储器</strong>把！</s></p>
<p>🙋 <strong>我</strong> ：</p>
<blockquote>
<p>这部分内容来自：<a href="https://wizardforcel.gitbooks.io/wangdaokaoyan-os/content/13.html" target="_blank" rel="noopener noreferrer">王道考研操作系统知识点整理</a>。</p>
</blockquote>
<p>基于局部性原理，在程序装入时，可以将程序的一部分装入内存，而将其他部分留在外存，就可以启动程序执行。由于外存往往比内存大很多，所以我们运行的软件的内存大小实际上是可以比计算机系统实际的内存大小大的。在程序执行过程中，当所访问的信息不在内存时，由操作系统将所需要的部分调入内存，然后继续执行程序。另一方面，操作系统将内存中暂时不使用的内容换到外存上，从而腾出空间存放将要调入内存的信息。这样，计算机好像为用户提供了一个比实际内存大得多的存储器——<strong>虚拟存储器</strong>。</p>
<p>实际上，我觉得虚拟内存同样是一种时间换空间的策略，你用 CPU 的计算时间，页的调入调出花费的时间，换来了一个虚拟的更大的空间来支持程序的运行。不得不感叹，程序世界几乎不是时间换空间就是空间换时间。</p>
<h3> 虚拟内存的技术实现</h3>
<p>👨‍💻<strong>面试官</strong> ：<strong>虚拟内存技术的实现呢？</strong></p>
<p>🙋 <strong>我</strong> ：<strong>虚拟内存的实现需要建立在离散分配的内存管理方式的基础上。</strong> 虚拟内存的实现有以下三种方式：</p>
<ol>
<li><strong>请求分页存储管理</strong> ：建立在分页管理之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。请求分页是目前最常用的一种实现虚拟存储器的方法。请求分页存储管理系统中，在作业开始运行之前，仅装入当前要执行的部分段即可运行。假如在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调入到主存，同时操作系统也可以将暂时不用的页面置换到外存中。</li>
<li><strong>请求分段存储管理</strong> ：建立在分段存储管理之上，增加了请求调段功能、分段置换功能。请求分段储存管理方式就如同请求分页储存管理方式一样，在作业开始运行之前，仅装入当前要执行的部分段即可运行；在执行过程中，可使用请求调入中断动态装入要访问但又不在内存的程序段；当内存空间已满，而又需要装入新的段时，根据置换功能适当调出某个段，以便腾出空间而装入新的段。</li>
<li><strong>请求段页式存储管理</strong></li>
</ol>
<p><strong>这里多说一下？很多人容易搞混请求分页与分页存储管理，两者有何不同呢？</strong></p>
<p>请求分页存储管理建立在分页管理之上。他们的根本区别是是否将程序全部所需的全部地址空间都装入主存，这也是请求分页存储管理可以提供虚拟内存的原因，我们在上面已经分析过了。</p>
<p>它们之间的根本区别在于是否将一作业的全部地址空间同时装入主存。请求分页存储管理不要求将作业全部地址空间同时装入主存。基于这一点，请求分页存储管理可以提供虚存，而分页存储管理却不能提供虚存。</p>
<p>不管是上面那种实现方式，我们一般都需要：</p>
<ol>
<li>一定容量的内存和外存：在载入程序的时候，只需要将程序的一部分装入内存，而将其他部分留在外存，然后程序就可以执行了；</li>
<li><strong>缺页中断</strong>：如果<strong>需执行的指令或访问的数据尚未在内存</strong>（称为缺页或缺段），则由处理器通知操作系统将相应的页面或段<strong>调入到内存</strong>，然后继续执行程序；</li>
<li><strong>虚拟地址空间</strong> ：逻辑地址到物理地址的变换。</li>
</ol>
<h3> 页面置换算法</h3>
<p>👨‍💻<strong>面试官</strong> ：虚拟内存管理很重要的一个概念就是页面置换算法。那你说一下 <strong>页面置换算法的作用?常见的页面置换算法有哪些?</strong></p>
<p>🙋 <strong>我</strong> ：</p>
<blockquote>
<p>这个题目经常作为笔试题出现，网上已经给出了很不错的回答，我这里只是总结整理了一下。</p>
</blockquote>
<p>地址映射过程中，若在页面中发现所要访问的页面不在内存中，则发生缺页中断 。</p>
<blockquote>
<p><strong>缺页中断</strong> 就是要访问的<strong>页</strong>不在主存，需要操作系统将其调入主存后再进行访问。 在这个时候，被内存映射的文件实际上成了一个分页交换文件。</p>
</blockquote>
<p>当发生缺页中断时，如果当前内存中并没有空闲的页面，操作系统就必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。用来选择淘汰哪一页的规则叫做页面置换算法，我们可以把页面置换算法看成是淘汰页面的规则。</p>
<ul>
<li><strong>OPT 页面置换算法（最佳页面置换算法）</strong> ：最佳(Optimal, OPT)置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面,这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在内存下的若千页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现。一般作为衡量其他置换算法的方法。</li>
<li><strong>FIFO（First In First Out） 页面置换算法（先进先出页面置换算法）</strong> : 总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰。</li>
<li><strong>LRU （Least Recently Used）页面置换算法（最近最久未使用页面置换算法）</strong> ：LRU 算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 T，当须淘汰一个页面时，选择现有页面中其 T 值最大的，即最近最久未使用的页面予以淘汰。</li>
<li><strong>LFU （Least Frequently Used）页面置换算法（最少使用页面置换算法）</strong> : 该置换算法选择在之前时期使用最少的页面作为淘汰页。</li>
</ul>
<h2> 参考</h2>
<ul>
<li>《计算机操作系统—汤小丹》第四版</li>
<li><a href="https://book.douban.com/subject/1230413/" target="_blank" rel="noopener noreferrer">《深入理解计算机系统》</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%8D%95%E5%85%83" target="_blank" rel="noopener noreferrer">https://zh.wikipedia.org/wiki/输入输出内存管理单元</a></li>
<li><a href="https://baike.baidu.com/item/%E5%BF%AB%E8%A1%A8/19781679" target="_blank" rel="noopener noreferrer">https://baike.baidu.com/item/快表/19781679</a></li>
<li>https://www.jianshu.com/p/1d47ed0b46d5</li>
<li><a href="https://www.studytonight.com/operating-system" target="_blank" rel="noopener noreferrer">https://www.studytonight.com/operating-system</a></li>
<li><a href="https://www.geeksforgeeks.org/interprocess-communication-methods/" target="_blank" rel="noopener noreferrer">https://www.geeksforgeeks.org/interprocess-communication-methods/</a></li>
<li><a href="https://juejin.im/post/59f8691b51882534af254317" target="_blank" rel="noopener noreferrer">https://juejin.im/post/59f8691b51882534af254317</a></li>
<li>王道考研操作系统知识点整理： https://wizardforcel.gitbooks.io/wangdaokaoyan-os/content/13.html</li>
</ul>
]]></content:encoded>
      <enclosure url="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-8/Kernel_Layout.png" type="image/png"/>
    </item>
    <item>
      <title>Shell 编程基础知识总结</title>
      <link>https://javaguide.cn/cs-basics/operating-system/shell-intro.html</link>
      <guid>https://javaguide.cn/cs-basics/operating-system/shell-intro.html</guid>
      <source url="https://javaguide.cn/rss.xml">Shell 编程基础知识总结</source>
      <description>Shell 编程在我们的日常开发工作中非常实用，目前 Linux 系统下最流行的运维自动化语言就是 Shell 和 Python 了。 这篇文章我会简单总结一下 Shell 编程基础知识，带你入门 Shell 编程！ 走进 Shell 编程的大门 为什么要学 Shell？ 学一个东西，我们大部分情况都是往实用性方向着想。从工作角度来讲，学习 Shell 是为了提高我们自己工作效率，提高产出，让我们在更少的时间完成更多的事情。 很多人会说 Shell 编程属于运维方面的知识了，应该是运维人员来做，我们做后端开发的没必要学。我觉得这种说法大错特错，相比于专门做 Linux 运维的人员来说，我们对 Shell 编程掌握程度的要求要比他们低，但是 Shell 编程也是我们必须要掌握的！</description>
      <category>计算机基础</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<p>Shell 编程在我们的日常开发工作中非常实用，目前 Linux 系统下最流行的运维自动化语言就是 Shell 和 Python 了。</p>
<p>这篇文章我会简单总结一下 Shell 编程基础知识，带你入门 Shell 编程！</p>
<h2> 走进 Shell 编程的大门</h2>
<h3> 为什么要学 Shell？</h3>
<p>学一个东西，我们大部分情况都是往实用性方向着想。从工作角度来讲，学习 Shell 是为了提高我们自己工作效率，提高产出，让我们在更少的时间完成更多的事情。</p>
<p>很多人会说 Shell 编程属于运维方面的知识了，应该是运维人员来做，我们做后端开发的没必要学。我觉得这种说法大错特错，相比于专门做 Linux 运维的人员来说，我们对 Shell 编程掌握程度的要求要比他们低，但是 Shell 编程也是我们必须要掌握的！</p>
<p>目前 Linux 系统下最流行的运维自动化语言就是 Shell 和 Python 了。</p>
<p>两者之间，Shell 几乎是 IT 企业必须使用的运维自动化编程语言，特别是在运维工作中的服务监控、业务快速部署、服务启动停止、数据备份及处理、日志分析等环节里，shell 是不可缺的。Python 更适合处理复杂的业务逻辑，以及开发复杂的运维软件工具，实现通过 web 访问等。Shell 是一个命令解释器，解释执行用户所输入的命令和程序。一输入命令，就立即回应的交互的对话方式。</p>
<p>另外，了解 shell 编程也是大部分互联网公司招聘后端开发人员的要求。下图是我截取的一些知名互联网公司对于 Shell 编程的要求。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-11-16/60190220.jpg" alt="大型互联网公司对于shell编程技能的要求"></p>
<h3> 什么是 Shell？</h3>
<p>简单来说“Shell 编程就是对一堆 Linux 命令的逻辑化处理”。</p>
<p>W3Cschool 上的一篇文章是这样介绍 Shell 的，如下图所示。
<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-11-26/19456505.jpg" alt="什么是 Shell？"></p>
<h3> Shell 编程的 Hello World</h3>
<p>学习任何一门编程语言第一件事就是输出 HelloWorld 了！下面我会从新建文件到 shell 代码编写来说下 Shell 编程如何输出 Hello World。</p>
<p>(1)新建一个文件 helloworld.sh :<code>touch helloworld.sh</code>，扩展名为 sh（sh 代表 Shell）（扩展名并不影响脚本执行，见名知意就好，如果你用 php 写 shell 脚本，扩展名就用 php 好了）</p>
<p>(2) 使脚本具有执行权限：<code>chmod +x helloworld.sh</code></p>
<p>(3) 使用 vim 命令修改 helloworld.sh 文件：<code>vim helloworld.sh</code>(vim 文件------&gt;进入文件-----&gt;命令模式------&gt;按 i 进入编辑模式-----&gt;编辑文件 -------&gt;按 Esc 进入底行模式-----&gt;输入:wq/q! （输入 wq 代表写入内容并退出，即保存；输入 q!代表强制退出不保存。）)</p>
<p>helloworld.sh 内容如下：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>shell 中 # 符号表示注释。<strong>shell 的第一行比较特殊，一般都会以#!开始来指定使用的 shell 类型。在 linux 中，除了 bash shell 以外，还有很多版本的 shell， 例如 zsh、dash 等等...不过 bash shell 还是我们使用最多的。</strong></p>
<p>(4) 运行脚本:<code>./helloworld.sh</code> 。（注意，一定要写成 <code>./helloworld.sh</code> ，而不是 <code>helloworld.sh</code> ，运行其它二进制的程序也一样，直接写 <code>helloworld.sh</code> ，linux 系统会去 PATH 里寻找有没有叫 helloworld.sh 的，而只有 /bin, /sbin, /usr/bin，/usr/sbin 等在 PATH 里，你的当前目录通常不在 PATH 里，所以写成 <code>helloworld.sh</code> 是会找不到命令的，要用<code>./helloworld.sh</code> 告诉系统说，就在当前目录找。）</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-11-16/55296212.jpg" alt="shell 编程Hello World"></p>
<h2> Shell 变量</h2>
<h3> Shell 编程中的变量介绍</h3>
<p><strong>Shell 编程中一般分为三种变量：</strong></p>
<ol>
<li><strong>我们自己定义的变量（自定义变量）:</strong> 仅在当前 Shell 实例中有效，其他 Shell 启动的程序不能访问局部变量。</li>
<li><strong>Linux 已定义的环境变量</strong>（环境变量， 例如：<code>PATH</code>, ​<code>HOME</code> 等..., 这类变量我们可以直接使用），使用 <code>env</code> 命令可以查看所有的环境变量，而 set 命令既可以查看环境变量也可以查看自定义变量。</li>
<li><strong>Shell 变量</strong> ：Shell 变量是由 Shell 程序设置的特殊变量。Shell 变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了 Shell 的正常运行</li>
</ol>
<p><strong>常用的环境变量:</strong></p>
<blockquote>
<p>PATH 决定了 shell 将到哪些目录中寻找命令或程序<br>
HOME 当前用户主目录<br>
HISTSIZE 　历史记录数<br>
LOGNAME 当前用户的登录名<br>
HOSTNAME 　指主机的名称<br>
SHELL 当前用户 Shell 类型<br>
LANGUAGE 　语言相关的环境变量，多语言可以修改此环境变量<br>
MAIL 　当前用户的邮件存放目录<br>
PS1 　基本提示符，对于 root 用户是#，对于普通用户是$</p>
</blockquote>
<p><strong>使用 Linux 已定义的环境变量：</strong></p>
<p>比如我们要看当前用户目录可以使用：<code>echo $HOME</code>命令；如果我们要看当前用户 Shell 类型 可以使用<code>echo $SHELL</code>命令。可以看出，使用方法非常简单。</p>
<p><strong>使用自己定义的变量：</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-11-17/19835037.jpg" alt="使用自己定义的变量"></p>
<p><strong>Shell 编程中的变量名的命名的注意事项：</strong></p>
<ul>
<li>命名只能使用英文字母，数字和下划线，首个字符不能以数字开头，但是可以使用下划线（_）开头。</li>
<li>中间不能有空格，可以使用下划线（_）。</li>
<li>不能使用标点符号。</li>
<li>不能使用 bash 里的关键字（可用 help 命令查看保留关键字）。</li>
</ul>
<h3> Shell 字符串入门</h3>
<p>字符串是 shell 编程中最常用最有用的数据类型（除了数字和字符串，也没啥其它类型好用了），字符串可以用单引号，也可以用双引号。这点和 Java 中有所不同。</p>
<p>在单引号中所有的特殊符号，如$和反引号都没有特殊含义。在双引号中，除了"$",""和反引号，其他的字符没有特殊含义。</p>
<p><strong>单引号字符串：</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出内容：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>双引号字符串：</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出内容：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> Shell 字符串常见操作</h3>
<p><strong>拼接字符串：</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果：</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-11-17/51148933.jpg" alt="输出结果"></p>
<p><strong>获取字符串长度：</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果:</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>使用 expr 命令时，表达式中的运算符左右必须包含空格，如果不包含空格，将会输出表达式本身:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>对于某些运算符，还需要我们使用符号<code>\</code>进行转义，否则就会提示语法错误。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>截取子字符串:</strong></p>
<p>简单的字符串截取：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>根据表达式截取：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> Shell 数组</h3>
<p>bash 支持一维数组（不支持多维数组），并且没有限定数组的大小。我下面给了大家一个关于数组操作的 Shell 代码示例，通过该示例大家可以知道如何创建数组、获取数组长度、获取/删除特定位置的数组元素、删除整个数组以及遍历数组。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> Shell 基本运算符</h2>
<blockquote>
<p>说明：图片来自《菜鸟教程》</p>
</blockquote>
<p>Shell 编程支持下面几种运算符</p>
<ul>
<li>算数运算符</li>
<li>关系运算符</li>
<li>布尔运算符</li>
<li>字符串运算符</li>
<li>文件测试运算符</li>
</ul>
<h3> 算数运算符</h3>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-11-22/4937342.jpg" alt="算数运算符"></p>
<p>我以加法运算符做一个简单的示例（注意：不是单引号，是反引号）：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 关系运算符</h3>
<p>关系运算符只支持数字，不支持字符串，除非字符串的值是数字。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-11-22/64391380.jpg" alt="shell关系运算符"></p>
<p>通过一个简单的示例演示关系运算符的使用，下面 shell 程序的作用是当 score=100 的时候输出 A 否则输出 B。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 逻辑运算符</h3>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-11-22/60545848.jpg" alt="逻辑运算符"></p>
<p>示例：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 布尔运算符</h3>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-11-22/93961425.jpg" alt="布尔运算符"></p>
<p>这里就不做演示了，应该挺简单的。</p>
<h3> 字符串运算符</h3>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-11-22/309094.jpg" alt=" 字符串运算符"></p>
<p>简单示例：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 文件相关运算符</h3>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-11-22/60359774.jpg" alt="文件相关运算符"></p>
<p>使用方式很简单，比如我们定义好了一个文件路径<code>file="/usr/learnshell/test.sh"</code> 如果我们想判断这个文件是否可读，可以这样<code>if [ -r $file ]</code> 如果想判断这个文件是否可写，可以这样<code>-w $file</code>，是不是很简单。</p>
<h2> shell 流程控制</h2>
<h3> if 条件语句</h3>
<p>简单的 if else-if else 的条件语句示例</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>相信大家通过上面的示例就已经掌握了 shell 编程中的 if 条件语句。不过，还要提到的一点是，不同于我们常见的 Java 以及 PHP 中的 if 条件语句，shell if 条件语句中不能包含空语句也就是什么都不做的语句。</p>
<h3> for 循环语句</h3>
<p>通过下面三个简单的示例认识 for 循环语句最基本的使用，实际上 for 循环语句的功能比下面你看到的示例展现的要大得多。</p>
<p><strong>输出当前列表中的数据：</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>产生 10 个随机数：</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>输出 1 到 5:</strong></p>
<p>通常情况下 shell 变量调用需要加 $,但是 for 的 (()) 中不需要,下面来看一个例子：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> while 语句</h3>
<p><strong>基本的 while 循环语句：</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>while 循环可用于读取键盘信息：</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出内容:</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>无限循环：</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> shell 函数</h2>
<h3> 不带参数没有返回值的函数</h3>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 有返回值的函数</h3>
<p><strong>输入两个数字之后相加并返回结果：</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 带参数的函数</h3>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出结果：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
      <enclosure url="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-11-16/60190220.jpg" type="image/jpeg"/>
    </item>
    <item>
      <title>应用层常见协议总结（应用层）</title>
      <link>https://javaguide.cn/cs-basics/network/application-layer-protocol.html</link>
      <guid>https://javaguide.cn/cs-basics/network/application-layer-protocol.html</guid>
      <source url="https://javaguide.cn/rss.xml">应用层常见协议总结（应用层）</source>
      <description>HTTP:超文本传输协议 超文本传输协议（HTTP，HyperText Transfer Protocol) 主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。当我们使用浏览器浏览网页的时候，我们网页就是通过 HTTP 请求进行加载的，整个过程如下图所示。 HTTP 协是基于 TCP协议，发送 HTTP 请求之前首先要建立 TCP 连接也就是要经历 3 次握手。目前使用的 HTTP 协议大部分都是 1.1。在 1.1 的协议里面，默认是开启了 Keep-Alive 的，这样的话建立的连接就可以在多次请求中被复用了。</description>
      <category>计算机基础</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<h2> HTTP:超文本传输协议</h2>
<p><strong>超文本传输协议（HTTP，HyperText Transfer Protocol)</strong> 主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。当我们使用浏览器浏览网页的时候，我们网页就是通过 HTTP 请求进行加载的，整个过程如下图所示。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/450px-HTTP-Header.png" alt=""></p>
<p>HTTP 协是基于 TCP协议，发送 HTTP 请求之前首先要建立 TCP 连接也就是要经历 3 次握手。目前使用的 HTTP 协议大部分都是 1.1。在 1.1 的协议里面，默认是开启了 Keep-Alive 的，这样的话建立的连接就可以在多次请求中被复用了。</p>
<p>另外， HTTP 协议是”无状态”的协议，它无法记录客户端用户的状态，一般我们都是通过 Session 来记录客户端用户的状态。</p>
<h2> SMTP:简单邮件传输(发送)协议</h2>
<p><strong>简单邮件传输(发送)协议（SMTP，Simple Mail Transfer Protocol）</strong> 基于 TCP 协议，用来发送电子邮件。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/network/what-is-smtp.png" alt="SMTP 协议"></p>
<p>注意⚠️：<strong>接受邮件的协议不是 SMTP 而是 POP3 协议。</strong></p>
<p>SMTP 协议这块涉及的内容比较多，下面这两个问题比较重要：</p>
<ol>
<li>电子邮件的发送过程</li>
<li>如何判断邮箱是真正存在的？</li>
</ol>
<p><strong>电子邮件的发送过程？</strong></p>
<p>比如我的邮箱是“dabai@cszhinan.com”，我要向“xiaoma@qq.com”发送邮件，整个过程可以简单分为下面几步：</p>
<ol>
<li>通过 <strong>SMTP</strong>  协议，我将我写好的邮件交给163邮箱服务器（邮局）。</li>
<li>163邮箱服务器发现我发送的邮箱是qq邮箱，然后它使用 SMTP协议将我的邮件转发到 qq邮箱服务器。</li>
<li>qq邮箱服务器接收邮件之后就通知邮箱为“xiaoma@qq.com”的用户来收邮件，然后用户就通过 <strong>POP3/IMAP</strong> 协议将邮件取出。</li>
</ol>
<p><strong>如何判断邮箱是真正存在的？</strong></p>
<p>很多场景(比如邮件营销)下面我们需要判断我们要发送的邮箱地址是否真的存在，这个时候我们可以利用 SMTP 协议来检测：</p>
<ol>
<li>查找邮箱域名对应的  SMTP 服务器地址</li>
<li>尝试与服务器建立连接</li>
<li>连接成功后尝试向需要验证的邮箱发送邮件</li>
<li>根据返回结果判定邮箱地址的真实性</li>
</ol>
<p>推荐几个在线邮箱是否有效检测工具：</p>
<ol>
<li>https://verify-email.org/</li>
<li>http://tool.chacuo.net/mailverify</li>
<li>https://www.emailcamel.com/</li>
</ol>
<h2> POP3/IMAP:邮件接收的协议</h2>
<p>这两个协议没必要多做阐述，只需要了解 <strong>POP3 和 IMAP 两者都是负责邮件接收的协议</strong>即可。另外，需要注意不要将这两者和 SMTP 协议搞混淆了。<strong>SMTP 协议只负责邮件的发送，真正负责接收的协议是POP3/IMAP。</strong></p>
<p>IMAP 协议相比于POP3更新一点，为用户提供的可选功能也更多一点,几乎所有现代电子邮件客户端和服务器都支持IMAP。大部分网络邮件服务提供商都支持POP3和IMAP。</p>
<h2> FTP:文件传输协议</h2>
<p><strong>FTP 协议</strong> 主要提供文件传输服务，基于 TCP 实现可靠的传输。使用 FTP 传输文件的好处是可以屏蔽操作系统和文件存储方式。</p>
<p>FTP 是基于客户—服务器（C/S）模型而设计的，在客户端与 FTP 服务器之间建立两个连接。如果我们要基于 FTP 协议开发一个文件传输的软件的话，首先需要搞清楚 FTP 的原理。关于 FTP 的原理，很多书籍上已经描述的非常详细了：</p>
<blockquote>
<p>FTP 的独特的优势同时也是与其它客户服务器程序最大的不同点就在于它在两台通信的主机之间使用了两条 TCP 连接（其它客户服务器应用程序一般只有一条 TCP 连接）：</p>
<ol>
<li>控制连接：用于传送控制信息（命令和响应）</li>
<li>数据连接：用于数据传送；</li>
</ol>
<p>这种将命令和数据分开传送的思想大大提高了 FTP 的效率。</p>
</blockquote>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/计算机网络总结/ftp.png" alt="FTP工作过程"></p>
<h2> Telnet:远程登陆协议</h2>
<p><strong>Telnet 协议</strong> 通过一个终端登陆到其他服务器，建立在可靠的传输协议 TCP 之上。Telnet 协议的最大缺点之一是所有数据（包括用户名和密码）均以明文形式发送，这有潜在的安全风险。这就是为什么如今很少使用Telnet并被一种称为SSH的非常安全的协议所取代的主要原因。</p>
<h2> SSH:安全的网络传输协议</h2>
<p><strong>SSH（ Secure Shell）</strong> 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH  建立在可靠的传输协议 TCP 之上。</p>
<p><strong>Telnet 和 SSH 之间的主要区别在于 SSH 协议会对传输的数据进行加密保证数据安全性。</strong></p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/计算机网络总结/TCP和UDP.png" alt="TCP和UDP"></p>
]]></content:encoded>
      <enclosure url="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/450px-HTTP-Header.png" type="image/png"/>
    </item>
    <item>
      <title>ARP 协议详解(网络层)</title>
      <link>https://javaguide.cn/cs-basics/network/arp.html</link>
      <guid>https://javaguide.cn/cs-basics/network/arp.html</guid>
      <source url="https://javaguide.cn/rss.xml">ARP 协议详解(网络层)</source>
      <description>每当我们学习一个新的网络协议的时候，都要把他结合到 OSI 七层模型中，或者是 TCP/IP 协议栈中来学习，一是要学习该协议在整个网络协议栈中的位置，二是要学习该协议解决了什么问题，地位如何？三是要学习该协议的工作原理，以及一些更深入的细节。 ARP 协议，可以说是在协议栈中属于一个偏底层的、非常重要的、又非常简单的通信协议。 开始阅读这篇文章之前，你可以先看看下面几个问题： ARP 协议在协议栈中的位置？ ARP 协议在协议栈中的位置非常重要，在理解了它的工作原理之后，也很难说它到底是网络层协议，还是链路层协议，因为它恰恰串联起了网络层和链路层。国外的大部分教程通常将 ARP 协议放在网络层。 ARP 协议解决了什么问题，地位如何？ ARP 协议，全称 地址解析协议（Address Resolution Protocol），它解决的是网络层地址和链路层地址之间的转换问题。因为一个 IP 数据报在物理上传输的过程中，总是需要知道下一跳（物理上的下一个目的地）该去往何处，但 IP 地址属于逻辑地址，而 MAC 地址才是物理地址，ARP 协议解决了 IP 地址转 MAC 地址的一些问题。 ARP 工作原理？ 只希望大家记住几个关键词：ARP 表、广播问询、单播响应。</description>
      <category>计算机基础</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<p>每当我们学习一个新的网络协议的时候，都要把他结合到 OSI 七层模型中，或者是 TCP/IP 协议栈中来学习，一是要学习该协议在整个网络协议栈中的位置，二是要学习该协议解决了什么问题，地位如何？三是要学习该协议的工作原理，以及一些更深入的细节。</p>
<p><strong>ARP 协议</strong>，可以说是在协议栈中属于一个<strong>偏底层的、非常重要的、又非常简单的</strong>通信协议。</p>
<p>开始阅读这篇文章之前，你可以先看看下面几个问题：</p>
<ol>
<li><strong>ARP 协议在协议栈中的位置？</strong> ARP 协议在协议栈中的位置非常重要，在理解了它的工作原理之后，也很难说它到底是网络层协议，还是链路层协议，因为它恰恰串联起了网络层和链路层。国外的大部分教程通常将 ARP 协议放在网络层。</li>
<li><strong>ARP 协议解决了什么问题，地位如何？</strong> ARP 协议，全称 <strong>地址解析协议（Address Resolution Protocol）</strong>，它解决的是网络层地址和链路层地址之间的转换问题。因为一个 IP 数据报在物理上传输的过程中，总是需要知道下一跳（物理上的下一个目的地）该去往何处，但 IP 地址属于逻辑地址，而 MAC 地址才是物理地址，ARP 协议解决了 IP 地址转 MAC 地址的一些问题。</li>
<li><strong>ARP 工作原理？</strong> 只希望大家记住几个关键词：<strong>ARP 表、广播问询、单播响应</strong>。</li>
</ol>
<h2> MAC 地址</h2>
<p>在介绍 ARP 协议之前，有必要介绍一下 MAC 地址。</p>
<p>MAC 地址的全称是 <strong>媒体访问控制地址（Media Access Control Address）</strong>。如果说，互联网中每一个资源都由 IP 地址唯一标识（IP 协议内容），那么一切网络设备都由 MAC 地址唯一标识。</p>
<p></p>
<p>可以理解为，MAC 地址是一个网络设备真正的身份证号，IP 地址只是一种不重复的定位方式（比如说住在某省某市某街道的张三，这种逻辑定位是 IP 地址，他的身份证号才是他的 MAC 地址），也可以理解为 MAC 地址是身份证号，IP 地址是邮政地址。MAC 地址也有一些别称，如 LAN 地址、物理地址、以太网地址等。</p>
<blockquote>
<p>还有一点要知道的是，不仅仅是网络资源才有 IP 地址，网络设备也有 IP 地址，比如路由器。但从结构上说，路由器等网络设备的作用是组成一个网络，而且通常是内网，所以它们使用的 IP 地址通常是内网 IP，内网的设备在与内网以外的设备进行通信时，需要用到 NAT 协议。</p>
</blockquote>
<p>MAC 地址的长度为 6 字节（48 比特），地址空间大小有 280 万亿之多（$2^{48}$），MAC 地址由 IEEE 统一管理与分配，理论上，一个网络设备中的网卡上的 MAC 地址是永久的。不同的网卡生产商从 IEEE 那里购买自己的 MAC 地址空间（MAC 的前 24 比特），也就是前 24 比特由 IEEE 统一管理，保证不会重复。而后 24 比特，由各家生产商自己管理，同样保证生产的两块网卡的 MAC 地址不会重复。</p>
<p>MAC 地址具有可携带性、永久性，身份证号永久地标识一个人的身份，不论他到哪里都不会改变。而 IP 地址不具有这些性质，当一台设备更换了网络，它的 IP 地址也就可能发生改变，也就是它在互联网中的定位发生了变化。</p>
<p>最后，记住，MAC 地址有一个特殊地址：FF-FF-FF-FF-FF-FF（全 1 地址），该地址表示广播地址。</p>
<h2> ARP 协议工作原理</h2>
<p>ARP 协议工作时有一个大前提，那就是 <strong>ARP 表</strong>。</p>
<p>在一个局域网内，每个网络设备都自己维护了一个 ARP 表，ARP 表记录了某些其他网络设备的 IP 地址-MAC 地址映射关系，该映射关系以 <code>&lt;IP, MAC, TTL&gt;</code> 三元组的形式存储。其中，TTL 为该映射关系的生存周期，典型值为 20 分钟，超过该时间，该条目将被丢弃。</p>
<p>ARP 的工作原理将分两种场景讨论：</p>
<ol>
<li><strong>同一局域网内的 MAC 寻址</strong>；</li>
<li><strong>从一个局域网到另一个局域网中的网络设备的寻址</strong>。</li>
</ol>
<h3> 同一局域网内的 MAC 寻址</h3>
<p>假设当前有如下场景：IP 地址为<code>137.196.7.23</code>的主机 A，想要给同一局域网内的 IP 地址为<code>137.196.7.14</code>主机 B，发送 IP 数据报文。</p>
<blockquote>
<p>再次强调，当主机发送 IP 数据报文时（网络层），仅知道目的地的 IP 地址，并不清楚目的地的 MAC 地址，而 ARP 协议就是解决这一问题的。</p>
</blockquote>
<p>为了达成这一目标，主机 A 将不得不通过 ARP 协议来获取主机 B 的 MAC 地址，并将 IP 报文封装成链路层帧，发送到下一跳上。在该局域网内，关于此将按照时间顺序，依次发生如下事件：</p>
<ol>
<li>
<p>主机 A 检索自己的 ARP 表，发现 ARP 表中并无主机 B 的 IP 地址对应的映射条目，也就无从知道主机 B 的 MAC 地址。</p>
</li>
<li>
<p>主机 A 将构造一个 ARP 查询分组，并将其广播到所在的局域网中。</p>
<p>ARP 分组是一种特殊报文，ARP 分组有两类，一种是查询分组，另一种是响应分组，它们具有相同的格式，均包含了发送和接收的 IP 地址、发送和接收的 MAC 地址。当然了，查询分组中，发送的 IP 地址，即为主机 A 的 IP 地址，接收的 IP 地址即为主机 B 的 IP 地址，发送的 MAC 地址也是主机 A 的 MAC 地址，但接收的 MAC 地址绝不会是主机 B 的 MAC 地址（因为这正是我们要问询的！），而是一个特殊值——<code>FF-FF-FF-FF-FF-FF</code>，之前说过，该 MAC 地址是广播地址，也就是说，查询分组将广播给该局域网内的所有设备。</p>
</li>
<li>
<p>主机 A 构造的查询分组将在该局域网内广播，理论上，每一个设备都会收到该分组，并检查查询分组的接收 IP 地址是否为自己的 IP 地址，如果是，说明查询分组已经到达了主机 B，否则，该查询分组对当前设备无效，丢弃之。</p>
</li>
<li>
<p>主机 B 收到了查询分组之后，验证是对自己的问询，接着构造一个 ARP 响应分组，该分组的目的地只有一个——主机 A，发送给主机 A。同时，主机 B 提取查询分组中的 IP 地址和 MAC 地址信息，在自己的 ARP 表中构造一条主机 A 的 IP-MAC 映射记录。</p>
<p>ARP 响应分组具有和 ARP 查询分组相同的构造，不同的是，发送和接受的 IP 地址恰恰相反，发送的 MAC 地址为发送者本身，目标 MAC 地址为查询分组的发送者，也就是说，ARP 响应分组只有一个目的地，而非广播。</p>
</li>
<li>
<p>主机 A 终将收到主机 B 的响应分组，提取出该分组中的 IP 地址和 MAC 地址后，构造映射信息，加入到自己的 ARP 表中。</p>
</li>
</ol>
<p></p>
<p>在整个过程中，有几点需要补充说明的是：</p>
<ol>
<li>主机 A 想要给主机 B 发送 IP 数据报，如果主机 B 的 IP-MAC 映射信息已经存在于主机 A 的 ARP 表中，那么主机 A 无需广播，只需提取 MAC 地址并构造链路层帧发送即可。</li>
<li>ARP 表中的映射信息是有生存周期的，典型值为 20 分钟。</li>
<li>目标主机接收到了问询主机构造的问询报文后，将先把问询主机的 IP-MAC 映射存进自己的 ARP 表中，这样才能获取到响应的目标 MAC 地址，顺利的发送响应分组。</li>
</ol>
<p>总结来说，ARP 协议是一个<strong>广播问询，单播响应</strong>协议。</p>
<h3> 不同局域网内的 MAC 寻址</h3>
<p>更复杂的情况是，发送主机 A 和接收主机 B 不在同一个子网中，假设一个一般场景，两台主机所在的子网由一台路由器联通。这里需要注意的是，一般情况下，我们说网络设备都有一个 IP 地址和一个 MAC 地址，这里说的网络设备，更严谨的说法应该是一个接口。路由器作为互联设备，具有多个接口，每个接口同样也应该具备不重复的 IP 地址和 MAC 地址。因此，在讨论 ARP 表时，路由器的多个接口都个各自维护一个 ARP 表，而非一个路由器只维护一个 ARP 表。</p>
<p>接下来，回顾同一子网内的 MAC 寻址，如果主机 A 发送一个广播问询分组，那么 A 所在子网内的所有设备（接口）都将不会捕获该分组，因为该分组的目的 IP 地址在另一个子网中，本子网内不会有设备成功接收。那么，主机 A 应该发送怎样的查询分组呢？整个过程按照时间顺序发生的事件如下：</p>
<ol>
<li>
<p>主机 A 查询 ARP 表，期望寻找到目标路由器的本子网接口的 MAC 地址。</p>
<p>目标路由器指的是，根据目的主机 B 的 IP 地址，分析出 B 所在的子网，能够把报文转发到 B 所在子网的那个路由器。</p>
</li>
<li>
<p>主机 A 未能找到目标路由器的本子网接口的 MAC 地址，将采用 ARP 协议，问询到该 MAC 地址，由于目标接口与主机 A 在同一个子网内，该过程与同一局域网内的 MAC 寻址相同。</p>
</li>
<li>
<p>主机 A 获取到目标接口的 MAC 地址，先构造 IP 数据报，其中源 IP 是 A 的 IP 地址，目的 IP 地址是 B 的 IP 地址，再构造链路层帧，其中源 MAC 地址是 A 的 MAC 地址，目的 MAC 地址是<strong>本子网内与路由器连接的接口的 MAC 地址</strong>。主机 A 将把这个链路层帧，以单播的方式，发送给目标接口。</p>
</li>
<li>
<p>目标接口接收到了主机 A 发过来的链路层帧，解析，根据目的 IP 地址，查询转发表，将该 IP 数据报转发到与主机 B 所在子网相连的接口上。</p>
<p>到此，该帧已经从主机 A 所在的子网，转移到了主机 B 所在的子网了。</p>
</li>
<li>
<p>路由器接口查询 ARP 表，期望寻找到主机 B 的 MAC 地址。</p>
</li>
<li>
<p>路由器接口如未能找到主机 B 的 MAC 地址，将采用 ARP 协议，广播问询，单播响应，获取到主机 B 的 MAC 地址。</p>
</li>
<li>
<p>路由器接口将对 IP 数据报重新封装成链路层帧，目标 MAC 地址为主机 B 的 MAC 地址，单播发送，直到目的地。</p>
</li>
</ol>
<p></p>
]]></content:encoded>
    </item>
    <item>
      <title>《计算机网络》（谢希仁）内容总结</title>
      <link>https://javaguide.cn/cs-basics/network/computer-network-xiexiren-summary.html</link>
      <guid>https://javaguide.cn/cs-basics/network/computer-network-xiexiren-summary.html</guid>
      <source url="https://javaguide.cn/rss.xml">《计算机网络》（谢希仁）内容总结</source>
      <description>本文是我在大二学习计算机网络期间整理， 大部分内容都来自于谢希仁老师的《计算机网络》第七版 这本书。为了内容更容易理解，我对之前的整理进行了一波重构，并配上了一些相关的示意图便于理解。</description>
      <category>计算机基础</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<p>本文是我在大二学习计算机网络期间整理， 大部分内容都来自于谢希仁老师的<a href="https://www.elias.ltd/usr/local/etc/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E7%AC%AC7%E7%89%88%EF%BC%89%E8%B0%A2%E5%B8%8C%E4%BB%81.pdf" target="_blank" rel="noopener noreferrer">《计算机网络》第七版 </a>这本书。为了内容更容易理解，我对之前的整理进行了一波重构，并配上了一些相关的示意图便于理解。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/network/computer-network-xiexiren.png" alt=""></p>
<p>相关问题：<a href="https://www.zhihu.com/question/327872966" target="_blank" rel="noopener noreferrer">如何评价谢希仁的计算机网络（第七版）？ - 知乎</a>  。</p>
<h2> 1. 计算机网络概述</h2>
<h3> 1.1. 基本术语</h3>
<ol>
<li><strong>结点 （node）</strong> ：网络中的结点可以是计算机，集线器，交换机或路由器等。</li>
<li><strong>链路（link ）</strong> : 从一个结点到另一个结点的一段物理线路。中间没有任何其他交点。</li>
<li><strong>主机（host）</strong> ：连接在因特网上的计算机。</li>
<li><strong>ISP（Internet Service Provider）</strong> ：因特网服务提供者（提供商）。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/img_convert/b83f6951e3f8f4bcde5b227257d603a8.png" alt="ISP (Internet Service Provider) Definition"></p>
<ol start="5">
<li><strong>IXP（Internet eXchange Point）</strong> ： 互联网交换点 IXP 的主要作用就是允许两个网络直接相连并交换分组，而不需要再通过第三个网络来转发分组。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/img_convert/7a9568a9e94001fc110801addc8c4ec0.png" alt="IXP Traffic Levels During the Stratos Skydive — RIPE Labs"></p>
<p style="text-align:center;font-size:13px;color:gray">https://labs.ripe.net/Members/fergalc/ixp-traffic-during-stratos-skydive</p>
<ol start="6">
<li><strong>RFC(Request For Comments)</strong> ：意思是“请求评议”，包含了关于 Internet 几乎所有的重要的文字资料。</li>
<li><strong>广域网 WAN（Wide Area Network）</strong> ：任务是通过长距离运送主机发送的数据。</li>
<li><strong>城域网 MAN（Metropolitan Area Network）</strong>：用来将多个局域网进行互连。</li>
<li><strong>局域网 LAN（Local Area Network）</strong> ： 学校或企业大多拥有多个互连的局域网。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/img_convert/25a5789f8e18995c649f2f864d51e7a9.png" alt="MAN &amp; WMAN | Red de área metropolitana, Redes informaticas, Par trenzado"></p>
<p style="text-align:center;font-size:13px;color:gray">http://conexionesmanwman.blogspot.com/</p>
<ol start="10">
<li><strong>个人区域网 PAN（Personal Area Network）</strong> ：在个人工作的地方把属于个人使用的电子设备用无线技术连接起来的网络 。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/img_convert/5c99dd6011439b1fab6cd2fece155dd5.png" alt="Advantages and disadvantages of personal area network (PAN) - IT Release"></p>
<p style="text-align:center;font-size:13px;color:gray">https://www.itrelease.com/2018/07/advantages-and-disadvantages-of-personal-area-network-pan/</p>
<ol start="12">
<li><strong>分组（packet ）</strong> ：因特网中传送的数据单元。由首部 header 和数据段组成。分组又称为包，首部可称为包头。</li>
<li><strong>存储转发（store and forward ）</strong> ：路由器收到一个分组，先检查分组是否正确，并过滤掉冲突包错误。确定包正确后，取出目的地址，通过查找表找到想要发送的输出端口地址，然后将该包发送出去。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20201025142342169.gif#pic_center" alt=""></p>
<ol start="14">
<li><strong>带宽（bandwidth）</strong> ：在计算机网络中，表示在单位时间内从网络中的某一点到另一点所能通过的“最高数据率”。常用来表示网络的通信线路所能传送数据的能力。单位是“比特每秒”，记为 b/s。</li>
<li><strong>吞吐量（throughput ）</strong> ：表示在单位时间内通过某个网络（或信道、接口）的数据量。吞吐量更经常地用于对现实世界中的网络的一种测量，以便知道实际上到底有多少数据量能够通过网络。吞吐量受网络的带宽或网络的额定速率的限制。</li>
</ol>
<h3> 1.2. 重要知识点总结</h3>
<ol>
<li><strong>计算机网络（简称网络）把许多计算机连接在一起，而互联网把许多网络连接在一起，是网络的网络。</strong></li>
<li>小写字母 i 开头的 internet（互联网）是通用名词，它泛指由多个计算机网络相互连接而成的网络。在这些网络之间的通信协议（即通信规则）可以是任意的。大写字母 I 开头的 Internet（互联网）是专用名词，它指全球最大的，开放的，由众多网络相互连接而成的特定的互联网，并采用 TCP/IP 协议作为通信规则，其前身为 ARPANET。Internet 的推荐译名为因特网，现在一般流行称为互联网。</li>
<li>路由器是实现分组交换的关键构件，其任务是转发收到的分组，这是网络核心部分最重要的功能。分组交换采用存储转发技术，表示把一个报文（要发送的整块数据）分为几个分组后再进行传送。在发送报文之前，先把较长的报文划分成为一个个更小的等长数据段。在每个数据端的前面加上一些由必要的控制信息组成的首部后，就构成了一个分组。分组又称为包。分组是在互联网中传送的数据单元，正是由于分组的头部包含了诸如目的地址和源地址等重要控制信息，每一个分组才能在互联网中独立的选择传输路径，并正确地交付到分组传输的终点。</li>
<li>互联网按工作方式可划分为边缘部分和核心部分。主机在网络的边缘部分，其作用是进行信息处理。由大量网络和连接这些网络的路由器组成核心部分，其作用是提供连通性和交换。</li>
<li>计算机通信是计算机中进程（即运行着的程序）之间的通信。计算机网络采用的通信方式是客户-服务器方式（C/S 方式）和对等连接方式（P2P 方式）。</li>
<li>客户和服务器都是指通信中所涉及的应用进程。客户是服务请求方，服务器是服务提供方。</li>
<li>按照作用范围的不同，计算机网络分为广域网 WAN，城域网 MAN，局域网 LAN，个人区域网 PAN。</li>
<li><strong>计算机网络最常用的性能指标是：速率，带宽，吞吐量，时延（发送时延，处理时延，排队时延），时延带宽积，往返时间和信道利用率。</strong></li>
<li>网络协议即协议，是为进行网络中的数据交换而建立的规则。计算机网络的各层以及其协议集合，称为网络的体系结构。</li>
<li><strong>五层体系结构由应用层，运输层，网络层（网际层），数据链路层，物理层组成。运输层最主要的协议是 TCP 和 UDP 协议，网络层最重要的协议是 IP 协议。</strong></li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/2020102514243717.png#pic_center" alt="s"></p>
<p>下面的内容会介绍计算机网络的五层体系结构：<strong>物理层+数据链路层+网络层（网际层）+运输层+应用层</strong>。</p>
<h2> 2. 物理层（Physical Layer）</h2>
<p><img src="https://img-blog.csdnimg.cn/img_convert/4749289d6e152bab1c8a8ccfc946a797.png" alt="物理层"></p>
<h3> 2.1. 基本术语</h3>
<ol>
<li><strong>数据（data）</strong> :运送消息的实体。</li>
<li><strong>信号（signal）</strong> ：数据的电气的或电磁的表现。或者说信号是适合在传输介质上传输的对象。</li>
<li><strong>码元（ code）</strong> ：在使用时间域（或简称为时域）的波形来表示数字信号时，代表不同离散数值的基本波形。</li>
<li><strong>单工（simplex ）</strong> : 只能有一个方向的通信而没有反方向的交互。</li>
<li><strong>半双工（half duplex ）</strong> ：通信的双方都可以发送信息，但不能双方同时发送(当然也就不能同时接收)。</li>
<li><strong>全双工（full duplex）</strong> : 通信的双方可以同时发送和接收信息。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/img_convert/c5be4756d2d6f46cbb6d785d5b86faf1.png" alt=""></p>
<ol start="7">
<li><strong>失真</strong>：失去真实性，主要是指接受到的信号和发送的信号不同，有磨损和衰减。影响失真程度的因素：1.码元传输速率 2.信号传输距离 3.噪声干扰 4.传输媒体质量</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/img_convert/aef3aac72e86c1ee6ccb8a91647f656c.png" alt=""></p>
<ol start="8">
<li><strong>奈氏准则</strong> : 在任何信道中，码元的传输的效率是有上限的，传输速率超过此上限，就会出现严重的码间串扰问题，使接收端对码元的判决（即识别）成为不可能。</li>
<li><strong>香农定理</strong> ：在带宽受限且有噪声的信道中，为了不产生误差，信息的数据传输速率有上限值。</li>
<li><strong>基带信号（baseband signal）</strong> : 来自信源的信号。指没有经过调制的数字信号或模拟信号。</li>
<li><strong>带通（频带）信号（bandpass signal）</strong> ：把基带信号经过载波调制后，把信号的频率范围搬移到较高的频段以便在信道中传输（即仅在一段频率范围内能够通过信道），这里调制过后的信号就是带通信号。</li>
<li><strong>调制（modulation ）</strong> : 对信号源的信息进行处理后加到载波信号上，使其变为适合在信道传输的形式的过程。</li>
<li><strong>信噪比（signal-to-noise ratio ）</strong> : 指信号的平均功率和噪声的平均功率之比，记为 S/N。信噪比（dB）=10*log10（S/N）。</li>
<li><strong>信道复用（channel multiplexing ）</strong> ：指多个用户共享同一个信道。（并不一定是同时）。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/img_convert/a4889adaad3314f882e2cfab5f382064.png" alt="信道复用技术"></p>
<ol start="15">
<li><strong>比特率（bit rate ）</strong> ：单位时间（每秒）内传送的比特数。</li>
<li><strong>波特率（baud rate）</strong> ：单位时间载波调制状态改变的次数。针对数据信号对载波的调制速率。</li>
<li><strong>复用（multiplexing）</strong> ：共享信道的方法。</li>
<li><strong>ADSL（Asymmetric Digital Subscriber Line ）</strong> ：非对称数字用户线。</li>
<li><strong>光纤同轴混合网（HFC 网）</strong> :在目前覆盖范围很广的有线电视网的基础上开发的一种居民宽带接入网</li>
</ol>
<h3> 2.2. 重要知识点总结</h3>
<ol>
<li><strong>物理层的主要任务就是确定与传输媒体接口有关的一些特性，如机械特性，电气特性，功能特性，过程特性。</strong></li>
<li>一个数据通信系统可划分为三大部分，即源系统，传输系统，目的系统。源系统包括源点（或源站，信源）和发送器，目的系统包括接收器和终点。</li>
<li><strong>通信的目的是传送消息。如话音，文字，图像等都是消息，数据是运送消息的实体。信号则是数据的电气或电磁的表现。</strong></li>
<li>根据信号中代表消息的参数的取值方式不同，信号可分为模拟信号（或连续信号）和数字信号（或离散信号）。在使用时间域（简称时域）的波形表示数字信号时，代表不同离散数值的基本波形称为码元。</li>
<li>根据双方信息交互的方式，通信可划分为单向通信（或单工通信），双向交替通信（或半双工通信），双向同时通信（全双工通信）。</li>
<li>来自信源的信号称为基带信号。信号要在信道上传输就要经过调制。调制有基带调制和带通调制之分。最基本的带通调制方法有调幅，调频和调相。还有更复杂的调制方法，如正交振幅调制。</li>
<li>要提高数据在信道上的传递速率，可以使用更好的传输媒体，或使用先进的调制技术。但数据传输速率不可能任意被提高。</li>
<li>传输媒体可分为两大类，即导引型传输媒体（双绞线，同轴电缆，光纤）和非导引型传输媒体（无线，红外，大气激光）。</li>
<li>为了有效利用光纤资源，在光纤干线和用户之间广泛使用无源光网络 PON。无源光网络无需配备电源，其长期运营成本和管理成本都很低。最流行的无源光网络是以太网无源光网络 EPON 和吉比特无源光网络 GPON。</li>
</ol>
<h3> 2.3. 补充</h3>
<h4> 2.3.1. 物理层主要做啥？</h4>
<p>物理层主要做的事情就是 <strong>透明地传送比特流</strong>。也可以将物理层的主要任务描述为确定与传输媒体的接口的一些特性，即：机械特性（接口所用接线器的一些物理属性如形状和尺寸），电气特性（接口电缆的各条线上出现的电压的范围），功能特性（某条线上出现的某一电平的电压的意义），过程特性（对于不同功能的各种可能事件的出现顺序）。</p>
<p><strong>物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。</strong> 现有的计算机网络中的硬件设备和传输媒体的种类非常繁多，而且通信手段也有许多不同的方式。物理层的作用正是尽可能地屏蔽掉这些传输媒体和通信手段的差异，使物理层上面的数据链路层感觉不到这些差异，这样就可以使数据链路层只考虑完成本层的协议和服务，而不必考虑网络的具体传输媒体和通信手段是什么。</p>
<h4> 2.3.2. 几种常用的信道复用技术</h4>
<ol>
<li><strong>频分复用(FDM)</strong> ：所有用户在同样的时间占用不同的带宽资源。</li>
<li><strong>时分复用（TDM）</strong> ：所有用户在不同的时间占用同样的频带宽度（分时不分频）。</li>
<li><strong>统计时分复用 (Statistic TDM)</strong> ：改进的时分复用，能够明显提高信道的利用率。</li>
<li><strong>码分复用(CDM)</strong> ： 用户使用经过特殊挑选的不同码型，因此各用户之间不会造成干扰。这种系统发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现。</li>
<li><strong>波分复用( WDM)</strong> ：波分复用就是光的频分复用。</li>
</ol>
<h4> 2.3.3. 几种常用的宽带接入技术，主要是 ADSL 和 FTTx</h4>
<p>用户到互联网的宽带接入方法有非对称数字用户线 ADSL（用数字技术对现有的模拟电话线进行改造，而不需要重新布线。ADSL 的快速版本是甚高速数字用户线 VDSL。），光纤同轴混合网 HFC（是在目前覆盖范围很广的有线电视网的基础上开发的一种居民宽带接入网）和 FTTx（即光纤到······）。</p>
<h2> 3. 数据链路层（Data Link Layer）</h2>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/java-guide-blog/2-data-link-layer.svg" alt="数据链路层"></p>
<h3> 3.1. 基本术语</h3>
<ol>
<li><strong>链路（link）</strong> ：一个结点到相邻结点的一段物理链路。</li>
<li><strong>数据链路（data link）</strong> ：把实现控制数据运输的协议的硬件和软件加到链路上就构成了数据链路。</li>
<li><strong>循环冗余检验 CRC（Cyclic Redundancy Check）</strong> ：为了保证数据传输的可靠性，CRC 是数据链路层广泛使用的一种检错技术。</li>
<li><strong>帧（frame）</strong> ：一个数据链路层的传输单元，由一个数据链路层首部和其携带的封包所组成协议数据单元。</li>
<li><strong>MTU（Maximum Transfer Uint ）</strong> ：最大传送单元。帧的数据部分的的长度上限。</li>
<li><strong>误码率 BER（Bit Error Rate ）</strong> ：在一段时间内，传输错误的比特占所传输比特总数的比率。</li>
<li><strong>PPP（Point-to-Point Protocol ）</strong> ：点对点协议。即用户计算机和 ISP 进行通信时所使用的数据链路层协议。以下是 PPP 帧的示意图：
<img src="https://img-blog.csdnimg.cn/img_convert/298dbdeb16f98cec02c3954d8d95c1d6.png" alt="PPP"></li>
<li><strong>MAC 地址（Media Access Control 或者 Medium Access Control）</strong> ：意译为媒体访问控制，或称为物理地址、硬件地址，用来定义网络设备的位置。在 OSI 模型中，第三层网络层负责 IP 地址，第二层数据链路层则负责 MAC 地址。因此一个主机会有一个 MAC 地址，而每个网络位置会有一个专属于它的 IP 地址 。地址是识别某个系统的重要标识符，“名字指出我们所要寻找的资源，地址指出资源所在的地方，路由告诉我们如何到达该处。”</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/img_convert/002b2e6e45d66e805008fafc310afef0.png" alt="ARP (Address Resolution Protocol) explained"></p>
<ol start="9">
<li><strong>网桥（bridge）</strong> ：一种用于数据链路层实现中继，连接两个或多个局域网的网络互连设备。</li>
<li><strong>交换机（switch ）</strong> ：广义的来说，交换机指的是一种通信系统中完成信息交换的设备。这里工作在数据链路层的交换机指的是交换式集线器，其实质是一个多接口的网桥</li>
</ol>
<h3> 3.2. 重要知识点总结</h3>
<ol>
<li>链路是从一个结点到相邻结点的一段物理链路，数据链路则在链路的基础上增加了一些必要的硬件（如网络适配器）和软件（如协议的实现）</li>
<li>数据链路层使用的主要是<strong>点对点信道</strong>和<strong>广播信道</strong>两种。</li>
<li>数据链路层传输的协议数据单元是帧。数据链路层的三个基本问题是：<strong>封装成帧</strong>，<strong>透明传输</strong>和<strong>差错检测</strong></li>
<li><strong>循环冗余检验 CRC</strong> 是一种检错方法，而帧检验序列 FCS 是添加在数据后面的冗余码</li>
<li><strong>点对点协议 PPP</strong> 是数据链路层使用最多的一种协议，它的特点是：简单，只检测差错而不去纠正差错，不使用序号，也不进行流量控制，可同时支持多种网络层协议</li>
<li>PPPoE 是为宽带上网的主机使用的链路层协议</li>
<li><strong>局域网的优点是：具有广播功能，从一个站点可方便地访问全网；便于系统的扩展和逐渐演变；提高了系统的可靠性，可用性和生存性。</strong></li>
<li>计算机与外接局域网通信需要通过通信适配器（或网络适配器），它又称为网络接口卡或网卡。<strong>计算器的硬件地址就在适配器的 ROM 中</strong>。</li>
<li>以太网采用的无连接的工作方式，对发送的数据帧不进行编号，也不要求对方发回确认。目的站收到有差错帧就把它丢掉，其他什么也不做</li>
<li>以太网采用的协议是具有冲突检测的<strong>载波监听多点接入 CSMA/CD</strong>。协议的特点是：<strong>发送前先监听，边发送边监听，一旦发现总线上出现了碰撞，就立即停止发送。然后按照退避算法等待一段随机时间后再次发送。</strong> 因此，每一个站点在自己发送数据之后的一小段时间内，存在着遭遇碰撞的可能性。以太网上的各站点平等地争用以太网信道</li>
<li>以太网的适配器具有过滤功能，它只接收单播帧，广播帧和多播帧。</li>
<li>使用集线器可以在物理层扩展以太网（扩展后的以太网仍然是一个网络）</li>
</ol>
<h3> 3.3. 补充</h3>
<ol>
<li>数据链路层的点对点信道和广播信道的特点，以及这两种信道所使用的协议（PPP 协议以及 CSMA/CD 协议）的特点</li>
<li>数据链路层的三个基本问题：<strong>封装成帧</strong>，<strong>透明传输</strong>，<strong>差错检测</strong></li>
<li>以太网的 MAC 层硬件地址</li>
<li>适配器，转发器，集线器，网桥，以太网交换机的作用以及适用场合</li>
</ol>
<h2> 4. 网络层（Network Layer）</h2>
<p><img src="https://img-blog.csdnimg.cn/img_convert/fbf78bdcf3db11526ac1a234a8b98234.png" alt="网络层"></p>
<h3> 4.1. 基本术语</h3>
<ol>
<li><strong>虚电路（Virtual Circuit）</strong> : 在两个终端设备的逻辑或物理端口之间，通过建立的双向的透明传输通道。虚电路表示这只是一条逻辑上的连接，分组都沿着这条逻辑连接按照存储转发方式传送，而并不是真正建立了一条物理连接。</li>
<li><strong>IP（Internet Protocol ）</strong> : 网际协议 IP 是 TCP/IP 体系中两个最主要的协议之一，是 TCP/IP 体系结构网际层的核心。配套的有 ARP，RARP，ICMP，IGMP。</li>
<li><strong>ARP（Address Resolution Protocol）</strong> : 地址解析协议。地址解析协议 ARP 把 IP 地址解析为硬件地址。</li>
<li><strong>ICMP（Internet Control Message Protocol ）</strong> ：网际控制报文协议 （ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告）。</li>
<li><strong>子网掩码（subnet mask ）</strong> ：它是一种用来指明一个 IP 地址的哪些位标识的是主机所在的子网以及哪些位标识的是主机的位掩码。子网掩码不能单独存在，它必须结合 IP 地址一起使用。</li>
<li><strong>CIDR（ Classless Inter-Domain Routing ）</strong>：无分类域间路由选择 （特点是消除了传统的 A 类、B 类和 C 类地址以及划分子网的概念，并使用各种长度的“网络前缀”(network-prefix)来代替分类地址中的网络号和子网号）。</li>
<li><strong>默认路由（default route）</strong> ：当在路由表中查不到能到达目的地址的路由时，路由器选择的路由。默认路由还可以减小路由表所占用的空间和搜索路由表所用的时间。</li>
<li><strong>路由选择算法（Virtual Circuit）</strong> ：路由选择协议的核心部分。因特网采用自适应的，分层次的路由选择协议。</li>
</ol>
<h3> 4.2. 重要知识点总结</h3>
<ol>
<li><strong>TCP/IP 协议中的网络层向上只提供简单灵活的，无连接的，尽最大努力交付的数据报服务。网络层不提供服务质量的承诺，不保证分组交付的时限所传送的分组可能出错，丢失，重复和失序。进程之间通信的可靠性由运输层负责</strong></li>
<li>在互联网的交付有两种，一是在本网络直接交付不用经过路由器，另一种是和其他网络的间接交付，至少经过一个路由器，但最后一次一定是直接交付</li>
<li>分类的 IP 地址由网络号字段（指明网络）和主机号字段（指明主机）组成。网络号字段最前面的类别指明 IP 地址的类别。IP 地址是一种分等级的地址结构。IP 地址管理机构分配 IP 地址时只分配网络号，主机号由得到该网络号的单位自行分配。路由器根据目的主机所连接的网络号来转发分组。一个路由器至少连接到两个网络，所以一个路由器至少应当有两个不同的 IP 地址</li>
<li>IP 数据报分为首部和数据两部分。首部的前一部分是固定长度，共 20 字节，是所有 IP 数据包必须具有的（源地址，目的地址，总长度等重要地段都固定在首部）。一些长度可变的可选字段固定在首部的后面。IP 首部中的生存时间给出了 IP 数据报在互联网中所能经过的最大路由器数。可防止 IP 数据报在互联网中无限制的兜圈子。</li>
<li><strong>地址解析协议 ARP 把 IP 地址解析为硬件地址。ARP 的高速缓存可以大大减少网络上的通信量。因为这样可以使主机下次再与同样地址的主机通信时，可以直接从高速缓存中找到所需要的硬件地址而不需要再去以广播方式发送 ARP 请求分组</strong></li>
<li>无分类域间路由选择 CIDR 是解决目前 IP 地址紧缺的一个好办法。CIDR 记法在 IP 地址后面加上斜线“/”，然后写上前缀所占的位数。前缀（或网络前缀）用来指明网络，前缀后面的部分是后缀，用来指明主机。CIDR 把前缀都相同的连续的 IP 地址组成一个“CIDR 地址块”，IP 地址分配都以 CIDR 地址块为单位。</li>
<li>网际控制报文协议是 IP 层的协议。ICMP 报文作为 IP 数据报的数据，加上首部后组成 IP 数据报发送出去。使用 ICMP 数据报并不是为了实现可靠传输。ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告。ICMP 报文的种类有两种，即 ICMP 差错报告报文和 ICMP 询问报文。</li>
<li><strong>要解决 IP 地址耗尽的问题，最根本的办法是采用具有更大地址空间的新版本 IP 协议-IPv6。</strong> IPv6 所带来的变化有 ① 更大的地址空间（采用 128 位地址）② 灵活的首部格式 ③ 改进的选项 ④ 支持即插即用 ⑤ 支持资源的预分配 ⑥IPv6 的首部改为 8 字节对齐。</li>
<li><strong>虚拟专用网络 VPN 利用公用的互联网作为本机构专用网之间的通信载体。VPN 内使用互联网的专用地址。一个 VPN 至少要有一个路由器具有合法的全球 IP 地址，这样才能和本系统的另一个 VPN 通过互联网进行通信。所有通过互联网传送的数据都需要加密。</strong></li>
<li>MPLS 的特点是：① 支持面向连接的服务质量 ② 支持流量工程，平衡网络负载 ③ 有效的支持虚拟专用网 VPN。MPLS 在入口节点给每一个 IP 数据报打上固定长度的“标记”，然后根据标记在第二层（链路层）用硬件进行转发（在标记交换路由器中进行标记交换），因而转发速率大大加快。</li>
</ol>
<h2> 5. 传输层（Transport Layer）</h2>
<p><img src="https://img-blog.csdnimg.cn/img_convert/09eb87a29bed99775ef5bde5eb216971.png" alt="传输层"></p>
<h3> 5.1. 基本术语</h3>
<ol>
<li><strong>进程（process）</strong> ：指计算机中正在运行的程序实体。</li>
<li><strong>应用进程互相通信</strong> ：一台主机的进程和另一台主机中的一个进程交换数据的过程（另外注意通信真正的端点不是主机而是主机中的进程，也就是说端到端的通信是应用进程之间的通信）。</li>
<li><strong>传输层的复用与分用</strong> ：复用指发送方不同的进程都可以通过同一个运输层协议传送数据。分用指接收方的运输层在剥去报文的首部后能把这些数据正确的交付到目的应用进程。</li>
<li><strong>TCP（Transmission Control Protocol）</strong> ：传输控制协议。</li>
<li><strong>UDP（User Datagram Protocol）</strong> ：用户数据报协议。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/img_convert/2bd5bf90676c338864807ade87b7bdea.png" alt="TCP和UDP"></p>
<ol start="6">
<li><strong>端口（port）</strong> ：端口的目的是为了确认对方机器的哪个进程在与自己进行交互，比如 MSN 和 QQ 的端口不同，如果没有端口就可能出现 QQ 进程和 MSN 交互错误。端口又称协议端口号。</li>
<li><strong>停止等待协议（stop-and-wait）</strong> ：指发送方每发送完一个分组就停止发送，等待对方确认，在收到确认之后在发送下一个分组。</li>
<li><strong>流量控制</strong> : 就是让发送方的发送速率不要太快，既要让接收方来得及接收，也不要使网络发生拥塞。</li>
<li><strong>拥塞控制</strong> ：防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。</li>
</ol>
<h3> 5.2. 重要知识点总结</h3>
<ol>
<li><strong>运输层提供应用进程之间的逻辑通信，也就是说，运输层之间的通信并不是真正在两个运输层之间直接传输数据。运输层向应用层屏蔽了下面网络的细节（如网络拓补，所采用的路由选择协议等），它使应用进程之间看起来好像两个运输层实体之间有一条端到端的逻辑通信信道。</strong></li>
<li><strong>网络层为主机提供逻辑通信，而运输层为应用进程之间提供端到端的逻辑通信。</strong></li>
<li>运输层的两个重要协议是用户数据报协议 UDP 和传输控制协议 TCP。按照 OSI 的术语，两个对等运输实体在通信时传送的数据单位叫做运输协议数据单元 TPDU（Transport Protocol Data Unit）。但在 TCP/IP 体系中，则根据所使用的协议是 TCP 或 UDP，分别称之为 TCP 报文段或 UDP 用户数据报。</li>
<li><strong>UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 确是一种最有效的工作方式。 TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的传输服务，难以避免地增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。</strong></li>
<li>硬件端口是不同硬件设备进行交互的接口，而软件端口是应用层各种协议进程与运输实体进行层间交互的一种地址。UDP 和 TCP 的首部格式中都有源端口和目的端口这两个重要字段。当运输层收到 IP 层交上来的运输层报文时，就能够根据其首部中的目的端口号把数据交付应用层的目的应用层。（两个进程之间进行通信不光要知道对方 IP 地址而且要知道对方的端口号(为了找到对方计算机中的应用进程)）</li>
<li>运输层用一个 16 位端口号标志一个端口。端口号只有本地意义，它只是为了标志计算机应用层中的各个进程在和运输层交互时的层间接口。在互联网的不同计算机中，相同的端口号是没有关联的。协议端口号简称端口。虽然通信的终点是应用进程，但只要把所发送的报文交到目的主机的某个合适端口，剩下的工作（最后交付目的进程）就由 TCP 和 UDP 来完成。</li>
<li>运输层的端口号分为服务器端使用的端口号（0˜1023 指派给熟知端口，1024˜49151 是登记端口号）和客户端暂时使用的端口号（49152˜65535）</li>
<li><strong>UDP 的主要特点是 ① 无连接 ② 尽最大努力交付 ③ 面向报文 ④ 无拥塞控制 ⑤ 支持一对一，一对多，多对一和多对多的交互通信 ⑥ 首部开销小（只有四个字段：源端口，目的端口，长度和检验和）</strong></li>
<li><strong>TCP 的主要特点是 ① 面向连接 ② 每一条 TCP 连接只能是一对一的 ③ 提供可靠交付 ④ 提供全双工通信 ⑤ 面向字节流</strong></li>
<li><strong>TCP 用主机的 IP 地址加上主机上的端口号作为 TCP 连接的端点。这样的端点就叫做套接字（socket）或插口。套接字用（IP 地址：端口号）来表示。每一条 TCP 连接唯一地被通信两端的两个端点所确定。</strong></li>
<li>停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li>
<li>为了提高传输效率，发送方可以不使用低效率的停止等待协议，而是采用流水线传输。流水线传输就是发送方可连续发送多个分组，不必每发完一个分组就停下来等待对方确认。这样可使信道上一直有数据不间断的在传送。这种传输方式可以明显提高信道利用率。</li>
<li>停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为自动重传请求 ARQ。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。连续 ARQ 协议可提高信道利用率。发送维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组位置的所有分组都已经正确收到了。</li>
<li>TCP 报文段的前 20 个字节是固定的，其后有 40 字节长度的可选字段。如果加入可选字段后首部长度不是 4 的整数倍字节，需要在再在之后用 0 填充。因此，TCP 首部的长度取值为 20+4n 字节,最长为 60 字节。</li>
<li><strong>TCP 使用滑动窗口机制。发送窗口里面的序号表示允许发送的序号。发送窗口后沿的后面部分表示已发送且已收到确认，而发送窗口前沿的前面部分表示不允许发送。发送窗口后沿的变化情况有两种可能，即不动（没有收到新的确认）和前移（收到了新的确认）。发送窗口的前沿通常是不断向前移动的。一般来说，我们总是希望数据传输更快一些。但如果发送方把数据发送的过快，接收方就可能来不及接收，这就会造成数据的丢失。所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。</strong></li>
<li>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</li>
<li><strong>为了进行拥塞控制，TCP 发送方要维持一个拥塞窗口 cwnd 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</strong></li>
<li><strong>TCP 的拥塞控制采用了四种算法，即慢开始，拥塞避免，快重传和快恢复。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。</strong></li>
<li>运输连接的三个阶段，即：连接建立，数据传送和连接释放。</li>
<li><strong>主动发起 TCP 连接建立的应用进程叫做客户，而被动等待连接建立的应用进程叫做服务器。TCP 连接采用三报文握手机制。服务器要确认用户的连接请求，然后客户要对服务器的确认进行确认。</strong></li>
<li>TCP 的连接释放采用四报文握手机制。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送时，则发送连接释放通知，对方确认后就完全关闭了 TCP 连接</li>
</ol>
<h3> 5.3. 补充（重要）</h3>
<p>以下知识点需要重点关注：</p>
<ol>
<li>端口和套接字的意义</li>
<li>UDP 和 TCP 的区别以及两者的应用场景</li>
<li>在不可靠的网络上实现可靠传输的工作原理，停止等待协议和 ARQ 协议</li>
<li>TCP 的滑动窗口，流量控制，拥塞控制和连接管理</li>
<li>TCP 的三次握手，四次挥手机制</li>
</ol>
<h2> 6. 应用层（Application Layer）</h2>
<p><img src="https://img-blog.csdnimg.cn/img_convert/3ff57c0632bc7f4017723b1d1b7d3a52.png" alt="应用层"></p>
<h3> 6.1. 基本术语</h3>
<ol>
<li><strong>域名系统（DNS）</strong> ：域名系统（DNS，Domain Name System）将人类可读的域名 (例如，www.baidu.com) 转换为机器可读的 IP 地址 (例如，220.181.38.148)。我们可以将其理解为专为互联网设计的电话薄。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/img_convert/6af26a3293530061785df50e70d53e07.png" alt=""></p>
<p style="text-align:right;font-size:12px">https://www.seobility.net/en/wiki/HTTP_headers</p>
<ol start="2">
<li><strong>文件传输协议（FTP）</strong> ：FTP 是 File Transfer Protocol（文件传输协议）的英文简称，而中文简称为“文传协议”。用于 Internet 上的控制文件的双向传输。同时，它也是一个应用程序（Application）。基于不同的操作系统有不同的 FTP 应用程序，而所有这些应用程序都遵守同一种协议以传输文件。在 FTP 的使用当中，用户经常遇到两个概念："下载"（Download）和"上传"（Upload）。 "下载"文件就是从远程主机拷贝文件至自己的计算机上；"上传"文件就是将文件从自己的计算机中拷贝至远程主机上。用 Internet 语言来说，用户可通过客户机程序向（从）远程主机上传（下载）文件。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/img_convert/3f1abf8adba4aa317eca69c489e3db23.png" alt="FTP工作过程"></p>
<ol start="3">
<li><strong>简单文件传输协议（TFTP）</strong> ：TFTP（Trivial File Transfer Protocol,简单文件传输协议）是 TCP/IP 协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。端口号为 69。</li>
<li><strong>远程终端协议（TELNET）</strong> ：Telnet 协议是 TCP/IP 协议族中的一员，是 Internet 远程登陆服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的能力。在终端使用者的电脑上使用 telnet 程序，用它连接到服务器。终端使用者可以在 telnet 程序中输入命令，这些命令会在服务器上运行，就像直接在服务器的控制台上输入一样。可以在本地就能控制服务器。要开始一个 telnet 会话，必须输入用户名和密码来登录服务器。Telnet 是常用的远程控制 Web 服务器的方法。</li>
<li><strong>万维网（WWW）</strong> ：WWW 是环球信息网的缩写，（亦作“Web”、“WWW”、“'W3'”，英文全称为“World Wide Web”），中文名字为“万维网”，"环球网"等，常简称为 Web。分为 Web 客户端和 Web 服务器程序。WWW 可以让 Web 客户端（常用浏览器）访问浏览 Web 服务器上的页面。是一个由许多互相链接的超文本组成的系统，通过互联网访问。在这个系统中，每个有用的事物，称为一样“资源”；并且由一个全局“统一资源标识符”（URI）标识；这些资源通过超文本传输协议（Hypertext Transfer Protocol）传送给用户，而后者通过点击链接来获得资源。万维网联盟（英语：World Wide Web Consortium，简称 W3C），又称 W3C 理事会。1994 年 10 月在麻省理工学院（MIT）计算机科学实验室成立。万维网联盟的创建者是万维网的发明者蒂姆·伯纳斯-李。万维网并不等同互联网，万维网只是互联网所能提供的服务其中之一，是靠着互联网运行的一项服务。</li>
<li><strong>万维网的大致工作工程：</strong></li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/img_convert/735f55501e81898aa61b8032f7dbcb73.png" alt="万维网的大致工作工程"></p>
<ol start="7">
<li><strong>统一资源定位符（URL）</strong> ：统一资源定位符是对可以从互联网上得到的资源的位置和访问方法的一种简洁的表示，是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的 URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。</li>
<li><strong>超文本传输协议（HTTP）</strong> ：超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的 WWW 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。1960 年美国人 Ted Nelson 构思了一种通过计算机处理文本信息的方法，并称之为超文本（hypertext）,这成为了 HTTP 超文本传输协议标准架构的发展根基。</li>
</ol>
<p>HTTP 协议的本质就是一种浏览器与服务器之间约定好的通信格式。HTTP 的原理如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/b273efef5f2388e26414135672b00295.png" alt=""></p>
<ol start="10">
<li><strong>代理服务器（Proxy Server）</strong> ： 代理服务器（Proxy Server）是一种网络实体，它又称为万维网高速缓存。 代理服务器把最近的一些请求和响应暂存在本地磁盘中。当新请求到达时，若代理服务器发现这个请求与暂时存放的的请求相同，就返回暂存的响应，而不需要按 URL 的地址再次去互联网访问该资源。代理服务器可在客户端或服务器工作，也可以在中间系统工作。</li>
<li><strong>简单邮件传输协议(SMTP)</strong> : SMTP（Simple Mail Transfer Protocol）即简单邮件传输协议,它是一组用于由源地址到目的地址传送邮件的规则，由它来控制信件的中转方式。 SMTP 协议属于 TCP/IP 协议簇，它帮助每台计算机在发送或中转信件时找到下一个目的地。 通过 SMTP 协议所指定的服务器,就可以把 E-mail 寄到收信人的服务器上了，整个过程只要几分钟。SMTP 服务器则是遵循 SMTP 协议的发送邮件服务器，用来发送或中转发出的电子邮件。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/img_convert/b16da4d4fea63de5fce53f54973967d7.png" alt="一个电子邮件被发送的过程"></p>
<p style="text-align:right;font-size:12px">https://www.campaignmonitor.com/resources/knowledge-base/what-is-the-code-that-makes-bcc-or-cc-operate-in-an-email/</p>
<ol start="11">
<li><strong>搜索引擎</strong> :搜索引擎（Search Engine）是指根据一定的策略、运用特定的计算机程序从互联网上搜集信息，在对信息进行组织和处理后，为用户提供检索服务，将用户检索相关的信息展示给用户的系统。搜索引擎包括全文索引、目录索引、元搜索引擎、垂直搜索引擎、集合式搜索引擎、门户搜索引擎与免费链接列表等。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/img_convert/68fe865a9d87de361c45f4a42d624035.png" alt="搜索引擎"></p>
<ol start="12">
<li><strong>垂直搜索引擎</strong> ：垂直搜索引擎是针对某一个行业的专业搜索引擎，是搜索引擎的细分和延伸，是对网页库中的某类专门的信息进行一次整合，定向分字段抽取出需要的数据进行处理后再以某种形式返回给用户。垂直搜索是相对通用搜索引擎的信息量大、查询不准确、深度不够等提出来的新的搜索引擎服务模式，通过针对某一特定领域、某一特定人群或某一特定需求提供的有一定价值的信息和相关服务。其特点就是“专、精、深”，且具有行业色彩，相比较通用搜索引擎的海量信息无序化，垂直搜索引擎则显得更加专注、具体和深入。</li>
<li><strong>全文索引</strong> :全文索引技术是目前搜索引擎的关键技术。试想在 1M 大小的文件中搜索一个词，可能需要几秒，在 100M 的文件中可能需要几十秒，如果在更大的文件中搜索那么就需要更大的系统开销，这样的开销是不现实的。所以在这样的矛盾下出现了全文索引技术，有时候有人叫倒排文档技术。</li>
<li><strong>目录索引</strong> ：目录索引（ search index/directory)，顾名思义就是将网站分门别类地存放在相应的目录中，因此用户在查询信息时，可选择关键词搜索，也可按分类目录逐层查找。</li>
</ol>
<h3> 6.2. 重要知识点总结</h3>
<ol>
<li>文件传输协议（FTP）使用 TCP 可靠的运输服务。FTP 使用客户服务器方式。一个 FTP 服务器进程可以同时为多个用户提供服务。在进行文件传输时，FTP 的客户和服务器之间要先建立两个并行的 TCP 连接:控制连接和数据连接。实际用于传输文件的是数据连接。</li>
<li>万维网客户程序与服务器之间进行交互使用的协议是超文本传输协议 HTTP。HTTP 使用 TCP 连接进行可靠传输。但 HTTP 本身是无连接、无状态的。HTTP/1.1 协议使用了持续连接（分为非流水线方式和流水线方式）</li>
<li>电子邮件把邮件发送到收件人使用的邮件服务器，并放在其中的收件人邮箱中，收件人可随时上网到自己使用的邮件服务器读取，相当于电子邮箱。</li>
<li>一个电子邮件系统有三个重要组成构件：用户代理、邮件服务器、邮件协议（包括邮件发送协议，如 SMTP，和邮件读取协议，如 POP3 和 IMAP）。用户代理和邮件服务器都要运行这些协议。</li>
</ol>
<h3> 6.3. 补充（重要）</h3>
<p>以下知识点需要重点关注：</p>
<ol>
<li>应用层的常见协议（重点关注 HTTP 协议）</li>
<li>域名系统-从域名解析出 IP 地址</li>
<li>访问一个网站大致的过程</li>
<li>系统调用和应用编程接口概念</li>
</ol>
]]></content:encoded>
      <enclosure url="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/network/computer-network-xiexiren.png" type="image/png"/>
    </item>
    <item>
      <title>HTTP vs HTTPS（应用层）</title>
      <link>https://javaguide.cn/cs-basics/network/http_https.html</link>
      <guid>https://javaguide.cn/cs-basics/network/http_https.html</guid>
      <source url="https://javaguide.cn/rss.xml">HTTP vs HTTPS（应用层）</source>
      <description>HTTP 协议 HTTP 协议介绍 HTTP 协议，全称超文本传输协议（Hypertext Transfer Protocol）。顾名思义，HTTP 协议就是用来规范超文本的传输，超文本，也就是网络上的包括文本在内的各式各样的消息，具体来说，主要是来规范浏览器和服务器端的行为的。 并且，HTTP 是一个无状态（stateless）协议，也就是说服务器不维护任何有关客户端过去所发请求的消息。这其实是一种懒政，有状态协议会更加复杂，需要维护状态（历史信息），而且如果客户或服务器失效，会产生状态的不一致，解决这种不一致的代价更高。</description>
      <category>计算机基础</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<h2> HTTP 协议</h2>
<h3> HTTP 协议介绍</h3>
<p>HTTP 协议，全称超文本传输协议（Hypertext Transfer Protocol）。顾名思义，HTTP 协议就是用来规范超文本的传输，超文本，也就是网络上的包括文本在内的各式各样的消息，具体来说，主要是来规范浏览器和服务器端的行为的。</p>
<p>并且，HTTP 是一个无状态（stateless）协议，也就是说服务器不维护任何有关客户端过去所发请求的消息。这其实是一种懒政，有状态协议会更加复杂，需要维护状态（历史信息），而且如果客户或服务器失效，会产生状态的不一致，解决这种不一致的代价更高。</p>
<h3> HTTP 协议通信过程</h3>
<p>HTTP 是应用层协议，它以 TCP（传输层）作为底层协议，默认端口为 80. 通信过程主要如下：</p>
<ol>
<li>服务器在 80 端口等待客户的请求。</li>
<li>浏览器发起到服务器的 TCP 连接（创建套接字 Socket）。</li>
<li>服务器接收来自浏览器的 TCP 连接。</li>
<li>浏览器（HTTP 客户端）与 Web 服务器（HTTP 服务器）交换 HTTP 消息。</li>
<li>关闭 TCP 连接。</li>
</ol>
<h3> HTTP 协议优点</h3>
<p>扩展性强、速度快、跨平台支持性好。</p>
<h2> HTTPS 协议</h2>
<h3> HTTPS 协议介绍</h3>
<p>HTTPS 协议（Hyper Text Transfer Protocol Secure），是 HTTP 的加强安全版本。HTTPS 是基于 HTTP 的，也是用 TCP 作为底层协议，并额外使用 SSL/TLS 协议用作加密和安全认证。默认端口号是 443.</p>
<p>HTTPS 协议中，SSL 通道通常使用基于密钥的加密算法，密钥长度通常是 40 比特或 128 比特。</p>
<h3> HTTPS 协议优点</h3>
<p>保密性好、信任度高。</p>
<h2> HTTPS 的核心—SSL/TLS协议</h2>
<p>HTTPS 之所以能达到较高的安全性要求，就是结合了 SSL/TLS 和 TCP 协议，对通信数据进行加密，解决了 HTTP 数据透明的问题。接下来重点介绍一下 SSL/TLS 的工作原理。</p>
<h3> SSL 和 TLS 的区别？</h3>
<p><strong>SSL 和 TLS 没有太大的区别。</strong></p>
<p>SSL 指安全套接字协议（Secure Sockets Layer），首次发布与 1996 年。SSL 的首次发布其实已经是他的 3.0 版本，SSL 1.0 从未面世，SSL 2.0 则具有较大的缺陷（DROWN 缺陷——Decrypting RSA with Obsolete and Weakened eNcryption）。很快，在 1999 年，SSL 3.0 进一步升级，<strong>新版本被命名为 TLS 1.0</strong>。因此，TLS 是基于 SSL 之上的，但由于习惯叫法，通常把 HTTPS 中的核心加密协议混成为 SSL/TLS。</p>
<h3> SSL/TLS 的工作原理</h3>
<h4> 非对称加密</h4>
<p>SSL/TLS 的核心要素是<strong>非对称加密</strong>。非对称加密采用两个密钥——一个公钥，一个私钥。在通信时，私钥仅由解密者保存，公钥由任何一个想与解密者通信的发送者（加密者）所知。可以设想一个场景，</p>
<blockquote>
<p>在某个自助邮局，每个通信信道都是一个邮箱，每一个邮箱所有者都在旁边立了一个牌子，上面挂着一把钥匙：这是我的公钥，发送者请将信件放入我的邮箱，并用公钥锁好。</p>
<p>但是公钥只能加锁，并不能解锁。解锁只能由邮箱的所有者——因为只有他保存着私钥。</p>
<p>这样，通信信息就不会被其他人截获了，这依赖于私钥的保密性。</p>
</blockquote>
<p></p>
<p>非对称加密的公钥和私钥需要采用一种复杂的数学机制生成（密码学认为，为了较高的安全性，尽量不要自己创造加密方案）。公私钥对的生成算法依赖于单向陷门函数。</p>
<blockquote>
<p>单向函数：已知单向函数 f，给定任意一个输入 x，易计算输出 y=f(x)；而给定一个输出 y，假设存在 f(x)=y，很难根据 f 来计算出 x。</p>
<p>单向陷门函数：一个较弱的单向函数。已知单向陷门函数 f，陷门 h，给定任意一个输入 x，易计算出输出 y=f(x;h)；而给定一个输出 y，假设存在 f(x;h)=y，很难根据 f 来计算出 x，但可以根据 f 和 h 来推导出 x。</p>
</blockquote>
<p></p>
<p>上图就是一个单向函数（不是单项陷门函数），假设有一个绝世秘籍，任何知道了这个秘籍的人都可以把苹果汁榨成苹果，那么这个秘籍就是“陷门”了吧。</p>
<p>在这里，函数 f 的计算方法相当于公钥，陷门 h 相当于私钥。公钥 f 是公开的，任何人对已有输入，都可以用 f 加密，而要想根据加密信息还原出原信息，必须要有私钥才行。</p>
<h4> 对称加密</h4>
<p>使用 SSL/TLS 进行通信的双方需要使用非对称加密方案来通信，但是非对称加密设计了较为复杂的数学算法，在实际通信过程中，计算的代价较高，效率太低，因此，SSL/TLS 实际对消息的加密使用的是对称加密。</p>
<blockquote>
<p>对称加密：通信双方共享唯一密钥 k，加解密算法已知，加密方利用密钥 k 加密，解密方利用密钥 k 解密，保密性依赖于密钥 k 的保密性。</p>
</blockquote>
<p></p>
<p>对称加密的密钥生成代价比公私钥对的生成代价低得多，那么有的人会问了，为什么 SSL/TLS 还需要使用非对称加密呢？因为对称加密的保密性完全依赖于密钥的保密性。在双方通信之前，需要商量一个用于对称加密的密钥。我们知道网络通信的信道是不安全的，传输报文对任何人是可见的，密钥的交换肯定不能直接在网络信道中传输。因此，使用非对称加密，对对称加密的密钥进行加密，保护该密钥不在网络信道中被窃听。这样，通信双方只需要一次非对称加密，交换对称加密的密钥，在之后的信息通信中，使用绝对安全的密钥，对信息进行对称加密，即可保证传输消息的保密性。</p>
<h4> 公钥传输的信赖性</h4>
<p>SSL/TLS 介绍到这里，了解信息安全的朋友又会想到一个安全隐患，设想一个下面的场景：</p>
<blockquote>
<p>客户端 C 和服务器 S 想要使用 SSL/TLS 通信，由上述 SSL/TLS 通信原理，C 需要先知道 S 的公钥，而 S 公钥的唯一获取途径，就是把 S 公钥在网络信道中传输。要注意网络信道通信中有几个前提：</p>
<ol>
<li>任何人都可以捕获通信包</li>
<li>通信包的保密性由发送者设计</li>
<li>保密算法设计方案默认为公开，而（解密）密钥默认是安全的</li>
</ol>
<p>因此，假设 S 公钥不做加密，在信道中传输，那么很有可能存在一个攻击者 A，发送给 C 一个诈包，假装是 S 公钥，其实是诱饵服务器 AS 的公钥。当 C 收获了 AS 的公钥（却以为是 S 的公钥），C 后续就会使用 AS 公钥对数据进行加密，并在公开信道传输，那么 A 将捕获这些加密包，用 AS 的私钥解密，就截获了 C 本要给 S 发送的内容，而 C 和 S 二人全然不知。</p>
<p>同样的，S 公钥即使做加密，也难以避免这种信任性问题，C 被 AS 拐跑了！</p>
</blockquote>
<p></p>
<p>为了公钥传输的信赖性问题，第三方机构应运而生——证书颁发机构（CA，Certificate Authority）。CA 默认是受信任的第三方。CA 会给各个服务器颁发证书，证书存储在服务器上，并附有 CA 的<strong>电子签名</strong>（见下节）。</p>
<p>当客户端（浏览器）向服务器发送 HTTPS 请求时，一定要先获取目标服务器的证书，并根据证书上的信息，检验证书的合法性。一旦客户端检测到证书非法，就会发生错误。客户端获取了服务器的证书后，由于证书的信任性是由第三方信赖机构认证的，而证书上又包含着服务器的公钥信息，客户端就可以放心的信任证书上的公钥就是目标服务器的公钥。</p>
<h4> 数字签名</h4>
<p>好，到这一小节，已经是 SSL/TLS 的尾声了。上一小节提到了数字签名，数字签名要解决的问题，是防止证书被伪造。第三方信赖机构 CA 之所以能被信赖，就是 <strong>靠数字签名技术</strong> 。</p>
<p>数字签名，是 CA 在给服务器颁发证书时，使用散列+加密的组合技术，在证书上盖个章，以此来提供验伪的功能。具体行为如下：</p>
<blockquote>
<p>CA 知道服务器的公钥，对证书采用散列技术生成一个摘要。CA 使用 CA 私钥对该摘要进行加密，并附在证书下方，发送给服务器。</p>
<p>现在服务器将该证书发送给客户端，客户端需要验证该证书的身份。客户端找到第三方机构 CA，获知 CA 的公钥，并用 CA 公钥对证书的签名进行解密，获得了 CA 生成的摘要。</p>
<p>客户端对证书数据（包含服务器的公钥）做相同的散列处理，得到摘要，并将该摘要与之前从签名中解码出的摘要做对比，如果相同，则身份验证成功；否则验证失败。</p>
</blockquote>
<p></p>
<p>总结来说，带有证书的公钥传输机制如下：</p>
<ol>
<li>设有服务器 S，客户端 C，和第三方信赖机构 CA。</li>
<li>S 信任 CA，CA 是知道 S 公钥的，CA 向 S 颁发证书。并附上 CA 私钥对消息摘要的加密签名。</li>
<li>S 获得 CA 颁发的证书，将该证书传递给 C。</li>
<li>C 获得 S 的证书，信任 CA 并知晓 CA 公钥，使用 CA 公钥对 S 证书上的签名解密，同时对消息进行散列处理，得到摘要。比较摘要，验证 S 证书的真实性。</li>
<li>如果 C 验证 S 证书是真实的，则信任 S 的公钥（在 S 证书中）。</li>
</ol>
<p></p>
<p>对于数字签名，我这里讲的比较简单，如果你没有搞清楚的话，强烈推荐你看看<a href="https://www.bilibili.com/video/BV18N411X7ty/" target="_blank" rel="noopener noreferrer">数字签名及数字证书原理</a>这个视频，这是我看过最清晰的讲解。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/image-20220321121814946.png" alt=""></p>
<h2> 总结</h2>
<ul>
<li><strong>端口号</strong> ：HTTP 默认是 80，HTTPS 默认是 443。</li>
<li><strong>URL 前缀</strong> ：HTTP 的 URL 前缀是 <code>http://</code>，HTTPS 的 URL 前缀是 <code>https://</code>。</li>
<li><strong>安全性和资源消耗</strong> ： HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL/TLS 之上的 HTTP 协议，SSL/TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>HTTP 常见状态码总结（应用层）</title>
      <link>https://javaguide.cn/cs-basics/network/http-status-codes.html</link>
      <guid>https://javaguide.cn/cs-basics/network/http-status-codes.html</guid>
      <source url="https://javaguide.cn/rss.xml">HTTP 常见状态码总结（应用层）</source>
      <description>HTTP 状态码用于描述 HTTP 请求的结果，比如2xx 就代表请求被成功处理。 1xx Informational（信息性状态码） 相比于其他类别状态码来说，1xx 你平时你大概率不会碰到，所以这里直接跳过。 2xx Success（成功状态码） 200 OK ：请求被成功处理。比如我们发送一个查询用户数据的HTTP 请求到服务端，服务端正确返回了用户数据。这个是我们平时最常见的一个 HTTP 状态码。 201 Created ：请求被成功处理并且在服务端创建了一个新的资源。比如我们通过 POST 请求创建一个新的用户。 202 Accepted ：服务端已经接收到了请求，但是还未处理。 204 No Content ： 服务端已经成功处理了请求，但是没有返回任何内容。</description>
      <category>计算机基础</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<p>HTTP 状态码用于描述 HTTP 请求的结果，比如2xx 就代表请求被成功处理。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/状态码.png" alt="状态码"></p>
<h3> 1xx Informational（信息性状态码）</h3>
<p>相比于其他类别状态码来说，1xx 你平时你大概率不会碰到，所以这里直接跳过。</p>
<h3> 2xx Success（成功状态码）</h3>
<ul>
<li><strong>200 OK</strong> ：请求被成功处理。比如我们发送一个查询用户数据的HTTP 请求到服务端，服务端正确返回了用户数据。这个是我们平时最常见的一个 HTTP 状态码。</li>
<li><strong>201 Created</strong> ：请求被成功处理并且在服务端创建了一个新的资源。比如我们通过 POST 请求创建一个新的用户。</li>
<li><strong>202 Accepted</strong> ：服务端已经接收到了请求，但是还未处理。</li>
<li><strong>204 No Content</strong> ： 服务端已经成功处理了请求，但是没有返回任何内容。</li>
</ul>
<p>这里格外提一下 204 状态码，平时学习/工作中见到的次数并不多。</p>
<p><a href="https://tools.ietf.org/html/rfc2616#section-10.2.5" target="_blank" rel="noopener noreferrer">HTTP RFC 2616对204状态码的描述</a>如下：</p>
<blockquote>
<p>The server has fulfilled the request but does not need to return an
entity-body, and might want to return updated metainformation. The
response MAY include new or updated metainformation in the form of
entity-headers, which if present SHOULD be associated with the
requested variant.</p>
<p>If the client is a user agent, it SHOULD NOT change its document view
from that which caused the request to be sent. This response is
primarily intended to allow input for actions to take place without
causing a change to the user agent's active document view, although
any new or updated metainformation SHOULD be applied to the document
currently in the user agent's active view.</p>
<p>The 204 response MUST NOT include a message-body, and thus is always
terminated by the first empty line after the header fields.</p>
</blockquote>
<p>简单来说，204状态码描述的是我们向服务端发送 HTTP 请求之后，只关注处理结果是否成功的场景。也就是说我们需要的就是一个结果：true/false。</p>
<p>举个例子：你要追一个女孩子，你问女孩子：“我能追你吗？”，女孩子回答：“好！”。我们把这个女孩子当做是服务端就很好理解 204 状态码了。</p>
<h3> 3xx Redirection（重定向状态码）</h3>
<ul>
<li><strong>301 Moved Permanently</strong> ： 资源被永久重定向了。比如你的网站的网址更换了。</li>
<li><strong>302 Found</strong> ：资源被临时重定向了。比如你的网站的某些资源被暂时转移到另外一个网址。</li>
</ul>
<h3> 4xx Client Error（客户端错误状态码）</h3>
<ul>
<li><strong>400 Bad Request</strong> ： 发送的HTTP请求存在问题。比如请求参数不合法、请求方法错误。</li>
<li><strong>401 Unauthorized</strong> ： 未认证却请求需要认证之后才能访问的资源。</li>
<li><strong>403 Forbidden</strong> ：直接拒绝HTTP请求，不处理。一般用来针对非法请求。</li>
<li><strong>404 Not Found</strong> ： 你请求的资源未在服务端找到。比如你请求某个用户的信息，服务端并没有找到指定的用户。</li>
<li><strong>409 Conflict</strong> ： 表示请求的资源与服务端当前的状态存在冲突，请求无法被处理。</li>
</ul>
<h3> 5xx Server Error（服务端错误状态码）</h3>
<ul>
<li><strong>500 Internal Server Error</strong> ： 服务端出问题了（通常是服务端出Bug了）。比如你服务端处理请求的时候突然抛出异常，但是异常并未在服务端被正确处理。</li>
<li><strong>502 Bad Gateway</strong> ：我们的网关将请求转发到服务端，但是服务端返回的却是一个错误的响应。</li>
</ul>
<h3> 参考</h3>
<ul>
<li>https://www.restapitutorial.com/httpstatuscodes.html</li>
<li>https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status</li>
<li>https://en.wikipedia.org/wiki/List_of_HTTP_status_codes</li>
<li>https://segmentfault.com/a/1190000018264501</li>
</ul>
]]></content:encoded>
      <enclosure url="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/%E7%8A%B6%E6%80%81%E7%A0%81.png" type="image/png"/>
    </item>
    <item>
      <title>HTTP 1.0 vs HTTP 1.1（应用层）</title>
      <link>https://javaguide.cn/cs-basics/network/http1.0_http1.1.html</link>
      <guid>https://javaguide.cn/cs-basics/network/http1.0_http1.1.html</guid>
      <source url="https://javaguide.cn/rss.xml">HTTP 1.0 vs HTTP 1.1（应用层）</source>
      <description>这篇文章会从下面几个维度来对比 HTTP 1.0 和 HTTP 1.1： 响应状态码 缓存处理 连接方式 Host头处理 带宽优化 响应状态码 HTTP/1.0仅定义了16种状态码。HTTP/1.1中新加入了大量的状态码，光是错误响应状态码就新增了24种。比如说，100 (Continue)——在请求大资源前的预热请求，206 (Partial Content)——范围请求的标识码，409 (Conflict)——请求与当前资源的规定冲突，410 (Gone)——资源已被永久转移，而且没有任何已知的转发地址。</description>
      <category>计算机基础</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<p>这篇文章会从下面几个维度来对比 HTTP 1.0 和 HTTP 1.1：</p>
<ul>
<li>响应状态码</li>
<li>缓存处理</li>
<li>连接方式</li>
<li>Host头处理</li>
<li>带宽优化</li>
</ul>
<h2> 响应状态码</h2>
<p>HTTP/1.0仅定义了16种状态码。HTTP/1.1中新加入了大量的状态码，光是错误响应状态码就新增了24种。比如说，<code>100 (Continue)</code>——在请求大资源前的预热请求，<code>206 (Partial Content)</code>——范围请求的标识码，<code>409 (Conflict)</code>——请求与当前资源的规定冲突，<code>410 (Gone)</code>——资源已被永久转移，而且没有任何已知的转发地址。</p>
<h2> 缓存处理</h2>
<p>缓存技术通过避免用户与源服务器的频繁交互，节约了大量的网络带宽，降低了用户接收信息的延迟。</p>
<h3> HTTP/1.0</h3>
<p>HTTP/1.0提供的缓存机制非常简单。服务器端使用<code>Expires</code>标签来标志（时间）一个响应体，在<code>Expires</code>标志时间内的请求，都会获得该响应体缓存。服务器端在初次返回给客户端的响应体中，有一个<code>Last-Modified</code>标签，该标签标记了被请求资源在服务器端的最后一次修改。在请求头中，使用<code>If-Modified-Since</code>标签，该标签标志一个时间，意为客户端向服务器进行问询：“该时间之后，我要请求的资源是否有被修改过？”通常情况下，请求头中的<code>If-Modified-Since</code>的值即为上一次获得该资源时，响应体中的<code>Last-Modified</code>的值。</p>
<p>如果服务器接收到了请求头，并判断<code>If-Modified-Since</code>时间后，资源确实没有修改过，则返回给客户端一个<code>304 not modified</code>响应头，表示”缓冲可用，你从浏览器里拿吧！”。</p>
<p>如果服务器判断<code>If-Modified-Since</code>时间后，资源被修改过，则返回给客户端一个<code>200 OK</code>的响应体，并附带全新的资源内容，表示”你要的我已经改过的，给你一份新的”。</p>
<p></p>
<p></p>
<h3> HTTP/1.1</h3>
<p>HTTP/1.1的缓存机制在HTTP/1.0的基础上，大大增加了灵活性和扩展性。基本工作原理和HTTP/1.0保持不变，而是增加了更多细致的特性。其中，请求头中最常见的特性就是<code>Cache-Control</code>，详见MDN Web文档 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control" target="_blank" rel="noopener noreferrer">Cache-Control</a>.</p>
<h2> 连接方式</h2>
<p><strong>HTTP/1.0 默认使用短连接</strong> ，也就是说，客户端和服务器每进行一次 HTTP 操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个 HTML 或其他类型的 Web 页中包含有其他的 Web 资源（如 JavaScript 文件、图像文件、CSS 文件等），每遇到这样一个 Web 资源，浏览器就会重新建立一个TCP连接，这样就会导致有大量的“握手报文”和“挥手报文”占用了带宽。</p>
<p><strong>为了解决 HTTP/1.0 存在的资源浪费的问题， HTTP/1.1 优化为默认长连接模式 。</strong> 采用长连接模式的请求报文会通知服务端：“我向你请求连接，并且连接成功建立后，请不要关闭”。因此，该TCP连接将持续打开，为后续的客户端-服务端的数据交互服务。也就是说在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。</p>
<p>如果 TCP 连接一直保持的话也是对资源的浪费，因此，一些服务器软件（如 Apache）还会支持超时时间的时间。在超时时间之内没有新的请求达到，TCP 连接才会被关闭。</p>
<p>有必要说明的是，HTTP/1.0仍提供了长连接选项，即在请求头中加入<code>Connection: Keep-alive</code>。同样的，在HTTP/1.1中，如果不希望使用长连接选项，也可以在请求头中加入<code>Connection: close</code>，这样会通知服务器端：“我不需要长连接，连接成功后即可关闭”。</p>
<p><strong>HTTP 协议的长连接和短连接，实质上是 TCP 协议的长连接和短连接。</strong></p>
<p><strong>实现长连接需要客户端和服务端都支持长连接。</strong></p>
<h2> Host头处理</h2>
<p>域名系统（DNS）允许多个主机名绑定到同一个IP地址上，但是HTTP/1.0并没有考虑这个问题，假设我们有一个资源URL是http://example1.org/home.html，HTTP/1.0的请求报文中，将会请求的是<code>GET /home.html HTTP/1.0</code>.也就是不会加入主机名。这样的报文送到服务器端，服务器是理解不了客户端想请求的真正网址。</p>
<p>因此，HTTP/1.1在请求头中加入了<code>Host</code>字段。加入<code>Host</code>字段的报文头部将会是:</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这样，服务器端就可以确定客户端想要请求的真正的网址了。</p>
<h2> 带宽优化</h2>
<h3> 范围请求</h3>
<p>HTTP/1.1引入了范围请求（range request）机制，以避免带宽的浪费。当客户端想请求一个文件的一部分，或者需要继续下载一个已经下载了部分但被终止的文件，HTTP/1.1可以在请求中加入<code>Range</code>头部，以请求（并只能请求字节型数据）数据的一部分。服务器端可以忽略<code>Range</code>头部，也可以返回若干<code>Range</code>响应。</p>
<p>如果一个响应包含部分数据的话，那么将带有<code>206 (Partial Content)</code>状态码。该状态码的意义在于避免了HTTP/1.0代理缓存错误地把该响应认为是一个完整的数据响应，从而把他当作为一个请求的响应缓存。</p>
<p>在范围响应中，<code>Content-Range</code>头部标志指示出了该数据块的偏移量和数据块的长度。</p>
<h3> 状态码100</h3>
<p>HTTP/1.1中新加入了状态码<code>100</code>。该状态码的使用场景为，存在某些较大的文件请求，服务器可能不愿意响应这种请求，此时状态码<code>100</code>可以作为指示请求是否会被正常响应，过程如下图：</p>
<p></p>
<p></p>
<p>然而在HTTP/1.0中，并没有<code>100 (Continue)</code>状态码，要想触发这一机制，可以发送一个<code>Expect</code>头部，其中包含一个<code>100-continue</code>的值。</p>
<h3> 压缩</h3>
<p>许多格式的数据在传输时都会做预压缩处理。数据的压缩可以大幅优化带宽的利用。然而，HTTP/1.0对数据压缩的选项提供的不多，不支持压缩细节的选择，也无法区分端到端（end-to-end）压缩或者是逐跳（hop-by-hop）压缩。</p>
<p>HTTP/1.1则对内容编码（content-codings）和传输编码（transfer-codings）做了区分。内容编码总是端到端的，传输编码总是逐跳的。</p>
<p>HTTP/1.0包含了<code>Content-Encoding</code>头部，对消息进行端到端编码。HTTP/1.1加入了<code>Transfer-Encoding</code>头部，可以对消息进行逐跳传输编码。HTTP/1.1还加入了<code>Accept-Encoding</code>头部，是客户端用来指示他能处理什么样的内容编码。</p>
<h2> 总结</h2>
<ol>
<li><strong>连接方式</strong> : HTTP 1.0 为短连接，HTTP 1.1 支持长连接。</li>
<li><strong>状态响应码</strong> : HTTP/1.1中新加入了大量的状态码，光是错误响应状态码就新增了24种。比如说，<code>100 (Continue)</code>——在请求大资源前的预热请求，<code>206 (Partial Content)</code>——范围请求的标识码，<code>409 (Conflict)</code>——请求与当前资源的规定冲突，<code>410 (Gone)</code>——资源已被永久转移，而且没有任何已知的转发地址。</li>
<li><strong>缓存处理</strong> : 在 HTTP1.0 中主要使用 header 里的 If-Modified-Since,Expires 来做为缓存判断的标准，HTTP1.1 则引入了更多的缓存控制策略例如 Entity tag，If-Unmodified-Since, If-Match, If-None-Match 等更多可供选择的缓存头来控制缓存策略。</li>
<li><strong>带宽优化及网络连接的使用</strong> :HTTP1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li>
<li><strong>Host头处理</strong> : HTTP/1.1在请求头中加入了<code>Host</code>字段。</li>
</ol>
<h2> 参考资料</h2>
<p><a href="http://www.ra.ethz.ch/cdstore/www8/data/2136/pdf/pd1.pdf" target="_blank" rel="noopener noreferrer">Key differences between HTTP/1.0 and HTTP/1.1</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>OSI 和 TCP/IP 网络分层模型详解（基础）</title>
      <link>https://javaguide.cn/cs-basics/network/osi_tcp-ip-model.html</link>
      <guid>https://javaguide.cn/cs-basics/network/osi_tcp-ip-model.html</guid>
      <source url="https://javaguide.cn/rss.xml">OSI 和 TCP/IP 网络分层模型详解（基础）</source>
      <description>OSI 七层模型 OSI 七层模型 是国际标准化组织提出一个网络分层模型，其大体结构以及每一层提供的功能如下图所示： 每一层都专注做一件事情，并且每一层都需要使用下一层提供的功能比如传输层需要使用网络层提供的路由和寻址功能，这样传输层才知道把数据传输到哪里去。</description>
      <category>计算机基础</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<h2> OSI 七层模型</h2>
<p><strong>OSI 七层模型</strong> 是国际标准化组织提出一个网络分层模型，其大体结构以及每一层提供的功能如下图所示：</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/network/osi-7-model.png" alt="OSI 七层模型"></p>
<p>每一层都专注做一件事情，并且每一层都需要使用下一层提供的功能比如传输层需要使用网络层提供的路由和寻址功能，这样传输层才知道把数据传输到哪里去。</p>
<p><strong>OSI 的七层体系结构概念清楚，理论也很完整，但是它比较复杂而且不实用，而且有些功能在多个层中重复出现。</strong></p>
<p>上面这种图可能比较抽象，再来一个比较生动的图片。下面这个图片是我在国外的一个网站上看到的，非常赞！</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/osi七层模型2.png" alt="osi七层模型2"></p>
<p><strong>既然 OSI 七层模型这么厉害，为什么干不过 TCP/IP 四 层模型呢？</strong></p>
<p>的确，OSI 七层模型当时一直被一些大公司甚至一些国家政府支持。这样的背景下，为什么会失败呢？我觉得主要有下面几方面原因：</p>
<ol>
<li>OSI 的专家缺乏实际经验，他们在完成 OSI 标准时缺乏商业驱动力</li>
<li>OSI 的协议实现起来过分复杂，而且运行效率很低</li>
<li>OSI 制定标准的周期太长，因而使得按 OSI 标准生产的设备无法及时进入市场（20 世纪 90 年代初期，虽然整套的 OSI 国际标准都已经制定出来，但基于 TCP/IP 的互联网已经抢先在全球相当大的范围成功运行了）</li>
<li>OSI 的层次划分不太合理，有些功能在多个层次中重复出现。</li>
</ol>
<p>OSI 七层模型虽然失败了，但是却提供了很多不错的理论基础。为了更好地去了解网络分层，OSI 七层模型还是非常有必要学习的。</p>
<p>最后再分享一个关于 OSI 七层模型非常不错的总结图片！</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/network/osi-model-detail.png" alt=""></p>
<h2> TCP/IP 四层模型</h2>
<p><strong>TCP/IP 四层模型</strong> 是目前被广泛采用的一种模型,我们可以将 TCP / IP 模型看作是 OSI 七层模型的精简版本，由以下 4 层组成：</p>
<ol>
<li>应用层</li>
<li>传输层</li>
<li>网络层</li>
<li>网络接口层</li>
</ol>
<p>需要注意的是，我们并不能将 TCP/IP 四层模型 和 OSI 七层模型完全精确地匹配起来，不过可以简单将两者对应起来，如下图所示：</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/network/tcp-ip-4-model.png" alt="TCP/IP 四层模型"></p>
<h3> 应用层（Application layer）</h3>
<p><strong>应用层位于传输层之上，主要提供两个终端设备上的应用程序之间信息交换的服务，它定义了信息交换的格式，消息会交给下一层传输层来传输。</strong> 我们把应用层交互的数据单元称为报文。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/5971-2-7I1-20220111095024771-20220111201807861.png" alt=""></p>
<p>应用层协议定义了网络通信规则，对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如支持 Web 应用的 HTTP 协议，支持电子邮件的 SMTP 协议等等。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/network/application-layer-protocol.png" alt="应用层重要协议"></p>
<p>应用层常见协议总结，请看这篇文章：<a href="/cs-basics/network/application-layer-protocol.html" target="blank">应用层常见协议总结（应用层）</a>。</p>
<h3> 传输层（Transport layer）</h3>
<p><strong>传输层的主要任务就是负责向两台终端设备进程之间的通信提供通用的数据传输服务。</strong> 应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。</p>
<p><strong>运输层主要使用以下两种协议：</strong></p>
<ol>
<li><strong>传输控制协议 TCP</strong>（Transmisson Control Protocol）--提供 <strong>面向连接</strong> 的，<strong>可靠的</strong> 数据传输服务。</li>
<li><strong>用户数据协议 UDP</strong>（User Datagram Protocol）--提供 <strong>无连接</strong> 的，尽最大努力的数据传输服务（不保证数据传输的可靠性）。</li>
</ol>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/network/transport-layer-protocol.png" alt="传输层重要协议"></p>
<h3> 网络层（Network layer）</h3>
<p><strong>网络层负责为分组交换网上的不同主机提供通信服务。</strong> 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报，简称数据报。</p>
<p>⚠️注意 ：<strong>不要把运输层的“用户数据报 UDP”和网络层的“IP 数据报”弄混</strong>。</p>
<p><strong>网络层的还有一个任务就是选择合适的路由，使源主机运输层所传下来的分组，能通过网络层中的路由器找到目的主机。</strong></p>
<p>这里强调指出，网络层中的“网络”二字已经不是我们通常谈到的具体网络，而是指计算机网络体系结构模型中第三层的名称。</p>
<p>互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Internet Prococol）和许多路由选择协议，因此互联网的网络层也叫做 <strong>网际层</strong> 或 <strong>IP 层</strong>。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/network/nerwork-layer-protocol.png" alt="网络层重要协议"></p>
<p><strong>网络层常见协议</strong> ：</p>
<ul>
<li><strong>IP:网际协议</strong> ：网际协议 IP 是TCP/IP协议中最重要的协议之一，也是网络层最重要的协议之一，IP协议的作用包括寻址规约、定义数据包的格式等等，是网络层信息传输的主力协议。目前IP协议主要分为两种，一种是过去的IPv4，另一种是较新的IPv6，目前这两种协议都在使用，但后者已经被提议来取代前者。</li>
<li><strong>ARP 协议</strong> ：ARP协议，全称地址解析协议（Address Resolution Protocol），它解决的是网络层地址和链路层地址之间的转换问题。因为一个IP数据报在物理上传输的过程中，总是需要知道下一跳（物理上的下一个目的地）该去往何处，但IP地址属于逻辑地址，而MAC地址才是物理地址，ARP协议解决了IP地址转MAC地址的一些问题。</li>
<li><strong>NAT:网络地址转换协议</strong> ：NAT协议（Network Address Translation）的应用场景如同它的名称——网络地址转换，应用于内部网到外部网的地址转换过程中。具体地说，在一个小的子网（局域网，LAN）内，各主机使用的是同一个LAN下的IP地址，但在该LAN以外，在广域网（WAN）中，需要一个统一的IP地址来标识该LAN在整个Internet上的位置。</li>
<li>......</li>
</ul>
<h3> 网络接口层（Network interface layer）</h3>
<p>我们可以把网络接口层看作是数据链路层和物理层的合体。</p>
<ol>
<li>数据链路层(data link layer)通常简称为链路层（ 两台主机之间的数据传输，总是在一段一段的链路上传送的）。<strong>数据链路层的作用是将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</strong></li>
<li><strong>物理层的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异</strong></li>
</ol>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/network/network-interface-layer-protocol.png" alt="网络接口层重要协议"></p>
<h3> 总结</h3>
<p>简单总结一下每一层包含的协议和核心技术:</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/network/network-protocol-overview.png" alt="TCP/IP 各层协议概览"></p>
<p><strong>应用层协议</strong> :</p>
<ul>
<li>HTTP 协议（超文本传输协议，网页浏览常用的协议）</li>
<li>DHCP 协议（动态主机配置）</li>
<li>DNS 系统原理（域名系统）</li>
<li>FTP 协议（文件传输协议）</li>
<li>Telnet协议（远程登陆协议）</li>
<li>电子邮件协议等（SMTP、POP3、IMAP）</li>
<li>......</li>
</ul>
<p><strong>传输层协议</strong> :</p>
<ul>
<li>TCP 协议
<ul>
<li>报文段结构</li>
<li>可靠数据传输</li>
<li>流量控制</li>
<li>拥塞控制</li>
</ul>
</li>
<li>UDP 协议
<ul>
<li>报文段结构</li>
<li>RDT（可靠数据传输协议）</li>
</ul>
</li>
</ul>
<p><strong>网络层协议</strong> :</p>
<ul>
<li>IP 协议（TCP/IP 协议的基础，分为 IPv4 和 IPv6）</li>
<li>ARP 协议（地址解析协议，用于解析 IP 地址和 MAC 地址之间的映射）</li>
<li>ICMP 协议（控制报文协议，用于发送控制消息）</li>
<li>NAT 协议（网络地址转换协议）</li>
<li>RIP 协议、OSPF 协议、BGP 协议（路由选择协议）</li>
<li>......</li>
</ul>
<p><strong>网络接口层</strong> :</p>
<ul>
<li>差错检测技术</li>
<li>多路访问协议（信道复用技术）</li>
<li>CSMA/CD 协议</li>
<li>MAC 协议</li>
<li>以太网技术</li>
<li>......</li>
</ul>
<h2> 网络分层的原因</h2>
<p>在这篇文章的最后，我想聊聊：“为什么网络要分层？”。</p>
<p>说到分层，我们先从我们平时使用框架开发一个后台程序来说，我们往往会按照每一层做不同的事情的原则将系统分为三层（复杂的系统分层会更多）:</p>
<ol>
<li>Repository（数据库操作）</li>
<li>Service（业务操作）</li>
<li>Controller（前后端数据交互）</li>
</ol>
<p><strong>复杂的系统需要分层，因为每一层都需要专注于一类事情。网络分层的原因也是一样，每一层只专注于做一类事情。</strong></p>
<p>好了，再来说回：“为什么网络要分层？”。我觉得主要有 3 方面的原因：</p>
<ol>
<li><strong>各层之间相互独立</strong>：各层之间相互独立，各层之间不需要关心其他层是如何实现的，只需要知道自己如何调用下层提供好的功能就可以了（可以简单理解为接口调用）<strong>。这个和我们对开发时系统进行分层是一个道理。</strong></li>
<li><strong>提高了整体灵活性</strong> ：每一层都可以使用最适合的技术来实现，你只需要保证你提供的功能以及暴露的接口的规则没有改变就行了。<strong>这个和我们平时开发系统的时候要求的高内聚、低耦合的原则也是可以对应上的。</strong></li>
<li><strong>大问题化小</strong> ： 分层可以将复杂的网络间题分解为许多比较小的、界线比较清晰简单的小问题来处理和解决。这样使得复杂的计算机网络系统变得易于设计，实现和标准化。 <strong>这个和我们平时开发的时候，一般会将系统功能分解，然后将复杂的问题分解为容易理解的更小的问题是相对应的，这些较小的问题具有更好的边界（目标和接口）定义。</strong></li>
</ol>
<p>我想到了计算机世界非常非常有名的一句话，这里分享一下：</p>
<blockquote>
<p>计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决，计算机整个体系从上到下都是按照严格的层次结构设计的。</p>
</blockquote>
<h2> 参考</h2>
<ul>
<li>TCP/IP model vs OSI model：https://fiberbit.com.tw/tcpip-model-vs-osi-model/</li>
<li>Data Encapsulation and the TCP/IP Protocol Stack：https://docs.oracle.com/cd/E19683-01/806-4075/ipov-32/index.html</li>
</ul>
]]></content:encoded>
      <enclosure url="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/network/osi-7-model.png" type="image/png"/>
    </item>
    <item>
      <title>计算机网络常见面试题总结</title>
      <link>https://javaguide.cn/cs-basics/network/other-network-questions.html</link>
      <guid>https://javaguide.cn/cs-basics/network/other-network-questions.html</guid>
      <source url="https://javaguide.cn/rss.xml">计算机网络常见面试题总结</source>
      <description>计算机网络基础 OSI 和 TCP/IP 网络分层模型 相关面试题 ： OSI 七层模型是什么？每一层的作用是什么？ TCP/IP 四层模型是什么？每一层的作用是什么？ 为什么网络要分层？ 参考答案 ：OSI 和 TCP/IP 网络分层模型详解（基础）。</description>
      <category>计算机基础</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 计算机网络基础</h2>
<h3> OSI 和 TCP/IP 网络分层模型</h3>
<p><strong>相关面试题</strong> ：</p>
<ul>
<li>OSI 七层模型是什么？每一层的作用是什么？</li>
<li>TCP/IP 四层模型是什么？每一层的作用是什么？</li>
<li>为什么网络要分层？</li>
</ul>
<p><strong>参考答案</strong> ：<a href="/cs-basics/network/osi&amp;tcp-ip-model.html" target="blank">OSI 和 TCP/IP 网络分层模型详解（基础）</a>。</p>
<h3> 应用层有哪些常见的协议？</h3>
<p><a href="/cs-basics/network/application-layer-protocol.html" target="blank">应用层常见协议总结（应用层）</a></p>
<h2> TCP 与 UDP</h2>
<h3> TCP 与 UDP 的区别（重要）</h3>
<ol>
<li><strong>是否面向连接</strong> ：UDP 在传送数据之前不需要先建立连接。而 TCP 提供面向连接的服务，在传送数据之前必须先建立连接，数据传送结束后要释放连接。</li>
<li><strong>是否是可靠传输</strong>：远地主机在收到 UDP 报文后，不需要给出任何确认，并且不保证数据不丢失，不保证是否顺序到达。TCP 提供可靠的传输服务，TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制。通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。</li>
<li><strong>是否有状态</strong> ：这个和上面的“是否可靠传输”相对应。TCP 传输是有状态的，这个有状态说的是 TCP 会去记录自己发送消息的状态比如消息是否发送了、是否被接收了等等。为此 ，TCP 需要维持复杂的连接状态表。而 UDP 是无状态服务，简单来说就是不管发出去之后的事情了（<strong>这很渣男！</strong>）。</li>
<li><strong>传输效率</strong> ：由于使用 TCP 进行传输的时候多了连接、确认、重传等机制，所以 TCP 的传输效率要比 UDP 低很多。</li>
<li><strong>传输形式</strong> ： TCP 是面向字节流的，UDP 是面向报文的。</li>
<li><strong>首部开销</strong> ：TCP 首部开销（20 ～ 60 字节）比 UDP 首部开销（8 字节）要大。</li>
<li><strong>是否提供广播或多播服务</strong> ：TCP 只支持点对点通信，UDP 支持一对一、一对多、多对一、多对多；</li>
<li>......</li>
</ol>
<p>我把上面总结的内容通过表格形式展示出来了！确定不点个赞嘛？</p>
<table>
<thead>
<tr>
<th></th>
<th>TCP</th>
<th>UDP</th>
</tr>
</thead>
<tbody>
<tr>
<td>是否面向连接</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>是否可靠</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>是否有状态</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>传输效率</td>
<td>较慢</td>
<td>较快</td>
</tr>
<tr>
<td>传输形式</td>
<td>字节流</td>
<td>数据报文段</td>
</tr>
<tr>
<td>首部开销</td>
<td>20 ～ 60 bytes</td>
<td>8 bytes</td>
</tr>
<tr>
<td>是否提供广播或多播服务</td>
<td>否</td>
<td>是</td>
</tr>
</tbody>
</table>
<h3> 什么时候选择 TCP,什么时候选 UDP?</h3>
<ul>
<li><strong>UDP 一般用于即时通信</strong>，比如： 语音、 视频 、直播等等。这些场景对传输数据的准确性要求不是特别高，比如你看视频即使少个一两帧，实际给人的感觉区别也不大。</li>
<li><strong>TCP 用于对传输准确性要求特别高的场景</strong>，比如文件传输、发送和接收邮件、远程登录等等。</li>
</ul>
<h3> HTTP 基于 TCP 还是 UDP？</h3>
<p><strong>HTTP 协议是基于 TCP 协议的</strong>，所以发送 HTTP 请求之前首先要建立 TCP 连接也就是要经历 3 次握手。</p>
<h3> 使用 TCP 的协议有哪些?使用 UDP 的协议有哪些?</h3>
<p><strong>运行于 TCP 协议之上的协议</strong> ：</p>
<ol>
<li><strong>HTTP 协议</strong> ：超文本传输协议（HTTP，HyperText Transfer Protocol)主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。当我们使用浏览器浏览网页的时候，我们网页就是通过 HTTP 请求进行加载的。</li>
<li><strong>HTTPS 协议</strong> ：更安全的超文本传输协议(HTTPS,Hypertext Transfer Protocol Secure)，身披 SSL 外衣的 HTTP 协议</li>
<li><strong>FTP 协议</strong>：文件传输协议 FTP（File Transfer Protocol），提供文件传输服务，<strong>基于 TCP</strong> 实现可靠的传输。使用 FTP 传输文件的好处是可以屏蔽操作系统和文件存储方式。</li>
<li><strong>SMTP 协议</strong>：简单邮件传输协议（SMTP，Simple Mail Transfer Protocol）的缩写，<strong>基于 TCP 协议</strong>，用来发送电子邮件。注意 ⚠️：接受邮件的协议不是 SMTP 而是 POP3 协议。</li>
<li><strong>POP3/IMAP 协议</strong>： POP3 和 IMAP 两者都是负责邮件接收的协议。</li>
<li><strong>Telent 协议</strong>：远程登陆协议，通过一个终端登陆到其他服务器。被一种称为 SSH 的非常安全的协议所取代。</li>
<li><strong>SSH 协议</strong> : SSH（ Secure Shell）是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH 建立在可靠的传输协议 TCP 之上。</li>
<li>......</li>
</ol>
<p><strong>运行于 UDP 协议之上的协议</strong> ：</p>
<ol>
<li><strong>DHCP 协议</strong>：动态主机配置协议，动态配置 IP 地址</li>
<li><strong>DNS</strong> ： <strong>域名系统（DNS，Domain Name System）将人类可读的域名 (例如，www.baidu.com) 转换为机器可读的 IP 地址 (例如，220.181.38.148)。</strong> 我们可以将其理解为专为互联网设计的电话薄。实际上 DNS 同时支持 UDP 和 TCP 协议。</li>
</ol>
<h3> TCP 三次握手和四次挥手（非常重要）</h3>
<p><strong>相关面试题</strong> ：</p>
<ul>
<li>为什么要三次握手?</li>
<li>第 2 次握手传回了ACK，为什么还要传回SYN？</li>
<li>为什么要四次挥手？</li>
<li>为什么不能把服务器发送的 ACK 和 FIN 合并起来，变成三次挥手？</li>
<li>如果第二次挥手时服务器的 ACK 没有送达客户端，会怎样？</li>
<li>为什么第四次挥手客户端需要等待 2*MSL（报文段最长寿命）时间后才进入 CLOSED 状态？</li>
</ul>
<p><strong>参考答案</strong> ：<a href="/cs-basics/network/tcp-connection-and-disconnection.html" target="blank">TCP 三次握手和四次挥手（传输层）</a> 。</p>
<h3> TCP 如何保证传输的可靠性？（重要）</h3>
<p><a href="/cs-basics/network/tcp-reliability-guarantee.html" target="blank">TCP 传输可靠性保障（传输层）</a></p>
<h2> HTTP</h2>
<h3> 从输入URL 到页面展示到底发生了什么？（非常重要）</h3>
<blockquote>
<p>类似的问题：打开一个网页，整个过程会使用哪些协议？</p>
</blockquote>
<p>图解（图片来源：《图解 HTTP》）：</p>
<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/url输入到展示出来的过程.jpg" style="zoom:50%; ">
<blockquote>
<p>上图有一个错误，请注意，是 OSPF 不是 OPSF。 OSPF（Open Shortest Path First，ospf）开放最短路径优先协议, 是由 Internet 工程任务组开发的路由选择协议</p>
</blockquote>
<p>总体来说分为以下几个过程:</p>
<ol>
<li>DNS 解析</li>
<li>TCP 连接</li>
<li>发送 HTTP 请求</li>
<li>服务器处理请求并返回 HTTP 报文</li>
<li>浏览器解析渲染页面</li>
<li>连接结束</li>
</ol>
<p>具体可以参考下面这两篇文章：</p>
<ul>
<li><a href="https://segmentfault.com/a/1190000006879700" target="_blank" rel="noopener noreferrer">从输入URL到页面加载发生了什么？</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1879758" target="_blank" rel="noopener noreferrer">浏览器从输入网址到页面展示的过程</a></li>
</ul>
<h3> HTTP 状态码有哪些？</h3>
<p>HTTP 状态码用于描述 HTTP 请求的结果，比如2xx 就代表请求被成功处理。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/状态码.png" alt="HTTP 状态码"></p>
<p>关于 HTTP 状态码更详细的总结，可以看我写的这篇文章：<a href="/cs-basics/network/http-status-codes.html" target="blank">HTTP 常见状态码总结（应用层）</a>。</p>
<h3> HTTP 和 HTTPS 有什么区别？（重要）</h3>
<ul>
<li><strong>端口号</strong> ：HTTP 默认是 80，HTTPS 默认是 443。</li>
<li><strong>URL 前缀</strong> ：HTTP 的 URL 前缀是 <code>http://</code>，HTTPS 的 URL 前缀是 <code>https://</code>。</li>
<li><strong>安全性和资源消耗</strong> ： HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL/TLS 之上的 HTTP 协议，SSL/TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。</li>
</ul>
<p>关于 HTTP 和 HTTPS 更详细的对比总结，可以看我写的这篇文章：<a href="/cs-basics/network/http&amp;https.html" target="blank">HTTP vs HTTPS（应用层）</a> 。</p>
<h3> HTTP 1.0 和 HTTP 1.1 有什么区别？</h3>
<ul>
<li><strong>连接方式</strong> : HTTP 1.0 为短连接，HTTP 1.1 支持长连接。</li>
<li><strong>状态响应码</strong> : HTTP/1.1中新加入了大量的状态码，光是错误响应状态码就新增了24种。比如说，<code>100 (Continue)</code>——在请求大资源前的预热请求，<code>206 (Partial Content)</code>——范围请求的标识码，<code>409 (Conflict)</code>——请求与当前资源的规定冲突，<code>410 (Gone)</code>——资源已被永久转移，而且没有任何已知的转发地址。</li>
<li><strong>缓存处理</strong> : 在 HTTP1.0 中主要使用 header 里的 If-Modified-Since,Expires 来做为缓存判断的标准，HTTP1.1 则引入了更多的缓存控制策略例如 Entity tag，If-Unmodified-Since, If-Match, If-None-Match 等更多可供选择的缓存头来控制缓存策略。</li>
<li><strong>带宽优化及网络连接的使用</strong> :HTTP1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li>
<li><strong>Host头处理</strong> : HTTP/1.1在请求头中加入了<code>Host</code>字段。</li>
</ul>
<p>关于 HTTP 1.0 和 HTTP 1.1 更详细的对比总结，可以看我写的这篇文章：<a href="/cs-basics/network/http1.0&amp;http1.1.html" target="blank">HTTP 1.0 vs HTTP 1.1（应用层）</a> 。</p>
<h3> HTTP 是不保存状态的协议, 如何保存用户状态?</h3>
<p>HTTP 是一种不保存状态，即无状态（stateless）协议。也就是说 HTTP 协议自身不对请求和响应之间的通信状态进行保存。那么我们保存用户状态呢？Session 机制的存在就是为了解决这个问题，Session 的主要作用就是通过服务端记录用户的状态。典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个 Session）。</p>
<p>在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库 redis 保存)。既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？大部分情况下，我们都是通过在 Cookie 中附加一个 Session ID 来方式来跟踪。</p>
<p><strong>Cookie 被禁用怎么办?</strong></p>
<p>最常用的就是利用 URL 重写把 Session ID 直接附加在 URL 路径的后面。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/HTTP是无状态的.png" alt="HTTP是无状态协议"></p>
<h3> URI 和 URL 的区别是什么?</h3>
<ul>
<li>URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。</li>
<li>URL(Uniform Resource Locator) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。</li>
</ul>
<p>URI 的作用像身份证号一样，URL 的作用更像家庭住址一样。URL 是一种具体的 URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。</p>
<h2> ARP</h2>
<h3> 什么是 Mac 地址？</h3>
<p>MAC 地址的全称是 <strong>媒体访问控制地址（Media Access Control Address）</strong>。如果说，互联网中每一个资源都由 IP 地址唯一标识（IP 协议内容），那么一切网络设备都由 MAC 地址唯一标识。</p>
<p></p>
<p>可以理解为，MAC 地址是一个网络设备真正的身份证号，IP 地址只是一种不重复的定位方式（比如说住在某省某市某街道的张三，这种逻辑定位是 IP 地址，他的身份证号才是他的 MAC 地址），也可以理解为 MAC 地址是身份证号，IP 地址是邮政地址。MAC 地址也有一些别称，如 LAN 地址、物理地址、以太网地址等。</p>
<blockquote>
<p>还有一点要知道的是，不仅仅是网络资源才有 IP 地址，网络设备也有 IP 地址，比如路由器。但从结构上说，路由器等网络设备的作用是组成一个网络，而且通常是内网，所以它们使用的 IP 地址通常是内网 IP，内网的设备在与内网以外的设备进行通信时，需要用到 NAT 协议。</p>
</blockquote>
<p>MAC 地址的长度为 6 字节（48 比特），地址空间大小有 280 万亿之多（$2^{48}$），MAC 地址由 IEEE 统一管理与分配，理论上，一个网络设备中的网卡上的 MAC 地址是永久的。不同的网卡生产商从 IEEE 那里购买自己的 MAC 地址空间（MAC 的前 24 比特），也就是前 24 比特由 IEEE 统一管理，保证不会重复。而后 24 比特，由各家生产商自己管理，同样保证生产的两块网卡的 MAC 地址不会重复。</p>
<p>MAC 地址具有可携带性、永久性，身份证号永久地标识一个人的身份，不论他到哪里都不会改变。而 IP 地址不具有这些性质，当一台设备更换了网络，它的 IP 地址也就可能发生改变，也就是它在互联网中的定位发生了变化。</p>
<p>最后，记住，MAC 地址有一个特殊地址：FF-FF-FF-FF-FF-FF（全 1 地址），该地址表示广播地址。</p>
<h3> ARP 协议解决了什么问题地位如何？</h3>
<p>ARP 协议，全称 <strong>地址解析协议（Address Resolution Protocol）</strong>，它解决的是网络层地址和链路层地址之间的转换问题。因为一个 IP 数据报在物理上传输的过程中，总是需要知道下一跳（物理上的下一个目的地）该去往何处，但 IP 地址属于逻辑地址，而 MAC 地址才是物理地址，ARP 协议解决了 IP 地址转 MAC 地址的一些问题。</p>
<h3> ARP 协议的工作原理？</h3>
<p><a href="/cs-basics/network/arp.html" target="blank">ARP 协议详解(网络层)</a></p>
<h2> 复习建议</h2>
<p>非常推荐大家看一下 《图解 HTTP》 这本书，这本书页数不多，但是内容很是充实，不管是用来系统的掌握网络方面的一些知识还是说纯粹为了应付面试都有很大帮助。下面的一些文章只是参考。大二学习这门课程的时候，我们使用的教材是 《计算机网络第七版》（谢希仁编著），不推荐大家看这本教材，书非常厚而且知识偏理论，不确定大家能不能心平气和的读完。</p>
]]></content:encoded>
      <enclosure url="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019/7/状态码.png" type="image/png"/>
    </item>
    <item>
      <title>TCP 三次握手和四次挥手（传输层）</title>
      <link>https://javaguide.cn/cs-basics/network/tcp-connection-and-disconnection.html</link>
      <guid>https://javaguide.cn/cs-basics/network/tcp-connection-and-disconnection.html</guid>
      <source url="https://javaguide.cn/rss.xml">TCP 三次握手和四次挥手（传输层）</source>
      <description>为了准确无误地把数据送达目标处，TCP 协议采用了三次握手策略。 建立连接-TCP 三次握手 建立一个 TCP 连接需要“三次握手”，缺一不可 ： 一次握手:客户端发送带有 SYN（SEQ=x） 标志的数据包 -&amp;gt; 服务端，然后客户端进入 SYN_SEND 状态，等待服务器的确认； 二次握手:服务端发送带有 SYN+ACK(SEQ=y,ACK=x+1) 标志的数据包 –&amp;gt; 客户端,然后服务端进入 SYN_RECV 状态 三次握手:客户端发送带有带有 ACK(ACK=y+1) 标志的数据包 –&amp;gt; 服务端，然后客户端和服务器端都进入ESTABLISHED 状态，完成TCP三次握手。</description>
      <category>计算机基础</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<p>为了准确无误地把数据送达目标处，TCP 协议采用了三次握手策略。</p>
<h2> 建立连接-TCP 三次握手</h2>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/network/tcp-shakes-hands-three-times.png" alt="TCP 三次握手图解"></p>
<p>建立一个 TCP 连接需要“三次握手”，缺一不可 ：</p>
<ul>
<li><strong>一次握手</strong>:客户端发送带有 SYN（SEQ=x） 标志的数据包 -&gt; 服务端，然后客户端进入 <strong>SYN_SEND</strong> 状态，等待服务器的确认；</li>
<li><strong>二次握手</strong>:服务端发送带有 SYN+ACK(SEQ=y,ACK=x+1) 标志的数据包 –&gt; 客户端,然后服务端进入 <strong>SYN_RECV</strong> 状态</li>
<li><strong>三次握手</strong>:客户端发送带有带有 ACK(ACK=y+1) 标志的数据包 –&gt; 服务端，然后客户端和服务器端都进入<strong>ESTABLISHED</strong> 状态，完成TCP三次握手。</li>
</ul>
<p><strong>当建立了 3 次握手之后，客户端和服务端就可以传输数据啦！</strong></p>
<h3> 为什么要三次握手?</h3>
<p>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</p>
<ol>
<li><strong>第一次握手</strong> ：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常</li>
<li><strong>第二次握手</strong> ：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</li>
<li><strong>第三次握手</strong> ：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常</li>
</ol>
<p>三次握手就能确认双方收发功能都正常，缺一不可。</p>
<p>更详细的解答可以看这个：<a href="https://www.zhihu.com/question/24853633/answer/115173386" target="_blank" rel="noopener noreferrer">TCP 为什么是三次握手，而不是两次或四次？ - 车小胖的回答 - 知乎</a>  。</p>
<h3> 第2次握手传回了ACK，为什么还要传回SYN？</h3>
<p>服务端传回发送端所发送的 ACK 是为了告诉客户端：“我接收到的信息确实就是你所发送的信号了”，这表明从客户端到服务端的通信是正常的。回传 SYN 则是为了建立并确认从服务端到客户端的通信。</p>
<blockquote>
<p>SYN 同步序列编号(Synchronize Sequence Numbers) 是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement）消息响应。这样在客户机和服务器之间才能建立起可靠的 TCP 连接，数据才可以在客户机和服务器之间传递。</p>
</blockquote>
<h2> 断开连接-TCP 四次挥手</h2>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/network/tcp-waves-four-times.png" alt="TCP 四次挥手图解"></p>
<p>断开一个 TCP 连接则需要“四次挥手”，缺一不可 ：</p>
<ol>
<li><strong>第一次挥手</strong> ：客户端发送一个 FIN（SEQ=X） 标志的数据包-&gt;服务端，用来关闭客户端到服务器的数据传送。然后，客户端进入 <strong>FIN-WAIT-1</strong> 状态。</li>
<li><strong>第二次挥手</strong> ：服务器收到这个 FIN（SEQ=X） 标志的数据包，它发送一个 ACK （SEQ=X+1）标志的数据包-&gt;客户端 。然后，此时服务端进入<strong>CLOSE-WAIT</strong>状态，客户端进入<strong>FIN-WAIT-2</strong>状态。</li>
<li><strong>第三次挥手</strong> ：服务端关闭与客户端的连接并发送一个 FIN (SEQ=y)标志的数据包-&gt;客户端请求关闭连接，然后，服务端进入<strong>LAST-ACK</strong>状态。</li>
<li><strong>第四次挥手</strong> ：客户端发送 ACK (SEQ=y+1)标志的数据包-&gt;服务端并且进入<strong>TIME-WAIT</strong>状态，服务端在收到 ACK (SEQ=y+1)标志的数据包后进入 CLOSE 状态。此时，如果客户端等待 <strong>2MSL</strong> 后依然没有收到回复，就证明服务端已正常关闭，随后，客户端也可以关闭连接了。</li>
</ol>
<p><strong>只要四次挥手没有结束，客户端和服务端就可以继续传输数据！</strong></p>
<h3> 为什么要四次挥手？</h3>
<p>TCP是全双工通信，可以双向传输数据。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接。</p>
<p>举个例子：A 和 B 打电话，通话即将结束后。</p>
<ol>
<li><strong>第一次挥手</strong> ： A 说“我没啥要说的了”</li>
<li><strong>第二次挥手</strong> ：B 回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话</li>
<li><strong>第三次挥手</strong> ：于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”</li>
<li><strong>第四次挥手</strong> ：A 回答“知道了”，这样通话才算结束。</li>
</ol>
<h3> 为什么不能把服务器发送的 ACK 和 FIN 合并起来，变成三次挥手？</h3>
<p>因为服务器收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复 ACK，表示接收到了断开连接的请求。等到数据发完之后再发 FIN，断开服务器到客户端的数据传送。</p>
<h3> 如果第二次挥手时服务器的 ACK 没有送达客户端，会怎样？</h3>
<p>客户端没有收到 ACK 确认，会重新发送 FIN 请求。</p>
<h3> 为什么第四次挥手客户端需要等待 2*MSL（报文段最长寿命）时间后才进入 CLOSED 状态？</h3>
<p>第四次挥手时，客户端发送给服务器的 ACK 有可能丢失，如果服务端没有因为某些原因而没有收到 ACK 的话，服务端就会重发 FIN，如果客户端在 2*MSL 的时间内收到了 FIN，就会重新发送 ACK 并再次等待 2MSL，防止 Server 没有收到 ACK 而不断重发 FIN。</p>
<blockquote>
<p><strong>MSL(Maximum Segment Lifetime)</strong> : 一个片段在网络中最大的存活时间，2MSL 就是一个发送和一个回复所需的最大时间。如果直到 2MSL，Client 都没有再次收到 FIN，那么 Client 推断 ACK 已经被成功接收，则结束 TCP 连接。</p>
</blockquote>
<h2> 参考</h2>
<ul>
<li>
<p>《计算机网络（第 7 版）》</p>
</li>
<li>
<p>《图解 HTTP》</p>
</li>
<li>
<p>TCP and UDP Tutorial：https://www.9tut.com/tcp-and-udp-tutorial</p>
</li>
</ul>
]]></content:encoded>
      <enclosure url="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/network/tcp-shakes-hands-three-times.png" type="image/png"/>
    </item>
    <item>
      <title>TCP 传输可靠性保障（传输层）</title>
      <link>https://javaguide.cn/cs-basics/network/tcp-reliability-guarantee.html</link>
      <guid>https://javaguide.cn/cs-basics/network/tcp-reliability-guarantee.html</guid>
      <source url="https://javaguide.cn/rss.xml">TCP 传输可靠性保障（传输层）</source>
      <description>TCP 如何保证传输的可靠性？ 基于数据块传输 ：应用数据被分割成 TCP 认为最适合发送的数据块，再传输给网络层，数据块被称为报文段或段。 对失序数据包重新排序以及去重：TCP 为了保证不发生丢包，就给每个包一个序列号，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据就可以实现数据包去重。 校验和 : TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。 超时重传 : 当发送方发送数据之后，它启动一个定时器，等待目的端确认收到这个报文段。接收端实体对已成功收到的包发回一个相应的确认信息（ACK）。如果发送端实体在合理的往返时延（RTT）内未收到确认消息，那么对应的数据包就被假设为已丢失并进行重传。 流量控制 : TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议（TCP 利用滑动窗口实现流量控制）。 拥塞控制 : 当网络拥塞时，减少数据的发送。</description>
      <category>计算机基础</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<h2> TCP 如何保证传输的可靠性？</h2>
<ol>
<li><strong>基于数据块传输</strong> ：应用数据被分割成 TCP 认为最适合发送的数据块，再传输给网络层，数据块被称为报文段或段。</li>
<li><strong>对失序数据包重新排序以及去重</strong>：TCP 为了保证不发生丢包，就给每个包一个序列号，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据就可以实现数据包去重。</li>
<li><strong>校验和</strong> : TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li>
<li><strong>超时重传</strong> : 当发送方发送数据之后，它启动一个定时器，等待目的端确认收到这个报文段。接收端实体对已成功收到的包发回一个相应的确认信息（ACK）。如果发送端实体在合理的往返时延（RTT）内未收到确认消息，那么对应的数据包就被假设为<a href="https://zh.wikipedia.org/wiki/%E4%B8%A2%E5%8C%85" target="_blank" rel="noopener noreferrer">已丢失</a>并进行重传。</li>
<li><strong>流量控制</strong> : TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议（TCP 利用滑动窗口实现流量控制）。</li>
<li><strong>拥塞控制</strong> : 当网络拥塞时，减少数据的发送。</li>
</ol>
<h2> TCP 如何实现流量控制？</h2>
<p><strong>TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。</strong> 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p>
<p><strong>为什么需要流量控制?</strong> 这是因为双方在通信的时候，发送方的速率与接收方的速率是不一定相等，如果发送方的发送速率太快，会导致接收方处理不过来。如果接收方处理不过来的话，就只能把处理不过来的数据存在 <strong>接收缓冲区(Receiving Buffers)</strong> 里（失序的数据包也会被存放在缓存区里）。如果缓存区满了发送方还在狂发数据的话，接收方只能把收到的数据包丢掉。出现丢包问题的同时又疯狂浪费着珍贵的网络资源。因此，我们需要控制发送方的发送速率，让接收方与发送方处于一种动态平衡才好。</p>
<p>这里需要注意的是（常见误区）：</p>
<ul>
<li>发送端不等同于客户端</li>
<li>接收端不等同于服务端</li>
</ul>
<p>TCP 为全双工(Full-Duplex, FDX)通信，双方可以进行双向通信，客户端和服务端既可能是发送端又可能是服务端。因此，两端各有一个发送缓冲区与接收缓冲区，两端都各自维护一个发送窗口和一个接收窗口。接收窗口大小取决于应用、系统、硬件的限制（TCP传输速率不能大于应用的数据处理速率）。通信双方的发送窗口和接收窗口的要求相同</p>
<p><strong>TCP 发送窗口可以划分成四个部分</strong> ：</p>
<ol>
<li>已经发送并且确认的TCP段（已经发送并确认）；</li>
<li>已经发送但是没有确认的TCP段（已经发送未确认）；</li>
<li>未发送但是接收方准备接收的TCP段（可以发送）；</li>
<li>未发送并且接收方也并未准备接受的TCP段（不可发送）。</li>
</ol>
<p><strong>TCP发送窗口结构图示</strong> ：</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/network/tcp-send-window.png" alt="TCP发送窗口结构"></p>
<ul>
<li><strong>SND.WND</strong> ：发送窗口。</li>
<li><strong>SND.UNA</strong>：Send Unacknowledged 指针，指向发送窗口的第一个字节。</li>
<li><strong>SND.NXT</strong>：Send Next 指针，指向可用窗口的第一个字节。</li>
</ul>
<p><strong>可用窗口大小</strong> =  <code>SND.UNA + SND.WND - SND.NXT</code> 。</p>
<p><strong>TCP 接收窗口可以划分成三个部分</strong> ：</p>
<ol>
<li>已经接收并且已经确认的 TCP 段（已经接收并确认）；</li>
<li>等待接收且允许发送方发送 TCP 段（可以接收未确认）；</li>
<li>不可接收且不允许发送方发送TCP段（不可接收）。</li>
</ol>
<p><strong>TCP 接收窗口结构图示</strong> ：</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/network/tcp-receive-window.png" alt="TCP接收窗口结构"></p>
<p><strong>接收窗口的大小是根据接收端处理数据的速度动态调整的。</strong> 如果接收端读取数据快，接收窗口可能会扩大。 否则，它可能会缩小。</p>
<p>另外，这里的滑动窗口大小只是为了演示使用，实际窗口大小通常会远远大于这个值。</p>
<h2> TCP 的拥塞控制是怎么实现的？</h2>
<p>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/network/tcp-congestion-control.png" alt="TCP的拥塞控制"></p>
<p>为了进行拥塞控制，TCP 发送方要维持一个 <strong>拥塞窗口(cwnd)</strong> 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</p>
<p>TCP 的拥塞控制采用了四种算法，即 <strong>慢开始</strong> 、 <strong>拥塞避免</strong> 、<strong>快重传</strong> 和 <strong>快恢复</strong>。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。</p>
<ul>
<li><strong>慢开始：</strong> 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd 初始值为 1，每经过一个传播轮次，cwnd 加倍。</li>
<li><strong>拥塞避免：</strong> 拥塞避免算法的思路是让拥塞窗口 cwnd 缓慢增大，即每经过一个往返时间 RTT 就把发送放的 cwnd 加 1.</li>
<li><strong>快重传与快恢复：</strong> 在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。 　当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。</li>
</ul>
<h2> ARQ 协议了解吗?</h2>
<p><strong>自动重传请求</strong>（Automatic Repeat-reQuest，ARQ）是 OSI 模型中数据链路层和传输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认信息（Acknoledgements，就是我们常说的 ACK），它通常会重新发送，直到收到确认或者重试超过一定的次数。</p>
<p>ARQ 包括停止等待 ARQ 协议和连续 ARQ 协议。</p>
<h3> 停止等待 ARQ 协议</h3>
<p>停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认（回复 ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组；</p>
<p>在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。</p>
<p><strong>1) 无差错情况:</strong></p>
<p>发送方发送分组,接收方在规定时间内收到,并且回复确认.发送方再次发送。</p>
<p><strong>2) 出现差错情况（超时重传）:</strong></p>
<p>停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为 <strong>自动重传请求 ARQ</strong> 。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。</p>
<p><strong>3) 确认丢失和确认迟到</strong></p>
<ul>
<li><strong>确认丢失</strong> ：确认消息在传输过程丢失。当 A 发送 M1 消息，B 收到后，B 向 A 发送了一个 M1 确认消息，但却在传输过程中丢失。而 A 并不知道，在超时计时过后，A 重传 M1 消息，B 再次收到该消息后采取以下两点措施：1. 丢弃这个重复的 M1 消息，不向上层交付。 2. 向 A 发送确认消息。（不会认为已经发送过了，就不再发送。A 能重传，就证明 B 的确认消息丢失）。</li>
<li><strong>确认迟到</strong> ：确认消息在传输过程中迟到。A 发送 M1 消息，B 收到并发送确认。在超时时间内没有收到确认消息，A 重传 M1 消息，B 仍然收到并继续发送确认消息（B 收到了 2 份 M1）。此时 A 收到了 B 第二次发送的确认消息。接着发送其他数据。过了一会，A 收到了 B 第一次发送的对 M1 的确认消息（A 也收到了 2 份确认消息）。处理如下：1. A 收到重复的确认后，直接丢弃。2. B 收到重复的 M1 后，也直接丢弃重复的 M1。</li>
</ul>
<h3> 连续 ARQ 协议</h3>
<p>连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。</p>
<p><strong>优点：</strong> 信道利用率高，容易实现，即使确认丢失，也不必重传。</p>
<p><strong>缺点：</strong> 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5 条 消息，中间第三条丢失（3 号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。</p>
<h2> Reference</h2>
<ol>
<li>《计算机网络（第 7 版）》</li>
<li>《图解 HTTP》</li>
<li><a href="https://www.9tut.com/tcp-and-udp-tutorial" target="_blank" rel="noopener noreferrer">https://www.9tut.com/tcp-and-udp-tutorial</a></li>
<li><a href="https://github.com/wolverinn/Waking-Up/blob/master/Computer%20Network.md" target="_blank" rel="noopener noreferrer">https://github.com/wolverinn/Waking-Up/blob/master/Computer%20Network.md</a></li>
<li>TCP Flow Control—<a href="https://www.brianstorti.com/tcp-flow-control/" target="_blank" rel="noopener noreferrer">https://www.brianstorti.com/tcp-flow-control/</a></li>
<li>TCP 流量控制(Flow Control)：https://notfalse.net/24/tcp-flow-control</li>
<li>TCP之滑动窗口原理 : https://cloud.tencent.com/developer/article/1857363</li>
</ol>
]]></content:encoded>
      <enclosure url="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/network/tcp-send-window.png" type="image/png"/>
    </item>
    <item>
      <title>一千行 MySQL 学习笔记</title>
      <link>https://javaguide.cn/database/mysql/a-thousand-lines-of-mysql-study-notes.html</link>
      <guid>https://javaguide.cn/database/mysql/a-thousand-lines-of-mysql-study-notes.html</guid>
      <source url="https://javaguide.cn/rss.xml">一千行 MySQL 学习笔记</source>
      <description>原文地址：https://shockerli.net/post/1000-line-mysql-note/ ，JavaGuide 对本文进行了简答排版，新增了目录。 非常不错的总结，强烈建议保存下来，需要的时候看一看。 基本操作 /* Windows服务 */ -- 启动 MySQL 			net start mysql -- 创建Windows服务 				sc create mysql binPath= mysqld_bin_path(注意：等号与值之间有空格) /* 连接与断开服务器 */ -- 连接 MySQL 				mysql -h 地址 -P 端口 -u 用户名 -p 密码 -- 显示哪些线程正在运行 				SHOW PROCESSLIST -- 显示系统变量信息 				SHOW VARIABLES</description>
      <category>数据库</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>原文地址：https://shockerli.net/post/1000-line-mysql-note/ ，JavaGuide 对本文进行了简答排版，新增了目录。</p>
</blockquote>
<p>非常不错的总结，强烈建议保存下来，需要的时候看一看。</p>
<h3> 基本操作</h3>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 数据库操作</h3>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 表的操作</h3>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 数据操作</h3>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 字符集编码</h3>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 数据类型(列类型)</h3>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 列属性(列约束)</h3>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 建表规范</h3>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> SELECT</h3>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> UNION</h3>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 子查询</h3>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 连接查询(join)</h3>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> TRUNCATE</h3>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 备份与还原</h3>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 视图</h3>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 事务(transaction)</h3>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 锁表</h3>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 触发器</h3>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> SQL编程</h3>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 存储过程</h3>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 用户和权限管理</h3>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 表维护</h3>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 杂项</h3>
<div class="language-mysql line-numbers-mode" data-ext="mysql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
    </item>
    <item>
      <title>SQL语句在MySQL中的执行过程</title>
      <link>https://javaguide.cn/database/mysql/how-sql-executed-in-mysql.html</link>
      <guid>https://javaguide.cn/database/mysql/how-sql-executed-in-mysql.html</guid>
      <source url="https://javaguide.cn/rss.xml">SQL语句在MySQL中的执行过程</source>
      <description>本文来自木木匠投稿。 本篇文章会分析下一个 SQL 语句在 MySQL 中的执行流程，包括 SQL 的查询在 MySQL 内部会怎么流转，SQL 语句的更新是怎么完成的。 在分析之前我会先带着你看看 MySQL 的基础架构，知道了 MySQL 由那些组件组成以及这些组件的作用是什么，可以帮助我们理解和解决这些问题。 一 MySQL 基础架构分析</description>
      <category>数据库</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>本文来自<a href="https://github.com/kinglaw1204" target="_blank" rel="noopener noreferrer">木木匠</a>投稿。</p>
</blockquote>
<p>本篇文章会分析下一个 SQL 语句在 MySQL 中的执行流程，包括 SQL 的查询在 MySQL 内部会怎么流转，SQL 语句的更新是怎么完成的。</p>
<p>在分析之前我会先带着你看看 MySQL 的基础架构，知道了 MySQL 由那些组件组成以及这些组件的作用是什么，可以帮助我们理解和解决这些问题。</p>
<h2> 一 MySQL 基础架构分析</h2>
<h3> 1.1 MySQL 基本架构概览</h3>
<p>下图是 MySQL  的一个简要架构图，从下图你可以很清晰的看到用户的 SQL 语句在 MySQL 内部是如何执行的。</p>
<p>先简单介绍一下下图涉及的一些组件的基本作用帮助大家理解这幅图，在 1.2 节中会详细介绍到这些组件的作用。</p>
<ul>
<li><strong>连接器：</strong> 身份认证和权限相关(登录 MySQL 的时候)。</li>
<li><strong>查询缓存：</strong> 执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。</li>
<li><strong>分析器：</strong> 没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。</li>
<li><strong>优化器：</strong> 按照 MySQL 认为最优的方案去执行。</li>
<li><strong>执行器：</strong> 执行语句，然后从存储引擎返回数据。 -</li>
</ul>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/13526879-3037b144ed09eb88.png" alt=""></p>
<p>简单来说 MySQL  主要分为 Server 层和存储引擎层：</p>
<ul>
<li><strong>Server 层</strong>：主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 binlog 日志模块。</li>
<li><strong>存储引擎</strong>： 主要负责数据的存储和读取，采用可以替换的插件式架构，支持 InnoDB、MyISAM、Memory 等多个存储引擎，其中 InnoDB 引擎有自有的日志模块 redolog 模块。<strong>现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5 版本开始就被当做默认存储引擎了。</strong></li>
</ul>
<h3> 1.2 Server 层基本组件介绍</h3>
<h4> 1) 连接器</h4>
<p>连接器主要和身份认证和权限相关的功能相关，就好比一个级别很高的门卫一样。</p>
<p>主要负责用户登录数据库，进行用户的身份认证，包括校验账户密码，权限等操作，如果用户账户密码已通过，连接器会到权限表中查询该用户的所有权限，之后在这个连接里的权限逻辑判断都是会依赖此时读取到的权限数据，也就是说，后续只要这个连接不断开，即使管理员修改了该用户的权限，该用户也是不受影响的。</p>
<h4> 2) 查询缓存(MySQL 8.0 版本后移除)</h4>
<p>查询缓存主要用来缓存我们所执行的 SELECT 语句以及该语句的结果集。</p>
<p>连接建立后，执行查询语句的时候，会先查询缓存，MySQL 会先校验这个 SQL 是否执行过，以 Key-Value 的形式缓存在内存中，Key 是查询预计，Value 是结果集。如果缓存 key 被命中，就会直接返回给客户端，如果没有命中，就会执行后续的操作，完成后也会把结果缓存起来，方便下一次调用。当然在真正执行缓存查询的时候还是会校验用户的权限，是否有该表的查询条件。</p>
<p>MySQL 查询不建议使用缓存，因为查询缓存失效在实际业务场景中可能会非常频繁，假如你对一个表更新的话，这个表上的所有的查询缓存都会被清空。对于不经常更新的数据来说，使用缓存还是可以的。</p>
<p>所以，一般在大多数情况下我们都是不推荐去使用查询缓存的。</p>
<p>MySQL 8.0 版本后删除了缓存的功能，官方也是认为该功能在实际的应用场景比较少，所以干脆直接删掉了。</p>
<h4> 3) 分析器</h4>
<p>MySQL 没有命中缓存，那么就会进入分析器，分析器主要是用来分析 SQL 语句是来干嘛的，分析器也会分为几步：</p>
<p><strong>第一步，词法分析</strong>，一条 SQL 语句有多个字符串组成，首先要提取关键字，比如 select，提出查询的表，提出字段名，提出查询条件等等。做完这些操作后，就会进入第二步。</p>
<p><strong>第二步，语法分析</strong>，主要就是判断你输入的 SQL 是否正确，是否符合 MySQL 的语法。</p>
<p>完成这 2 步之后，MySQL 就准备开始执行了，但是如何执行，怎么执行是最好的结果呢？这个时候就需要优化器上场了。</p>
<h4> 4) 优化器</h4>
<p>优化器的作用就是它认为的最优的执行方案去执行（有时候可能也不是最优，这篇文章涉及对这部分知识的深入讲解），比如多个索引的时候该如何选择索引，多表查询的时候如何选择关联顺序等。</p>
<p>可以说，经过了优化器之后可以说这个语句具体该如何执行就已经定下来。</p>
<h4> 5) 执行器</h4>
<p>当选择了执行方案后，MySQL 就准备开始执行了，首先执行前会校验该用户有没有权限，如果没有权限，就会返回错误信息，如果有权限，就会去调用引擎的接口，返回接口执行的结果。</p>
<h2> 二 语句分析</h2>
<h3> 2.1 查询语句</h3>
<p>说了以上这么多，那么究竟一条 SQL 语句是如何执行的呢？其实我们的 SQL 可以分为两种，一种是查询，一种是更新（增加，修改，删除）。我们先分析下查询语句，语句如下：</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>结合上面的说明，我们分析下这个语句的执行流程：</p>
<ul>
<li>
<p>先检查该语句是否有权限，如果没有权限，直接返回错误信息，如果有权限，在 MySQL8.0 版本以前，会先查询缓存，以这条 SQL 语句为 key 在内存中查询是否有结果，如果有直接缓存，如果没有，执行下一步。</p>
</li>
<li>
<p>通过分析器进行词法分析，提取 SQL 语句的关键元素，比如提取上面这个语句是查询 select，提取需要查询的表名为 tb_student，需要查询所有的列，查询条件是这个表的 id='1'。然后判断这个 SQL 语句是否有语法错误，比如关键词是否正确等等，如果检查没问题就执行下一步。</p>
</li>
<li>
<p>接下来就是优化器进行确定执行方案，上面的 SQL 语句，可以有两种执行方案：</p>

<p>那么优化器根据自己的优化算法进行选择执行效率最好的一个方案（优化器认为，有时候不一定最好）。那么确认了执行计划后就准备开始执行了。</p>
</li>
<li>
<p>进行权限校验，如果没有权限就会返回错误信息，如果有权限就会调用数据库引擎接口，返回引擎的执行结果。</p>
</li>
</ul>
<h3> 2.2 更新语句</h3>
<p>以上就是一条查询 SQL 的执行流程，那么接下来我们看看一条更新语句如何执行的呢？SQL 语句如下：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>我们来给张三修改下年龄，在实际数据库肯定不会设置年龄这个字段的，不然要被技术负责人打的。其实这条语句也基本上会沿着上一个查询的流程走，只不过执行更新的时候肯定要记录日志啦，这就会引入日志模块了，MySQL 自带的日志模块是 <strong>binlog（归档日志）</strong> ，所有的存储引擎都可以使用，我们常用的 InnoDB 引擎还自带了一个日志模块 <strong>redo log（重做日志）</strong>，我们就以 InnoDB 模式下来探讨这个语句的执行流程。流程如下：</p>
<ul>
<li>先查询到张三这一条数据，如果有缓存，也是会用到缓存。</li>
<li>然后拿到查询的语句，把 age 改为 19，然后调用引擎 API 接口，写入这一行数据，InnoDB 引擎把数据保存在内存中，同时记录 redo log，此时 redo log 进入 prepare 状态，然后告诉执行器，执行完成了，随时可以提交。</li>
<li>执行器收到通知后记录 binlog，然后调用引擎接口，提交 redo log 为提交状态。</li>
<li>更新完成。</li>
</ul>
<p><strong>这里肯定有同学会问，为什么要用两个日志模块，用一个日志模块不行吗?</strong></p>
<p>这是因为最开始 MySQL 并没有 InnoDB 引擎（InnoDB 引擎是其他公司以插件形式插入 MySQL 的），MySQL 自带的引擎是 MyISAM，但是我们知道 redo log 是 InnoDB 引擎特有的，其他存储引擎都没有，这就导致会没有 crash-safe 的能力(crash-safe 的能力即使数据库发生异常重启，之前提交的记录都不会丢失)，binlog 日志只能用来归档。</p>
<p>并不是说只用一个日志模块不可以，只是 InnoDB 引擎就是通过 redo log 来支持事务的。那么，又会有同学问，我用两个日志模块，但是不要这么复杂行不行，为什么 redo log 要引入 prepare 预提交状态？这里我们用反证法来说明下为什么要这么做？</p>
<ul>
<li><strong>先写 redo log 直接提交，然后写 binlog</strong>，假设写完 redo log 后，机器挂了，binlog 日志没有被写入，那么机器重启后，这台机器会通过 redo log 恢复数据，但是这个时候 binlog 并没有记录该数据，后续进行机器备份的时候，就会丢失这一条数据，同时主从同步也会丢失这一条数据。</li>
<li><strong>先写 binlog，然后写 redo log</strong>，假设写完了 binlog，机器异常重启了，由于没有 redo log，本机是无法恢复这一条记录的，但是 binlog 又有记录，那么和上面同样的道理，就会产生数据不一致的情况。</li>
</ul>
<p>如果采用 redo log 两阶段提交的方式就不一样了，写完 binlog 后，然后再提交 redo log 就会防止出现上述的问题，从而保证了数据的一致性。那么问题来了，有没有一个极端的情况呢？假设 redo log 处于预提交状态，binlog 也已经写完了，这个时候发生了异常重启会怎么样呢？
这个就要依赖于 MySQL 的处理机制了，MySQL 的处理过程如下：</p>
<ul>
<li>判断 redo log 是否完整，如果判断是完整的，就立即提交。</li>
<li>如果 redo log 只是预提交但不是 commit 状态，这个时候就会去判断 binlog 是否完整，如果完整就提交 redo log, 不完整就回滚事务。</li>
</ul>
<p>这样就解决了数据一致性的问题。</p>
<h2> 三 总结</h2>
<ul>
<li>MySQL 主要分为 Server 层和引擎层，Server 层主要包括连接器、查询缓存、分析器、优化器、执行器，同时还有一个日志模块（binlog），这个日志模块所有执行引擎都可以共用，redolog 只有 InnoDB 有。</li>
<li>引擎层是插件式的，目前主要包括，MyISAM,InnoDB,Memory 等。</li>
<li>查询语句的执行流程如下：权限校验（如果命中缓存）---&gt;查询缓存---&gt;分析器---&gt;优化器---&gt;权限校验---&gt;执行器---&gt;引擎</li>
<li>更新语句执行流程如下：分析器----&gt;权限校验----&gt;执行器---&gt;引擎---redo log(prepare 状态)---&gt;binlog---&gt;redo log(commit状态)</li>
</ul>
<h2> 四 参考</h2>
<ul>
<li>《MySQL 实战45讲》</li>
<li>MySQL 5.6参考手册:<a href="https://dev.MySQL.com/doc/refman/5.6/en/" target="_blank" rel="noopener noreferrer">https://dev.MySQL.com/doc/refman/5.6/en/</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/13526879-3037b144ed09eb88.png" type="image/png"/>
    </item>
    <item>
      <title>MySQL中的隐式转换造成的索引失效</title>
      <link>https://javaguide.cn/database/mysql/index-invalidation-caused-by-implicit-conversion.html</link>
      <guid>https://javaguide.cn/database/mysql/index-invalidation-caused-by-implicit-conversion.html</guid>
      <source url="https://javaguide.cn/rss.xml">MySQL中的隐式转换造成的索引失效</source>
      <description>本次测试使用的 MySQL 版本是 5.7.26，随着 MySQL 版本的更新某些特性可能会发生改变，本文不代表所述观点和结论于 MySQL 所有版本均准确无误，版本差异请自行甄别。 原文：https://www.guitu18.com/post/2019/11/24/61.html 前言 数据库优化是一个任重而道远的任务，想要做优化必须深入理解数据库的各种特性。在开发过程中我们经常会遇到一些原因很简单但造成的后果却很严重的疑难杂症，这类问题往往还不容易定位，排查费时费力最后发现是一个很小的疏忽造成的，又或者是因为不了解某个技术特性产生的。</description>
      <category>数据库</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>本次测试使用的 MySQL 版本是 <code>5.7.26</code>，随着 MySQL 版本的更新某些特性可能会发生改变，本文不代表所述观点和结论于 MySQL 所有版本均准确无误，版本差异请自行甄别。</p>
<p>原文：https://www.guitu18.com/post/2019/11/24/61.html</p>
</blockquote>
<h2> 前言</h2>
<p>数据库优化是一个任重而道远的任务，想要做优化必须深入理解数据库的各种特性。在开发过程中我们经常会遇到一些原因很简单但造成的后果却很严重的疑难杂症，这类问题往往还不容易定位，排查费时费力最后发现是一个很小的疏忽造成的，又或者是因为不了解某个技术特性产生的。</p>
<p>于数据库层面，最常见的恐怕就是索引失效了，且一开始因为数据量小还不易被发现。但随着业务的拓展数据量的提升，性能问题慢慢的就体现出来了，处理不及时还很容易造成雪球效应，最终导致数据库卡死甚至瘫痪。造成索引失效的原因可能有很多种，相关技术博客已经有太多了，今天我要记录的是<strong>隐式转换造成的索引失效</strong>。</p>
<h2> 数据准备</h2>
<p>首先使用存储过程生成 1000 万条测试数据，
测试表一共建立了 7 个字段（包括主键），<code>num1</code>和<code>num2</code>保存的是和<code>ID</code>一样的顺序数字，其中<code>num2</code>是字符串类型。
<code>type1</code>和<code>type2</code>保存的都是主键对 5 的取模，目的是模拟实际应用中常用类似 type 类型的数据，但是<code>type2</code>是没有建立索引的。
<code>str1</code>和<code>str2</code>都是保存了一个 20 位长度的随机字符串，<code>str1</code>不能为<code>NULL</code>，<code>str2</code>允许为<code>NULL</code>，相应的生成测试数据的时候我也会在<code>str2</code>字段生产少量<code>NULL</code>值（每 100 条数据产生一个<code>NULL</code>值）。</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>数据量比较大，还涉及使用<code>MD5</code>生成随机字符串，所以速度有点慢，稍安勿躁，耐心等待即可。</p>
<p>1000 万条数据，我用了 33 分钟才跑完（实际时间跟你电脑硬件配置有关）。这里贴几条生成的数据，大致长这样。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/mysqlindex-invalidation-caused-by-implicit-conversion-01.png" alt=""></p>
<h2> SQL 测试</h2>
<p>先来看这组 SQL，一共四条，我们的测试数据表<code>num1</code>是<code>int</code>类型，<code>num2</code>是<code>varchar</code>类型，但是存储的数据都是跟主键<code>id</code>一样的顺序数字，两个字段都建立有索引。</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这四条 SQL 都是有针对性写的，12 查询的字段是 int 类型，34 查询的字段是<code>varchar</code>类型。12 或 34 查询的字段虽然都相同，但是一个条件是数字，一个条件是用引号引起来的字符串。这样做有什么区别呢？先不看下边的测试结果你能猜出这四条 SQL 的效率顺序吗？</p>
<p>经测试这四条 SQL 最后的执行结果却相差很大，其中 124 三条 SQL 基本都是瞬间出结果，大概在 0.001~0.005 秒，在千万级的数据量下这样的结果可以判定这三条 SQL 性能基本没差别了。但是第三条 SQL，多次测试耗时基本在 4.5~4.8 秒之间。</p>
<p>为什么 34 两条 SQL 效率相差那么大，但是同样做对比的 12 两条 SQL 却没什么差别呢？查看一下执行计划，下边分别 1234 条 SQL 的执行计划数据：</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/mysqlindex-invalidation-caused-by-implicit-conversion-02.png" alt=""></p>
<p>可以看到，124 三条 SQL 都能使用到索引，连接类型都为<code>ref</code>，扫描行数都为 1，所以效率非常高。再看看第三条 SQL，没有用上索引，所以为全表扫描，<code>rows</code>直接到达 1000 万了，所以性能差别才那么大。</p>
<p>仔细观察你会发现，34 两条 SQL 查询的字段<code>num2</code>是<code>varchar</code>类型的，查询条件等号右边加引号的第 4 条 SQL 是用到索引的，那么是查询的数据类型和字段数据类型不一致造成的吗？如果是这样那 12 两条 SQL 查询的字段<code>num1</code>是<code>int</code>类型，但是第 2 条 SQL 查询条件右边加了引号为什么还能用上索引呢。</p>
<p>查阅 MySQL 相关文档发现是隐式转换造成的，看一下官方的描述：</p>
<blockquote>
<p>官方文档： <a href="https://dev.mysql.com/doc/refman/5.7/en/type-conversion.html?spm=5176.100239.blogcont47339.5.1FTben" target="_blank" rel="noopener noreferrer">12.2 Type Conversion in Expression Evaluation</a></p>
<p>当操作符与不同类型的操作数一起使用时，会发生类型转换以使操作数兼容。某些转换是隐式发生的。例如，MySQL 会根据需要自动将字符串转换为数字，反之亦然。以下规则描述了比较操作的转换方式：</p>
<ol>
<li>两个参数至少有一个是<code>NULL</code>时，比较的结果也是<code>NULL</code>，特殊的情况是使用<code>&lt;=&gt;</code>对两个<code>NULL</code>做比较时会返回<code>1</code>，这两种情况都不需要做类型转换</li>
<li>两个参数都是字符串，会按照字符串来比较，不做类型转换</li>
<li>两个参数都是整数，按照整数来比较，不做类型转换</li>
<li>十六进制的值和非数字做比较时，会被当做二进制串</li>
<li>有一个参数是<code>TIMESTAMP</code>或<code>DATETIME</code>，并且另外一个参数是常量，常量会被转换为<code>timestamp</code></li>
<li>有一个参数是<code>decimal</code>类型，如果另外一个参数是<code>decimal</code>或者整数，会将整数转换为<code>decimal</code>后进行比较，如果另外一个参数是浮点数，则会把<code>decimal</code>转换为浮点数进行比较</li>
<li><strong>所有其他情况下，两个参数都会被转换为浮点数再进行比较</strong></li>
</ol>
</blockquote>
<p>根据官方文档的描述，我们的第 23 两条 SQL 都发生了隐式转换，第 2 条 SQL 的查询条件<code>num1 = '10000'</code>，左边是<code>int</code>类型右边是字符串，第 3 条 SQL 相反，那么根据官方转换规则第 7 条，左右两边都会转换为浮点数再进行比较。</p>
<p>先看第 2 条 SQL：<code>SELECT * FROM</code>test1<code>WHERE num1 = '10000';</code> <strong>左边为 int 类型</strong><code>10000</code>，转换为浮点数还是<code>10000</code>，右边字符串类型<code>'10000'</code>，转换为浮点数也是<code>10000</code>。两边的转换结果都是唯一确定的，所以不影响使用索引。</p>
<p>第 3 条 SQL：<code>SELECT * FROM</code>test1<code>WHERE num2 = 10000;</code> <strong>左边是字符串类型</strong><code>'10000'</code>，转浮点数为 10000 是唯一的，右边<code>int</code>类型<code>10000</code>转换结果也是唯一的。但是，因为左边是检索条件，<code>'10000'</code>转到<code>10000</code>虽然是唯一，但是其他字符串也可以转换为<code>10000</code>，比如<code>'10000a'</code>，<code>'010000'</code>，<code>'10000'</code>等等都能转为浮点数<code>10000</code>，这样的情况下，是不能用到索引的。</p>
<p>关于这个<strong>隐式转换</strong>我们可以通过查询测试验证一下，先插入几条数据，其中<code>num2='10000a'</code>、<code>'010000'</code>和<code>'10000'</code>：</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后使用第三条 SQL 语句<code>SELECT * FROM</code>test1<code>WHERE num2 = 10000;</code>进行查询：</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/mysqlindex-invalidation-caused-by-implicit-conversion-03.png" alt=""></p>
<p>从结果可以看到，后面插入的三条数据也都匹配上了。那么这个字符串隐式转换的规则是什么呢？为什么<code>num2='10000a'</code>、<code>'010000'</code>和<code>'10000'</code>这三种情形都能匹配上呢？查阅相关资料发现规则如下：</p>
<ol>
<li><strong>不以数字开头</strong>的字符串都将转换为<code>0</code>。如<code>'abc'</code>、<code>'a123bc'</code>、<code>'abc123'</code>都会转化为<code>0</code>；</li>
<li><strong>以数字开头的</strong>字符串转换时会进行截取，从第一个字符截取到第一个非数字内容为止。比如<code>'123abc'</code>会转换为<code>123</code>，<code>'012abc'</code>会转换为<code>012</code>也就是<code>12</code>，<code>'5.3a66b78c'</code>会转换为<code>5.3</code>，其他同理。</li>
</ol>
<p>现对以上规则做如下测试验证：</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/mysqlindex-invalidation-caused-by-implicit-conversion-04.png" alt=""></p>
<p>如此也就印证了之前的查询结果了。</p>
<p>再次写一条 SQL 查询 str1 字段：<code>SELECT * FROM</code>test1<code>WHERE str1 = 1234;</code></p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/mysqlindex-invalidation-caused-by-implicit-conversion-05.png" alt=""></p>
<h2> 分析和总结</h2>
<p>通过上面的测试我们发现 MySQL 使用操作符的一些特性：</p>
<ol>
<li>当操作符<strong>左右两边的数据类型不一致</strong>时，会发生<strong>隐式转换</strong>。</li>
<li>当 where 查询操作符<strong>左边为数值类型</strong>时发生了隐式转换，那么对效率影响不大，但还是不推荐这么做。</li>
<li>当 where 查询操作符<strong>左边为字符类型</strong>时发生了隐式转换，那么会导致索引失效，造成全表扫描效率极低。</li>
<li>字符串转换为数值类型时，非数字开头的字符串会转化为<code>0</code>，以数字开头的字符串会截取从第一个字符到第一个非数字内容为止的值为转化结果。</li>
</ol>
<p>所以，我们在写 SQL 时一定要养成良好的习惯，查询的字段是什么类型，等号右边的条件就写成对应的类型。特别当查询的字段是字符串时，等号右边的条件一定要用引号引起来标明这是一个字符串，否则会造成索引失效触发全表扫描。</p>
]]></content:encoded>
      <enclosure url="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/mysqlindex-invalidation-caused-by-implicit-conversion-01.png" type="image/png"/>
    </item>
    <item>
      <title>InnoDB存储引擎对MVCC的实现</title>
      <link>https://javaguide.cn/database/mysql/innodb-implementation-of-mvcc.html</link>
      <guid>https://javaguide.cn/database/mysql/innodb-implementation-of-mvcc.html</guid>
      <source url="https://javaguide.cn/rss.xml">InnoDB存储引擎对MVCC的实现</source>
      <description>一致性非锁定读和锁定读 一致性非锁定读 对于 一致性非锁定读（Consistent Nonlocking Reads） 的实现，通常做法是加一个版本号或者时间戳字段，在更新数据的同时版本号 + 1 或者更新时间戳。查询时，将当前可见的版本号与对应记录的版本号进行比对，如果记录的版本小于可见版本，则表示该记录可见</description>
      <category>数据库</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 一致性非锁定读和锁定读</h2>
<h3> 一致性非锁定读</h3>
<p>对于 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-consistent-read.html" target="_blank" rel="noopener noreferrer"><strong>一致性非锁定读（Consistent Nonlocking Reads）</strong> </a>的实现，通常做法是加一个版本号或者时间戳字段，在更新数据的同时版本号 + 1 或者更新时间戳。查询时，将当前可见的版本号与对应记录的版本号进行比对，如果记录的版本小于可见版本，则表示该记录可见</p>
<p>在 <code>InnoDB</code> 存储引擎中，<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-multi-versioning.html" target="_blank" rel="noopener noreferrer">多版本控制 (multi versioning)</a> 就是对非锁定读的实现。如果读取的行正在执行 <code>DELETE</code> 或 <code>UPDATE</code> 操作，这时读取操作不会去等待行上锁的释放。相反地，<code>InnoDB</code> 存储引擎会去读取行的一个快照数据，对于这种读取历史数据的方式，我们叫它快照读 (snapshot read)</p>
<p>在 <code>Repeatable Read</code> 和 <code>Read Committed</code> 两个隔离级别下，如果是执行普通的 <code>select</code> 语句（不包括 <code>select ... lock in share mode</code> ,<code>select ... for update</code>）则会使用 <code>一致性非锁定读（MVCC）</code>。并且在 <code>Repeatable Read</code> 下 <code>MVCC</code> 实现了可重复读和防止部分幻读</p>
<h3> 锁定读</h3>
<p>如果执行的是下列语句，就是 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locking-reads.html" target="_blank" rel="noopener noreferrer"><strong>锁定读（Locking Reads）</strong></a></p>
<ul>
<li><code>select ... lock in share mode</code></li>
<li><code>select ... for update</code></li>
<li><code>insert</code>、<code>update</code>、<code>delete</code> 操作</li>
</ul>
<p>在锁定读下，读取的是数据的最新版本，这种读也被称为 <code>当前读（current read）</code>。锁定读会对读取到的记录加锁：</p>
<ul>
<li>
<p><code>select ... lock in share mode</code>：对记录加 <code>S</code> 锁，其它事务也可以加<code>S</code>锁，如果加 <code>x</code> 锁则会被阻塞</p>
</li>
<li>
<p><code>select ... for update</code>、<code>insert</code>、<code>update</code>、<code>delete</code>：对记录加 <code>X</code> 锁，且其它事务不能加任何锁</p>
</li>
</ul>
<p>在一致性非锁定读下，即使读取的记录已被其它事务加上 <code>X</code> 锁，这时记录也是可以被读取的，即读取的快照数据。上面说了，在 <code>Repeatable Read</code> 下 <code>MVCC</code> 防止了部分幻读，这边的 “部分” 是指在 <code>一致性非锁定读</code> 情况下，只能读取到第一次查询之前所插入的数据（根据 Read View 判断数据可见性，Read View 在第一次查询时生成）。但是！如果是 <code>当前读</code> ，每次读取的都是最新数据，这时如果两次查询中间有其它事务插入数据，就会产生幻读。所以， <strong><code>InnoDB</code> 在实现<code>Repeatable Read</code> 时，如果执行的是当前读，则会对读取的记录使用 <code>Next-key Lock</code> ，来防止其它事务在间隙间插入数据</strong></p>
<h2> InnoDB 对 MVCC 的实现</h2>
<p><code>MVCC</code> 的实现依赖于：<strong>隐藏字段、Read View、undo log</strong>。在内部实现中，<code>InnoDB</code> 通过数据行的 <code>DB_TRX_ID</code> 和 <code>Read View</code> 来判断数据的可见性，如不可见，则通过数据行的 <code>DB_ROLL_PTR</code> 找到 <code>undo log</code> 中的历史版本。每个事务读到的数据版本可能是不一样的，在同一个事务中，用户只能看到该事务创建 <code>Read View</code> 之前已经提交的修改和该事务本身做的修改</p>
<h3> 隐藏字段</h3>
<p>在内部，<code>InnoDB</code> 存储引擎为每行数据添加了三个 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-multi-versioning.html" target="_blank" rel="noopener noreferrer">隐藏字段</a>：</p>
<ul>
<li><code>DB_TRX_ID（6字节）</code>：表示最后一次插入或更新该行的事务 id。此外，<code>delete</code> 操作在内部被视为更新，只不过会在记录头 <code>Record header</code> 中的 <code>deleted_flag</code> 字段将其标记为已删除</li>
<li><code>DB_ROLL_PTR（7字节）</code> 回滚指针，指向该行的 <code>undo log</code> 。如果该行未被更新，则为空</li>
<li><code>DB_ROW_ID（6字节）</code>：如果没有设置主键且该表没有唯一非空索引时，<code>InnoDB</code> 会使用该 id 来生成聚簇索引</li>
</ul>
<h3> ReadView</h3>
<div class="language-c line-numbers-mode" data-ext="c"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><a href="https://github.com/facebook/mysql-8.0/blob/8.0/storage/innobase/include/read0types.h#L298" target="_blank" rel="noopener noreferrer"><code>Read View</code></a> 主要是用来做可见性判断，里面保存了 “当前对本事务不可见的其他活跃事务”</p>
<p>主要有以下字段：</p>
<ul>
<li><code>m_low_limit_id</code>：目前出现过的最大的事务 ID+1，即下一个将被分配的事务 ID。大于等于这个 ID 的数据版本均不可见</li>
<li><code>m_up_limit_id</code>：活跃事务列表 <code>m_ids</code> 中最小的事务 ID，如果 <code>m_ids</code> 为空，则 <code>m_up_limit_id</code> 为 <code>m_low_limit_id</code>。小于这个 ID 的数据版本均可见</li>
<li><code>m_ids</code>：<code>Read View</code> 创建时其他未提交的活跃事务 ID 列表。创建 <code>Read View</code>时，将当前未提交事务 ID 记录下来，后续即使它们修改了记录行的值，对于当前事务也是不可见的。<code>m_ids</code> 不包括当前事务自己和已提交的事务（正在内存中）</li>
<li><code>m_creator_trx_id</code>：创建该 <code>Read View</code> 的事务 ID</li>
</ul>
<p><strong>事务可见性示意图</strong>（<a href="https://leviathan.vip/2019/03/20/InnoDB%E7%9A%84%E4%BA%8B%E5%8A%A1%E5%88%86%E6%9E%90-MVCC/#MVCC-1" target="_blank" rel="noopener noreferrer">图源</a>）：</p>
<p></p>
<h3> undo-log</h3>
<p><code>undo log</code> 主要有两个作用：</p>
<ul>
<li>当事务回滚时用于将数据恢复到修改前的样子</li>
<li>另一个作用是 <code>MVCC</code> ，当读取记录时，若该记录被其他事务占用或当前版本对该事务不可见，则可以通过 <code>undo log</code> 读取之前的版本数据，以此实现非锁定读</li>
</ul>
<p><strong>在 <code>InnoDB</code> 存储引擎中 <code>undo log</code> 分为两种： <code>insert undo log</code> 和 <code>update undo log</code>：</strong></p>
<ol>
<li><strong><code>insert undo log</code></strong> ：指在 <code>insert</code> 操作中产生的 <code>undo log</code>。因为 <code>insert</code> 操作的记录只对事务本身可见，对其他事务不可见，故该 <code>undo log</code> 可以在事务提交后直接删除。不需要进行 <code>purge</code> 操作</li>
</ol>
<p><strong><code>insert</code> 时的数据初始状态：</strong></p>
<p></p>
<ol start="2">
<li><strong><code>update undo log</code></strong> ：<code>update</code> 或 <code>delete</code> 操作中产生的 <code>undo log</code>。该 <code>undo log</code>可能需要提供 <code>MVCC</code> 机制，因此不能在事务提交时就进行删除。提交时放入 <code>undo log</code> 链表，等待 <code>purge线程</code> 进行最后的删除</li>
</ol>
<p><strong>数据第一次被修改时：</strong></p>
<p></p>
<p><strong>数据第二次被修改时：</strong></p>
<p></p>
<p>不同事务或者相同事务的对同一记录行的修改，会使该记录行的 <code>undo log</code> 成为一条链表，链首就是最新的记录，链尾就是最早的旧记录。</p>
<h3> 数据可见性算法</h3>
<p>在 <code>InnoDB</code> 存储引擎中，创建一个新事务后，执行每个 <code>select</code> 语句前，都会创建一个快照（Read View），<strong>快照中保存了当前数据库系统中正处于活跃（没有 commit）的事务的 ID 号</strong>。其实简单的说保存的是系统中当前不应该被本事务看到的其他事务 ID 列表（即 m_ids）。当用户在这个事务中要读取某个记录行的时候，<code>InnoDB</code> 会将该记录行的 <code>DB_TRX_ID</code> 与 <code>Read View</code> 中的一些变量及当前事务 ID 进行比较，判断是否满足可见性条件</p>
<p><a href="https://github.com/facebook/mysql-8.0/blob/8.0/storage/innobase/include/read0types.h#L161" target="_blank" rel="noopener noreferrer">具体的比较算法</a>如下(<a href="https://leviathan.vip/2019/03/20/InnoDB%E7%9A%84%E4%BA%8B%E5%8A%A1%E5%88%86%E6%9E%90-MVCC/#MVCC-1" target="_blank" rel="noopener noreferrer">图源</a>)：</p>
<p></p>
<ol>
<li>
<p>如果记录 DB_TRX_ID &lt; m_up_limit_id，那么表明最新修改该行的事务（DB_TRX_ID）在当前事务创建快照之前就提交了，所以该记录行的值对当前事务是可见的</p>
</li>
<li>
<p>如果 DB_TRX_ID &gt;= m_low_limit_id，那么表明最新修改该行的事务（DB_TRX_ID）在当前事务创建快照之后才修改该行，所以该记录行的值对当前事务不可见。跳到步骤 5</p>
</li>
<li>
<p>m_ids 为空，则表明在当前事务创建快照之前，修改该行的事务就已经提交了，所以该记录行的值对当前事务是可见的</p>
</li>
<li>
<p>如果 m_up_limit_id &lt;= DB_TRX_ID &lt; m_low_limit_id，表明最新修改该行的事务（DB_TRX_ID）在当前事务创建快照的时候可能处于“活动状态”或者“已提交状态”；所以就要对活跃事务列表 m_ids 进行查找（源码中是用的二分查找，因为是有序的）</p>
<ul>
<li>
<p>如果在活跃事务列表 m_ids 中能找到 DB_TRX_ID，表明：① 在当前事务创建快照前，该记录行的值被事务 ID 为 DB_TRX_ID 的事务修改了，但没有提交；或者 ② 在当前事务创建快照后，该记录行的值被事务 ID 为 DB_TRX_ID 的事务修改了。这些情况下，这个记录行的值对当前事务都是不可见的。跳到步骤 5</p>
</li>
<li>
<p>在活跃事务列表中找不到，则表明“id 为 trx_id 的事务”在修改“该记录行的值”后，在“当前事务”创建快照前就已经提交了，所以记录行对当前事务可见</p>
</li>
</ul>
</li>
<li>
<p>在该记录行的 DB_ROLL_PTR 指针所指向的 <code>undo log</code> 取出快照记录，用快照记录的 DB_TRX_ID 跳到步骤 1 重新开始判断，直到找到满足的快照版本或返回空</p>
</li>
</ol>
<h2> RC 和 RR 隔离级别下 MVCC 的差异</h2>
<p>在事务隔离级别 <code>RC</code> 和 <code>RR</code> （InnoDB 存储引擎的默认事务隔离级别）下，<code>InnoDB</code> 存储引擎使用 <code>MVCC</code>（非锁定一致性读），但它们生成 <code>Read View</code> 的时机却不同</p>
<ul>
<li>在 RC 隔离级别下的 <strong><code>每次select</code></strong> 查询前都生成一个<code>Read View</code> (m_ids 列表)</li>
<li>在 RR 隔离级别下只在事务开始后 <strong><code>第一次select</code></strong> 数据前生成一个<code>Read View</code>（m_ids 列表）</li>
</ul>
<h2> MVCC 解决不可重复读问题</h2>
<p>虽然 RC 和 RR 都通过 <code>MVCC</code> 来读取快照数据，但由于 <strong>生成 Read View 时机不同</strong>，从而在 RR 级别下实现可重复读</p>
<p>举个例子：</p>
<p></p>
<h3> 在 RC 下 ReadView 生成情况</h3>
<p><strong>1. 假设时间线来到 T4 ，那么此时数据行 id = 1 的版本链为：</strong></p>
<p></p>
<p>由于 RC 级别下每次查询都会生成<code>Read View</code> ，并且事务 101、102 并未提交，此时 <code>103</code> 事务生成的 <code>Read View</code> 中活跃的事务 <strong><code>m_ids</code> 为：[101,102]</strong> ，<code>m_low_limit_id</code>为：104，<code>m_up_limit_id</code>为：101，<code>m_creator_trx_id</code> 为：103</p>
<ul>
<li>此时最新记录的 <code>DB_TRX_ID</code> 为 101，m_up_limit_id &lt;= 101 &lt; m_low_limit_id，所以要在 <code>m_ids</code> 列表中查找，发现 <code>DB_TRX_ID</code> 存在列表中，那么这个记录不可见</li>
<li>根据 <code>DB_ROLL_PTR</code> 找到 <code>undo log</code> 中的上一版本记录，上一条记录的 <code>DB_TRX_ID</code> 还是 101，不可见</li>
<li>继续找上一条 <code>DB_TRX_ID</code>为 1，满足 1 &lt; m_up_limit_id，可见，所以事务 103 查询到数据为 <code>name = 菜花</code></li>
</ul>
<p><strong>2. 时间线来到 T6 ，数据的版本链为：</strong></p>
<p></p>
<p>因为在 RC 级别下，重新生成 <code>Read View</code>，这时事务 101 已经提交，102 并未提交，所以此时 <code>Read View</code> 中活跃的事务 <strong><code>m_ids</code>：[102]</strong> ，<code>m_low_limit_id</code>为：104，<code>m_up_limit_id</code>为：102，<code>m_creator_trx_id</code>为：103</p>
<ul>
<li>
<p>此时最新记录的 <code>DB_TRX_ID</code> 为 102，m_up_limit_id &lt;= 102 &lt; m_low_limit_id，所以要在 <code>m_ids</code> 列表中查找，发现 <code>DB_TRX_ID</code> 存在列表中，那么这个记录不可见</p>
</li>
<li>
<p>根据 <code>DB_ROLL_PTR</code> 找到 <code>undo log</code> 中的上一版本记录，上一条记录的 <code>DB_TRX_ID</code> 为 101，满足 101 &lt; m_up_limit_id，记录可见，所以在 <code>T6</code> 时间点查询到数据为 <code>name = 李四</code>，与时间 T4 查询到的结果不一致，不可重复读！</p>
</li>
</ul>
<p><strong>3. 时间线来到 T9 ，数据的版本链为：</strong></p>
<p></p>
<p>重新生成 <code>Read View</code>， 这时事务 101 和 102 都已经提交，所以 <strong>m_ids</strong> 为空，则 m_up_limit_id = m_low_limit_id = 104，最新版本事务 ID 为 102，满足 102 &lt; m_low_limit_id，可见，查询结果为 <code>name = 赵六</code></p>
<blockquote>
<p><strong>总结：</strong> <strong>在 RC 隔离级别下，事务在每次查询开始时都会生成并设置新的 Read View，所以导致不可重复读</strong></p>
</blockquote>
<h3> 在 RR 下 ReadView 生成情况</h3>
<p>在可重复读级别下，只会在事务开始后第一次读取数据时生成一个 Read View（m_ids 列表）</p>
<p><strong>1. 在 T4 情况下的版本链为：</strong></p>
<p></p>
<p>在当前执行 <code>select</code> 语句时生成一个 <code>Read View</code>，此时 <strong><code>m_ids</code>：[101,102]</strong> ，<code>m_low_limit_id</code>为：104，<code>m_up_limit_id</code>为：101，<code>m_creator_trx_id</code> 为：103</p>
<p>此时和 RC 级别下一样：</p>
<ul>
<li>最新记录的 <code>DB_TRX_ID</code> 为 101，m_up_limit_id &lt;= 101 &lt; m_low_limit_id，所以要在 <code>m_ids</code> 列表中查找，发现 <code>DB_TRX_ID</code> 存在列表中，那么这个记录不可见</li>
<li>根据 <code>DB_ROLL_PTR</code> 找到 <code>undo log</code> 中的上一版本记录，上一条记录的 <code>DB_TRX_ID</code> 还是 101，不可见</li>
<li>继续找上一条 <code>DB_TRX_ID</code>为 1，满足 1 &lt; m_up_limit_id，可见，所以事务 103 查询到数据为 <code>name = 菜花</code></li>
</ul>
<p><strong>2. 时间点 T6 情况下：</strong></p>
<p></p>
<p>在 RR 级别下只会生成一次<code>Read View</code>，所以此时依然沿用 <strong><code>m_ids</code> ：[101,102]</strong> ，<code>m_low_limit_id</code>为：104，<code>m_up_limit_id</code>为：101，<code>m_creator_trx_id</code> 为：103</p>
<ul>
<li>
<p>最新记录的 <code>DB_TRX_ID</code> 为 102，m_up_limit_id &lt;= 102 &lt; m_low_limit_id，所以要在 <code>m_ids</code> 列表中查找，发现 <code>DB_TRX_ID</code> 存在列表中，那么这个记录不可见</p>
</li>
<li>
<p>根据 <code>DB_ROLL_PTR</code> 找到 <code>undo log</code> 中的上一版本记录，上一条记录的 <code>DB_TRX_ID</code> 为 101，不可见</p>
</li>
<li>
<p>继续根据 <code>DB_ROLL_PTR</code> 找到 <code>undo log</code> 中的上一版本记录，上一条记录的 <code>DB_TRX_ID</code> 还是 101，不可见</p>
</li>
<li>
<p>继续找上一条 <code>DB_TRX_ID</code>为 1，满足 1 &lt; m_up_limit_id，可见，所以事务 103 查询到数据为 <code>name = 菜花</code></p>
</li>
</ul>
<p><strong>3. 时间点 T9 情况下：</strong></p>
<p></p>
<p>此时情况跟 T6 完全一样，由于已经生成了 <code>Read View</code>，此时依然沿用 <strong><code>m_ids</code> ：[101,102]</strong> ，所以查询结果依然是 <code>name = 菜花</code></p>
<h2> MVCC➕Next-key-Lock 防止幻读</h2>
<p><code>InnoDB</code>存储引擎在 RR 级别下通过 <code>MVCC</code>和 <code>Next-key Lock</code> 来解决幻读问题：</p>
<p><strong>1、执行普通 <code>select</code>，此时会以 <code>MVCC</code> 快照读的方式读取数据</strong></p>
<p>在快照读的情况下，RR 隔离级别只会在事务开启后的第一次查询生成 <code>Read View</code> ，并使用至事务提交。所以在生成 <code>Read View</code> 之后其它事务所做的更新、插入记录版本对当前事务并不可见，实现了可重复读和防止快照读下的 “幻读”</p>
<p><strong>2、执行 select...for update/lock in share mode、insert、update、delete 等当前读</strong></p>
<p>在当前读下，读取的都是最新的数据，如果其它事务有插入新的记录，并且刚好在当前事务查询范围内，就会产生幻读！<code>InnoDB</code> 使用 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html#innodb-next-key-locks" target="_blank" rel="noopener noreferrer">Next-key Lock</a> 来防止这种情况。当执行当前读时，会锁定读取到的记录的同时，锁定它们的间隙，防止其它事务在查询范围内插入数据。只要我不让你插入，就不会发生幻读</p>
<h2> 参考</h2>
<ul>
<li><strong>《MySQL 技术内幕 InnoDB 存储引擎第 2 版》</strong></li>
<li><a href="https://tech.meituan.com/2014/08/20/innodb-lock.html" target="_blank" rel="noopener noreferrer">Innodb 中的事务隔离级别和锁的关系</a></li>
<li><a href="https://blog.csdn.net/qq_35190492/article/details/109044141" target="_blank" rel="noopener noreferrer">MySQL 事务与 MVCC 如何实现的隔离级别</a></li>
<li><a href="https://leviathan.vip/2019/03/20/InnoDB%E7%9A%84%E4%BA%8B%E5%8A%A1%E5%88%86%E6%9E%90-MVCC/" target="_blank" rel="noopener noreferrer">InnoDB 事务分析-MVCC</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>MySQL高性能优化规范建议总结</title>
      <link>https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html</link>
      <guid>https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html</guid>
      <source url="https://javaguide.cn/rss.xml">MySQL高性能优化规范建议总结</source>
      <description>作者: 听风 原文地址: https://www.cnblogs.com/huchong/p/10219318.html。 JavaGuide 已获得作者授权，并对原文内容进行了完善。 数据库命名规范 所有数据库对象名称必须使用小写字母并用下划线分割 所有数据库对象名称禁止使用 MySQL 保留关键字（如果表名中包含关键字查询时，需要将其用单引号括起来） 数据库对象的命名要能做到见名识意，并且最后不要超过 32 个字符 临时库表必须以 tmp_ 为前缀并以日期为后缀，备份表必须以 bak_ 为前缀并以日期 (时间戳) 为后缀 所有存储相同数据的列名和列类型必须一致（一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低）</description>
      <category>数据库</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>作者: 听风 原文地址: <a href="https://www.cnblogs.com/huchong/p/10219318.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/huchong/p/10219318.html</a>。</p>
<p>JavaGuide 已获得作者授权，并对原文内容进行了完善。</p>
</blockquote>
<h2> 数据库命名规范</h2>
<ul>
<li>所有数据库对象名称必须使用小写字母并用下划线分割</li>
<li>所有数据库对象名称禁止使用 MySQL 保留关键字（如果表名中包含关键字查询时，需要将其用单引号括起来）</li>
<li>数据库对象的命名要能做到见名识意，并且最后不要超过 32 个字符</li>
<li>临时库表必须以 <code>tmp_</code> 为前缀并以日期为后缀，备份表必须以 <code>bak_</code> 为前缀并以日期 (时间戳) 为后缀</li>
<li>所有存储相同数据的列名和列类型必须一致（一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低）</li>
</ul>
<h2> 数据库基本设计规范</h2>
<h3> 所有表必须使用 InnoDB 存储引擎</h3>
<p>没有特殊要求（即 InnoDB 无法满足的功能如：列存储，存储空间数据等）的情况下，所有表必须使用 InnoDB 存储引擎（MySQL5.5 之前默认使用 Myisam，5.6 以后默认的为 InnoDB）。</p>
<p>InnoDB 支持事务，支持行级锁，更好的恢复性，高并发下性能更好。</p>
<h3> 数据库和表的字符集统一使用 UTF8</h3>
<p>兼容性更好，统一字符集可以避免由于字符集转换产生的乱码，不同的字符集进行比较前需要进行转换会造成索引失效，如果数据库中有存储 emoji 表情的需要，字符集需要采用 utf8mb4 字符集。</p>
<p>参考文章：</p>
<ul>
<li><a href="https://blog.csdn.net/horses/article/details/107243447" target="_blank" rel="noopener noreferrer">MySQL 字符集不一致导致索引失效的一个真实案例</a></li>
<li><a href="https://javaguide.cn/database/character-set.html" target="_blank" rel="noopener noreferrer">MySQL 字符集详解</a></li>
</ul>
<h3> 所有表和字段都需要添加注释</h3>
<p>使用 comment 从句添加表和列的备注，从一开始就进行数据字典的维护</p>
<h3> 尽量控制单表数据量的大小，建议控制在 500 万以内</h3>
<p>500 万并不是 MySQL 数据库的限制，过大会造成修改表结构，备份，恢复都会有很大的问题。</p>
<p>可以用历史数据归档（应用于日志数据），分库分表（应用于业务数据）等手段来控制数据量大小</p>
<h3> 谨慎使用 MySQL 分区表</h3>
<p>分区表在物理上表现为多个文件，在逻辑上表现为一个表；</p>
<p>谨慎选择分区键，跨分区查询效率可能更低；</p>
<p>建议采用物理分表的方式管理大数据。</p>
<h3> 经常一起使用的列放到一个表中</h3>
<p>避免更多的关联操作。</p>
<h3> 禁止在表中建立预留字段</h3>
<ul>
<li>预留字段的命名很难做到见名识义。</li>
<li>预留字段无法确认存储的数据类型，所以无法选择合适的类型。</li>
<li>对预留字段类型的修改，会对表进行锁定。</li>
</ul>
<h3> 禁止在数据库中存储文件（比如图片）这类大的二进制数据</h3>
<p>在数据库中存储文件会严重影响数据库性能，消耗过多存储空间。</p>
<p>文件（比如图片）这类大的二进制数据通常存储于文件服务器，数据库只存储文件地址信息。</p>
<h3> 不要被数据库范式所束缚</h3>
<p>一般来说，设计关系数据库时需要满足第三范式，但为了满足第三范式，我们可能会拆分出多张表。而在进行查询时需要对多张表进行关联查询，有时为了提高查询效率，会降低范式的要求，在表中保存一定的冗余信息，也叫做反范式。但要注意反范式一定要适度。</p>
<h3> 禁止在线上做数据库压力测试</h3>
<h3> 禁止从开发环境,测试环境直接连接生产环境数据库</h3>
<p>安全隐患极大，要对生产环境抱有敬畏之心！</p>
<h2> 数据库字段设计规范</h2>
<h3> 优先选择符合存储需要的最小的数据类型</h3>
<p>存储字节越小，占用也就空间越小，性能也越好。</p>
<p><strong>a.某些字符串可以转换成数字类型存储比如可以将 IP 地址转换成整型数据。</strong></p>
<p>数字是连续的，性能更好，占用空间也更小。</p>
<p>MySQL 提供了两个方法来处理 ip 地址</p>
<ul>
<li><code>INET_ATON()</code> ： 把 ip 转为无符号整型 (4-8 位)</li>
<li><code>INET_NTOA()</code> :把整型的 ip 转为地址</li>
</ul>
<p>插入数据前，先用 <code>INET_ATON()</code> 把 ip 地址转为整型，显示数据时，使用 <code>INET_NTOA()</code> 把整型的 ip 地址转为地址显示即可。</p>
<p><strong>b.对于非负型的数据 (如自增 ID,整型 IP，年龄) 来说,要优先使用无符号整型来存储。</strong></p>
<p>无符号相对于有符号可以多出一倍的存储空间</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>c.小数值类型（比如年龄、状态表示如 0/1）优先使用 TINYINT 类型。</strong></p>
<h3> 避免使用 TEXT,BLOB 数据类型，最常见的 TEXT 类型可以存储 64k 的数据</h3>
<p><strong>a. 建议把 BLOB 或是 TEXT 列分离到单独的扩展表中。</strong></p>
<p>MySQL 内存临时表不支持 TEXT、BLOB 这样的大数据类型，如果查询中包含这样的数据，在排序等操作时，就不能使用内存临时表，必须使用磁盘临时表进行。而且对于这种数据，MySQL 还是要进行二次查询，会使 sql 性能变得很差，但是不是说一定不能使用这样的数据类型。</p>
<p>如果一定要使用，建议把 BLOB 或是 TEXT 列分离到单独的扩展表中，查询时一定不要使用 <code>select *</code>而只需要取出必要的列，不需要 TEXT 列的数据时不要对该列进行查询。</p>
<p><strong>2、TEXT 或 BLOB 类型只能使用前缀索引</strong></p>
<p>因为 MySQL 对索引字段长度是有限制的，所以 TEXT 类型只能使用前缀索引，并且 TEXT 列上是不能有默认值的</p>
<h3> 避免使用 ENUM 类型</h3>
<ul>
<li>修改 ENUM 值需要使用 ALTER 语句；</li>
<li>ENUM 类型的 ORDER BY 操作效率低，需要额外操作；</li>
<li>ENUM 数据类型存在一些限制比如建议不要使用数值作为 ENUM 的枚举值。</li>
</ul>
<p>相关阅读：<a href="https://www.zhihu.com/question/404422255/answer/1661698499" target="_blank" rel="noopener noreferrer">是否推荐使用 MySQL 的 enum 类型？ - 架构文摘 - 知乎</a> 。</p>
<h3> 尽可能把所有列定义为 NOT NULL</h3>
<p>除非有特别的原因使用 NULL 值，应该总是让字段保持 NOT NULL。</p>
<ul>
<li>索引 NULL 列需要额外的空间来保存，所以要占用更多的空间；</li>
<li>进行比较和计算时要对 NULL 值做特别的处理。</li>
</ul>
<p>相关阅读：<a href="https://opensource.actionsky.com/20190710-mysql/" target="_blank" rel="noopener noreferrer">技术分享 | MySQL 默认值选型（是空，还是 NULL）</a> 。</p>
<h3> 使用 TIMESTAMP(4 个字节) 或 DATETIME 类型 (8 个字节) 存储时间</h3>
<p>TIMESTAMP 存储的时间范围 1970-01-01 00:00:01 ~ 2038-01-19-03:14:07</p>
<p>TIMESTAMP 占用 4 字节和 INT 相同，但比 INT 可读性高</p>
<p>超出 TIMESTAMP 取值范围的使用 DATETIME 类型存储</p>
<p><strong>经常会有人用字符串存储日期型的数据（不正确的做法）</strong></p>
<ul>
<li>缺点 1：无法用日期函数进行计算和比较</li>
<li>缺点 2：用字符串存储日期要占用更多的空间</li>
</ul>
<h3> 同财务相关的金额类数据必须使用 decimal 类型</h3>
<ul>
<li><strong>非精准浮点</strong> ：float,double</li>
<li><strong>精准浮点</strong> ：decimal</li>
</ul>
<p>decimal 类型为精准浮点数，在计算时不会丢失精度。占用空间由定义的宽度决定，每 4 个字节可以存储 9 位数字，并且小数点要占用一个字节。并且，decimal 可用于存储比 bigint 更大的整型数据</p>
<p>不过， 由于 decimal 需要额外的空间和计算开销，应该尽量只在需要对数据进行精确计算时才使用 decimal 。</p>
<h3> 单表不要包含过多字段</h3>
<p>如果一个表包含过多字段的话，可以考虑将其分解成多个表，必要时增加中间表进行关联。</p>
<h2> 索引设计规范</h2>
<h3> 限制每张表上的索引数量,建议单张表索引不超过 5 个</h3>
<p>索引并不是越多越好！索引可以提高效率同样可以降低效率。</p>
<p>索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率。</p>
<p>因为 MySQL 优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，就会增加 MySQL 优化器生成执行计划的时间，同样会降低查询性能。</p>
<h3> 禁止使用全文索引</h3>
<p>全文索引不适用于 OLTP 场景。</p>
<h3> 禁止给表中的每一列都建立单独的索引</h3>
<p>5.6 版本之前，一个 sql 只能使用到一个表中的一个索引，5.6 以后，虽然有了合并索引的优化方式，但是还是远远没有使用一个联合索引的查询方式好。</p>
<h3> 每个 InnoDB 表必须有个主键</h3>
<p>InnoDB 是一种索引组织表：数据的存储的逻辑顺序和索引的顺序是相同的。每个表都可以有多个索引，但是表的存储顺序只能有一种。</p>
<p>InnoDB 是按照主键索引的顺序来组织表的</p>
<ul>
<li>不要使用更新频繁的列作为主键，不适用多列主键（相当于联合索引）</li>
<li>不要使用 UUID,MD5,HASH,字符串列作为主键（无法保证数据的顺序增长）</li>
<li>主键建议使用自增 ID 值</li>
</ul>
<h3> 常见索引列建议</h3>
<ul>
<li>出现在 SELECT、UPDATE、DELETE 语句的 WHERE 从句中的列</li>
<li>包含在 ORDER BY、GROUP BY、DISTINCT 中的字段</li>
<li>并不要将符合 1 和 2 中的字段的列都建立一个索引， 通常将 1、2 中的字段建立联合索引效果更好</li>
<li>多表 join 的关联列</li>
</ul>
<h3> 如何选择索引列的顺序</h3>
<p>建立索引的目的是：希望通过索引进行数据查找，减少随机 IO，增加查询性能 ，索引能过滤出越少的数据，则从磁盘中读入的数据也就越少。</p>
<ul>
<li>区分度最高的放在联合索引的最左侧（区分度=列中不同值的数量/列的总行数）</li>
<li>尽量把字段长度小的列放在联合索引的最左侧（因为字段长度越小，一页能存储的数据量越大，IO 性能也就越好）</li>
<li>使用最频繁的列放到联合索引的左侧（这样可以比较少的建立一些索引）</li>
</ul>
<h3> 避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）</h3>
<ul>
<li>重复索引示例：primary key(id)、index(id)、unique index(id)</li>
<li>冗余索引示例：index(a,b,c)、index(a,b)、index(a)</li>
</ul>
<h3> 对于频繁的查询优先考虑使用覆盖索引</h3>
<blockquote>
<p>覆盖索引：就是包含了所有查询字段 (where,select,order by,group by 包含的字段) 的索引</p>
</blockquote>
<p><strong>覆盖索引的好处：</strong></p>
<ul>
<li><strong>避免 InnoDB 表进行索引的二次查询:</strong> InnoDB 是以聚集索引的顺序来存储的，对于 InnoDB 来说，二级索引在叶子节点中所保存的是行的主键信息，如果是用二级索引查询数据的话，在查找到相应的键值后，还要通过主键进行二次查询才能获取我们真实所需要的数据。而在覆盖索引中，二级索引的键值中可以获取所有的数据，避免了对主键的二次查询 ，减少了 IO 操作，提升了查询效率。</li>
<li><strong>可以把随机 IO 变成顺序 IO 加快查询效率:</strong> 由于覆盖索引是按键值的顺序存储的，对于 IO 密集型的范围查找来说，对比随机从磁盘读取每一行的数据 IO 要少的多，因此利用覆盖索引在访问时也可以把磁盘的随机读取的 IO 转变成索引查找的顺序 IO。</li>
</ul>
<hr>
<h3> 索引 SET 规范</h3>
<p><strong>尽量避免使用外键约束</strong></p>
<ul>
<li>不建议使用外键约束（foreign key），但一定要在表与表之间的关联键上建立索引</li>
<li>外键可用于保证数据的参照完整性，但建议在业务端实现</li>
<li>外键会影响父表和子表的写操作从而降低性能</li>
</ul>
<h2> 数据库 SQL 开发规范</h2>
<h3> 优化对性能影响较大的 SQL 语句</h3>
<p>要找到最需要优化的 SQL 语句。要么是使用最频繁的语句，要么是优化后提高最明显的语句，可以通过查询 MySQL 的慢查询日志来发现需要进行优化的 SQL 语句；</p>
<h3> 充分利用表上已经存在的索引</h3>
<p>避免使用双%号的查询条件。如：<code>a like '%123%'</code>，（如果无前置%,只有后置%，是可以用到列上的索引的）</p>
<p>一个 SQL 只能利用到复合索引中的一列进行范围查询。如：有 a,b,c 列的联合索引，在查询条件中有 a 列的范围查询，则在 b,c 列上的索引将不会被用到。</p>
<p>在定义联合索引时，如果 a 列要用到范围查找的话，就要把 a 列放到联合索引的右侧，使用 left join 或 not exists 来优化 not in 操作，因为 not in 也通常会使用索引失效。</p>
<h3> 禁止使用 SELECT * 必须使用 SELECT &lt;字段列表&gt; 查询</h3>
<ul>
<li><code>SELECT *</code> 消耗更多的 CPU 和 IO 以网络带宽资源</li>
<li><code>SELECT *</code> 无法使用覆盖索引</li>
<li><code>SELECT &lt;字段列表&gt;</code> 可减少表结构变更带来的影响</li>
</ul>
<h3> 禁止使用不含字段列表的 INSERT 语句</h3>
<p>如：</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>应使用：</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 建议使用预编译语句进行数据库操作</h3>
<ul>
<li>预编译语句可以重复使用这些计划，减少 SQL 编译所需要的时间，还可以解决动态 SQL 所带来的 SQL 注入的问题。</li>
<li>只传参数，比传递 SQL 语句更高效。</li>
<li>相同语句可以一次解析，多次使用，提高处理效率。</li>
</ul>
<h3> 避免数据类型的隐式转换</h3>
<p>隐式转换会导致索引失效如:</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>详细解读可以看：<a href="/database/mysql/index-invalidation-caused-by-implicit-conversion.html" target="blank">MySQL 中的隐式转换造成的索引失效</a> 这篇文章。</p>
<h3> 避免使用子查询，可以把子查询优化为 join 操作</h3>
<p>通常子查询在 in 子句中，且子查询中为简单 SQL(不包含 union、group by、order by、limit 从句) 时,才可以把子查询转化为关联查询进行优化。</p>
<p><strong>子查询性能差的原因：</strong> 子查询的结果集无法使用索引，通常子查询的结果集会被存储到临时表中，不论是内存临时表还是磁盘临时表都不会存在索引，所以查询性能会受到一定的影响。特别是对于返回结果集比较大的子查询，其对查询性能的影响也就越大。由于子查询会产生大量的临时表也没有索引，所以会消耗过多的 CPU 和 IO 资源，产生大量的慢查询。</p>
<h3> 避免使用 JOIN 关联太多的表</h3>
<p>对于 MySQL 来说，是存在关联缓存的，缓存的大小可以由 join_buffer_size 参数进行设置。</p>
<p>在 MySQL 中，对于同一个 SQL 多关联（join）一个表，就会多分配一个关联缓存，如果在一个 SQL 中关联的表越多，所占用的内存也就越大。</p>
<p>如果程序中大量的使用了多表关联的操作，同时 join_buffer_size 设置的也不合理的情况下，就容易造成服务器内存溢出的情况，就会影响到服务器数据库性能的稳定性。</p>
<p>同时对于关联操作来说，会产生临时表操作，影响查询效率，MySQL 最多允许关联 61 个表，建议不超过 5 个。</p>
<h3> 减少同数据库的交互次数</h3>
<p>数据库更适合处理批量操作，合并多个相同的操作到一起，可以提高处理效率。</p>
<h3> 对应同一列进行 or 判断时，使用 in 代替 or</h3>
<p>in 的值不要超过 500 个，in 操作可以更有效的利用索引，or 大多数情况下很少能利用到索引。</p>
<h3> 禁止使用 order by rand() 进行随机排序</h3>
<p>order by rand() 会把表中所有符合条件的数据装载到内存中，然后在内存中对所有数据根据随机生成的值进行排序，并且可能会对每一行都生成一个随机值，如果满足条件的数据集非常大，就会消耗大量的 CPU 和 IO 及内存资源。</p>
<p>推荐在程序中获取一个随机值，然后从数据库中获取数据的方式。</p>
<h3> WHERE 从句中禁止对列进行函数转换和计算</h3>
<p>对列进行函数转换或计算时会导致无法使用索引</p>
<p><strong>不推荐：</strong></p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>推荐：</strong></p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3> 在明显不会有重复值时使用 UNION ALL 而不是 UNION</h3>
<ul>
<li>UNION 会把两个结果集的所有数据放到临时表中后再进行去重操作</li>
<li>UNION ALL 不会再对结果集进行去重操作</li>
</ul>
<h3> 拆分复杂的大 SQL 为多个小 SQL</h3>
<ul>
<li>大 SQL 逻辑上比较复杂，需要占用大量 CPU 进行计算的 SQL</li>
<li>MySQL 中，一个 SQL 只能使用一个 CPU 进行计算</li>
<li>SQL 拆分后可以通过并行执行来提高处理效率</li>
</ul>
<h3> 程序连接不同的数据库使用不同的账号，禁止跨库查询</h3>
<ul>
<li>为数据库迁移和分库分表留出余地</li>
<li>降低业务耦合度</li>
<li>避免权限过大而产生的安全风险</li>
</ul>
<h2> 数据库操作行为规范</h2>
<h3> 超 100 万行的批量写 (UPDATE,DELETE,INSERT) 操作,要分批多次进行操作</h3>
<p><strong>大批量操作可能会造成严重的主从延迟</strong></p>
<p>主从环境中,大批量操作可能会造成严重的主从延迟，大批量的写操作一般都需要执行一定长的时间，而只有当主库上执行完成后，才会在其他从库上执行，所以会造成主库与从库长时间的延迟情况</p>
<p><strong>binlog 日志为 row 格式时会产生大量的日志</strong></p>
<p>大批量写操作会产生大量日志，特别是对于 row 格式二进制数据而言，由于在 row 格式中会记录每一行数据的修改，我们一次修改的数据越多，产生的日志量也就会越多，日志的传输和恢复所需要的时间也就越长，这也是造成主从延迟的一个原因</p>
<p><strong>避免产生大事务操作</strong></p>
<p>大批量修改数据，一定是在一个事务中进行的，这就会造成表中大批量数据进行锁定，从而导致大量的阻塞，阻塞会对 MySQL 的性能产生非常大的影响。</p>
<p>特别是长时间的阻塞会占满所有数据库的可用连接，这会使生产环境中的其他应用无法连接到数据库，因此一定要注意大批量写操作要进行分批</p>
<h3> 对于大表使用 pt-online-schema-change 修改表结构</h3>
<ul>
<li>避免大表修改产生的主从延迟</li>
<li>避免在对表字段进行修改时进行锁表</li>
</ul>
<p>对大表数据结构的修改一定要谨慎，会造成严重的锁表操作，尤其是生产环境，是不能容忍的。</p>
<p>pt-online-schema-change 它会首先建立一个与原表结构相同的新表，并且在新表上进行表结构的修改，然后再把原表中的数据复制到新表中，并在原表中增加一些触发器。把原表中新增的数据也复制到新表中，在行所有数据复制完成之后，把新表命名成原表，并把原来的表删除掉。把原来一个 DDL 操作，分解成多个小的批次进行。</p>
<h3> 禁止为程序使用的账号赋予 super 权限</h3>
<ul>
<li>当达到最大连接数限制时，还运行 1 个有 super 权限的用户连接</li>
<li>super 权限只能留给 DBA 处理问题的账号使用</li>
</ul>
<h3> 对于程序连接数据库账号,遵循权限最小原则</h3>
<ul>
<li>程序使用数据库账号只能在一个 DB 下使用，不准跨库</li>
<li>程序使用的账号原则上不准有 drop 权限</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>MySQL索引详解</title>
      <link>https://javaguide.cn/database/mysql/mysql-index.html</link>
      <guid>https://javaguide.cn/database/mysql/mysql-index.html</guid>
      <source url="https://javaguide.cn/rss.xml">MySQL索引详解</source>
      <description>感谢WT-AHA对本文的完善，相关 PR：https://github.com/Snailclimb/JavaGuide/pull/1648 。 但凡经历过几场面试的小伙伴，应该都清楚，数据库索引这个知识点在面试中出现的频率高到离谱。 除了对于准备面试来说非常重要之外，善用索引对 SQL 的性能提升非常明显，是一个性价比较高的 SQL 优化手段。</description>
      <category>数据库</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>感谢<a href="https://github.com/WT-AHA" target="_blank" rel="noopener noreferrer">WT-AHA</a>对本文的完善，相关 PR：https://github.com/Snailclimb/JavaGuide/pull/1648 。</p>
</blockquote>
<p>但凡经历过几场面试的小伙伴，应该都清楚，数据库索引这个知识点在面试中出现的频率高到离谱。</p>
<p>除了对于准备面试来说非常重要之外，善用索引对 SQL 的性能提升非常明显，是一个性价比较高的 SQL 优化手段。</p>
<h2> 索引介绍</h2>
<p><strong>索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。</strong></p>
<p>索引的作用就相当于书的目录。打个比方: 我们在查字典的时候，如果没有目录，那我们就只能一页一页的去找我们需要查的那个字，速度很慢。如果有目录了，我们只需要先去目录里查找字的位置，然后直接翻到那一页就行了。</p>
<p>索引底层数据结构存在很多种类型，常见的索引结构有: B 树， B+树 和 Hash、红黑树。在 MySQL 中，无论是 Innodb 还是 MyIsam，都使用了 B+树作为索引结构。</p>
<h2> 索引的优缺点</h2>
<p><strong>优点</strong> ：</p>
<ul>
<li>使用索引可以大大加快 数据的检索速度（大大减少检索的数据量）, 这也是创建索引的最主要的原因。</li>
<li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li>
</ul>
<p><strong>缺点</strong> ：</p>
<ul>
<li>创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。</li>
<li>索引需要使用物理文件存储，也会耗费一定空间。</li>
</ul>
<p>但是，<strong>使用索引一定能提高查询性能吗?</strong></p>
<p>大多数情况下，索引查询都是比全表扫描要快的。但是如果数据库的数据量不大，那么使用索引也不一定能够带来很大提升。</p>
<h2> 索引的底层数据结构</h2>
<h3> Hash 表</h3>
<p>哈希表是键值对的集合，通过键(key)即可快速取出对应的值(value)，因此哈希表可以快速检索数据（接近 O（1））。</p>
<p><strong>为何能够通过 key 快速取出 value 呢？</strong> 原因在于 <strong>哈希算法</strong>（也叫散列算法）。通过哈希算法，我们可以快速找到 key 对应的 index，找到了 index 也就找到了对应的 value。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://img-blog.csdnimg.cn/20210513092328171.png" alt=""></p>
<p>但是！哈希算法有个 <strong>Hash 冲突</strong> 问题，也就是说多个不同的 key 最后得到的 index 相同。通常情况下，我们常用的解决办法是 <strong>链地址法</strong>。链地址法就是将哈希冲突数据存放在链表中。就比如 JDK1.8 之前 <code>HashMap</code> 就是通过链地址法来解决哈希冲突的。不过，JDK1.8 以后<code>HashMap</code>为了减少链表过长的时候搜索时间过长引入了红黑树。</p>
<p><img src="https://img-blog.csdnimg.cn/20210513092224836.png" alt=""></p>
<p>为了减少 Hash 冲突的发生，一个好的哈希函数应该“均匀地”将数据分布在整个可能的哈希值集合中。</p>
<p>既然哈希表这么快，<strong>为什么 MySQL 没有使用其作为索引的数据结构呢？</strong> 主要是因为 Hash 索引不支持顺序和范围查询。假如我们要对表中的数据进行排序或者进行范围查询，那 Hash 索引可就不行了。并且，每次 IO 只能取一个。</p>
<p>试想一种情况:</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在这种范围查询中，优势非常大，直接遍历比 500 小的叶子节点就够了。而 Hash 索引是根据 hash 算法来定位的，难不成还要把 1 - 499 的数据，每个都进行一次 hash 计算来定位吗?这就是 Hash 最大的缺点了。</p>
<h3> B 树&amp; B+树</h3>
<p>B 树也称 B-树,全称为 <strong>多路平衡查找树</strong> ，B+ 树是 B 树的一种变体。B 树和 B+树中的 B 是 <code>Balanced</code> （平衡）的意思。</p>
<p>目前大部分数据库系统及文件系统都采用 B-Tree 或其变种 B+Tree 作为索引结构。</p>
<p><strong>B 树&amp; B+树两者有何异同呢？</strong></p>
<ul>
<li>B 树的所有节点既存放键(key) 也存放 数据(data)，而 B+树只有叶子节点存放 key 和 data，其他内节点只存放 key。</li>
<li>B 树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点。</li>
<li>B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。</li>
</ul>
<p>在 MySQL 中，MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是，两者的实现方式不太一样。（下面的内容整理自《Java 工程师修炼之道》）</p>
<blockquote>
<p>MyISAM 引擎中，B+Tree 叶节点的 data 域存放的是数据记录的地址。在索引检索的时候，首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“<strong>非聚簇索引（非聚集索引）</strong>”。</p>
<p>InnoDB 引擎中，其数据文件本身就是索引文件。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。这个索引的 key 是数据表的主键，因此 InnoDB 表数据文件本身就是主索引。这被称为“<strong>聚簇索引（聚集索引）</strong>”，而其余的索引都作为 <strong>辅助索引</strong> ，辅助索引的 data 域存储相应记录主键的值而不是地址，这也是和 MyISAM 不同的地方。在根据主索引搜索时，直接找到 key 所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。</p>
</blockquote>
<h2> 索引类型</h2>
<h3> 主键索引(Primary Key)</h3>
<p>数据表的主键列使用的就是主键索引。</p>
<p>一张数据表有只能有一个主键，并且主键不能为 null，不能重复。</p>
<p>在 MySQL 的 InnoDB 的表中，当没有显示的指定表的主键时，InnoDB 会自动先检查表中是否有唯一索引且不允许存在 null 值的字段，如果有，则选择该字段为默认的主键，否则 InnoDB 将会自动创建一个 6Byte 的自增主键。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/open-source-project/cluster-index.png" alt=""></p>
<h3> 二级索引(辅助索引)</h3>
<p><strong>二级索引又称为辅助索引，是因为二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置。</strong></p>
<p>唯一索引，普通索引，前缀索引等索引属于二级索引。</p>
<p>PS: 不懂的同学可以暂存疑，慢慢往下看，后面会有答案的，也可以自行搜索。</p>
<ol>
<li><strong>唯一索引(Unique Key)</strong> ：唯一索引也是一种约束。<strong>唯一索引的属性列不能出现重复的数据，但是允许数据为 NULL，一张表允许创建多个唯一索引。</strong> 建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。</li>
<li><strong>普通索引(Index)</strong> ：<strong>普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 NULL。</strong></li>
<li><strong>前缀索引(Prefix)</strong> ：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小，
因为只取前几个字符。</li>
<li><strong>全文索引(Full Text)</strong> ：全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。Mysql5.6 之前只有 MYISAM 引擎支持全文索引，5.6 之后 InnoDB 也支持了全文索引。</li>
</ol>
<p>二级索引:</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/open-source-project/no-cluster-index.png" alt=""></p>
<h2> 聚簇索引与非聚簇索引</h2>
<h3> 聚簇索引（聚集索引）</h3>
<h4> 聚簇索引介绍</h4>
<p><strong>聚簇索引即索引结构和数据一起存放的索引，并不是一种单独的索引类型。InnoDB 中的主键索引就属于聚簇索引。</strong></p>
<p>在 MySQL 中，InnoDB 引擎的表的 <code>.ibd</code>文件就包含了该表的索引和数据，对于 InnoDB 引擎表来说，该表的索引(B+树)的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。</p>
<h4> 聚簇索引的优缺点</h4>
<p><strong>优点</strong> ：</p>
<ul>
<li><strong>查询速度非常快</strong> ：聚簇索引的查询速度非常的快，因为整个 B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。相比于非聚簇索引， 聚簇索引少了一次读取数据的 IO 操作。</li>
<li><strong>对排序查找和范围查找优化</strong> ：聚簇索引对于主键的排序查找和范围查找速度非常快。</li>
</ul>
<p><strong>缺点</strong> ：</p>
<ul>
<li><strong>依赖于有序的数据</strong> ：因为 B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，插入或查找的速度肯定比较慢。</li>
<li><strong>更新代价大</strong> ： 如果对索引列的数据被修改时，那么对应的索引也将会被修改，而且聚簇索引的叶子节点还存放着数据，修改代价肯定是较大的，所以对于主键索引来说，主键一般都是不可被修改的。</li>
</ul>
<h3> 非聚簇索引（非聚集索引）</h3>
<h4> 非聚簇索引介绍</h4>
<p><strong>非聚簇索引即索引结构和数据分开存放的索引，并不是一种单独的索引类型。二级索引(辅助索引)就属于非聚簇索引。MySQL 的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引</strong></p>
<p>非聚簇索引的叶子节点并不一定存放数据的指针，因为二级索引的叶子节点就存放的是主键，根据主键再回表查数据。</p>
<h4> 非聚簇索引的优缺点</h4>
<p><strong>优点</strong> ：</p>
<p>更新代价比聚簇索引要小 。非聚簇索引的更新代价就没有聚簇索引那么大了，非聚簇索引的叶子节点是不存放数据的</p>
<p><strong>缺点</strong> ：</p>
<ul>
<li><strong>依赖于有序的数据</strong> ：跟聚簇索引一样，非聚簇索引也依赖于有序的数据</li>
<li><strong>可能会二次查询(回表)</strong> ：这应该是非聚簇索引最大的缺点了。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。</li>
</ul>
<p>这是 MySQL 的表的文件截图:</p>
<p><img src="https://img-blog.csdnimg.cn/20210420165311654.png" alt=""></p>
<p>聚簇索引和非聚簇索引:</p>
<p><img src="https://img-blog.csdnimg.cn/20210420165326946.png" alt=""></p>
<h4> 非聚簇索引一定回表查询吗(覆盖索引)?</h4>
<p><strong>非聚簇索引不一定回表查询。</strong></p>
<p>试想一种情况，用户准备使用 SQL 查询用户名，而用户名字段正好建立了索引。</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>那么这个索引的 key 本身就是 name，查到对应的 name 直接返回就行了，无需回表查询。</p>
<p>即使是 MYISAM 也是这样，虽然 MYISAM 的主键索引确实需要回表，因为它的主键索引的叶子节点存放的是指针。但是！<strong>如果 SQL 查的就是主键呢?</strong></p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>主键索引本身的 key 就是主键，查到返回就行了。这种情况就称之为覆盖索引了。</p>
<h2> 覆盖索引和联合索引</h2>
<h3> 覆盖索引</h3>
<p>如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”。我们知道在 InnoDB 存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一次。这样就会比较慢覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！</p>
<p><strong>覆盖索引即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了，而无需回表查询。</strong></p>
<blockquote>
<p>如主键索引，如果一条 SQL 需要查询主键，那么正好根据主键索引就可以查到主键。</p>
<p>再如普通索引，如果一条 SQL 需要查询 name，name 字段正好有索引，
那么直接根据这个索引就可以查到数据，也无需回表。</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20210420165341868.png" alt="覆盖索引"></p>
<h3> 联合索引</h3>
<p>使用表中的多个字段创建索引，就是 <strong>联合索引</strong>，也叫 <strong>组合索引</strong> 或 <strong>复合索引</strong>。</p>
<h3> 最左前缀匹配原则</h3>
<p>最左前缀匹配原则指的是，在使用联合索引时，<strong>MySQL</strong> 会根据联合索引中的字段顺序，从左到右依次到查询条件中去匹配，如果查询条件中存在与联合索引中最左侧字段相匹配的字段，则就会使用该字段过滤一批数据，直至联合索引中全部字段匹配完成，或者在执行过程中遇到范围查询，如 <strong><code>&gt;</code></strong>、<strong><code>&lt;</code></strong>、<strong><code>between</code></strong> 和 <strong><code>以%开头的like查询</code></strong> 等条件，才会停止匹配。</p>
<p>所以，我们在使用联合索引时，可以将区分度高的字段放在最左边，这也可以过滤更多数据。</p>
<h2> 索引下推</h2>
<p><strong>索引下推（Index Condition Pushdown）</strong> 是 <strong>MySQL 5.6</strong> 版本中提供的一项索引优化功能，可以在非聚簇索引遍历过程中，对索引中包含的字段先做判断，过滤掉不符合条件的记录，减少回表次数。</p>
<h2> 正确使用索引的一些建议</h2>
<h3> 选择合适的字段创建索引</h3>
<ul>
<li><strong>不为 NULL 的字段</strong> ：索引字段的数据应该尽量不为 NULL，因为对于数据为 NULL 的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为 NULL，建议使用 0,1,true,false 这样语义较为清晰的短值或短字符作为替代。</li>
<li><strong>被频繁查询的字段</strong> ：我们创建索引的字段应该是查询操作非常频繁的字段。</li>
<li><strong>被作为条件查询的字段</strong> ：被作为 WHERE 条件查询的字段，应该被考虑建立索引。</li>
<li><strong>频繁需要排序的字段</strong> ：索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。</li>
<li><strong>被经常频繁用于连接的字段</strong> ：经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率。</li>
</ul>
<h3> 被频繁更新的字段应该慎重建立索引</h3>
<p>虽然索引能带来查询上的效率，但是维护索引的成本也是不小的。 如果一个字段不被经常查询，反而被经常修改，那么就更不应该在这种字段上建立索引了。</p>
<h3> 尽可能的考虑建立联合索引而不是单列索引</h3>
<p>因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗 B+树。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的。如果是联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升。</p>
<h3> 注意避免冗余索引</h3>
<p>冗余索引指的是索引的功能相同，能够命中索引(a, b)就肯定能命中索引(a) ，那么索引(a)就是冗余索引。如（name,city ）和（name ）这两个索引就是冗余索引，能够命中前者的查询肯定是能够命中后者的 在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。</p>
<h3> 考虑在字符串类型的字段上使用前缀索引代替普通索引</h3>
<p>前缀索引仅限于字符串类型，较普通索引会占用更小的空间，所以可以考虑使用前缀索引带替普通索引。</p>
<h3> 避免索引失效</h3>
<p>索引失效也是慢查询的主要原因之一，常见的导致索引失效的情况有下面这些：</p>
<ul>
<li>使用 <code>SELECT *</code> 进行查询;</li>
<li>创建了组合索引，但查询条件未准守最左匹配原则;</li>
<li>在索引列上进行计算、函数、类型转换等操作;</li>
<li>以 % 开头的 LIKE 查询比如 <code>like '%abc';</code>;</li>
<li>查询条件中使用 or，且 or 的前后条件中有一个列没有索引，涉及的索引都不会被使用到;</li>
<li>发生<a href="https://javaguide.cn/database/mysql/index-invalidation-caused-by-implicit-conversion.html" target="_blank" rel="noopener noreferrer">隐式转换</a>;</li>
<li>......</li>
</ul>
<h3> 删除长期未使用的索引</h3>
<p>删除长期未使用的索引，不用的索引的存在会造成不必要的性能损耗 MySQL 5.7 可以通过查询 sys 库的 schema_unused_indexes 视图来查询哪些索引从未被使用</p>
]]></content:encoded>
      <enclosure url="https://img-blog.csdnimg.cn/20210513092328171.png" type="image/png"/>
    </item>
    <item>
      <title>MySQL三大日志(binlog、redo log和undo log)详解</title>
      <link>https://javaguide.cn/database/mysql/mysql-logs.html</link>
      <guid>https://javaguide.cn/database/mysql/mysql-logs.html</guid>
      <source url="https://javaguide.cn/rss.xml">MySQL三大日志(binlog、redo log和undo log)详解</source>
      <description>本文来自公号程序猿阿星投稿，JavaGuide 对其做了补充完善。 前言 MySQL 日志 主要包括错误日志、查询日志、慢查询日志、事务日志、二进制日志几大类。其中，比较重要的还要属二进制日志 binlog（归档日志）和事务日志 redo log（重做日志）和 undo log（回滚日志）。</description>
      <category>数据库</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>本文来自公号程序猿阿星投稿，JavaGuide 对其做了补充完善。</p>
</blockquote>
<h2> 前言</h2>
<p><code>MySQL</code> 日志 主要包括错误日志、查询日志、慢查询日志、事务日志、二进制日志几大类。其中，比较重要的还要属二进制日志 <code>binlog</code>（归档日志）和事务日志 <code>redo log</code>（重做日志）和 <code>undo log</code>（回滚日志）。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/01.png" alt=""></p>
<p>今天就来聊聊 <code>redo log</code>（重做日志）、<code>binlog</code>（归档日志）、两阶段提交、<code>undo log</code> （回滚日志）。</p>
<h2> redo log</h2>
<p><code>redo log</code>（重做日志）是<code>InnoDB</code>存储引擎独有的，它让<code>MySQL</code>拥有了崩溃恢复能力。</p>
<p>比如 <code>MySQL</code> 实例挂了或宕机了，重启时，<code>InnoDB</code>存储引擎会使用<code>redo log</code>恢复数据，保证数据的持久性与完整性。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/02.png" alt=""></p>
<p><code>MySQL</code> 中数据是以页为单位，你查询一条记录，会从硬盘把一页的数据加载出来，加载出来的数据叫数据页，会放入到 <code>Buffer Pool</code> 中。</p>
<p>后续的查询都是先从 <code>Buffer Pool</code> 中找，没有命中再去硬盘加载，减少硬盘 <code>IO</code> 开销，提升性能。</p>
<p>更新表数据的时候，也是如此，发现 <code>Buffer Pool</code> 里存在要更新的数据，就直接在 <code>Buffer Pool</code> 里更新。</p>
<p>然后会把“在某个数据页上做了什么修改”记录到重做日志缓存（<code>redo log buffer</code>）里，接着刷盘到 <code>redo log</code> 文件里。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/03.png" alt=""></p>
<blockquote>
<p>图片笔误提示：第 4 步 “清空 redo log buffe 刷盘到 redo 日志中”这句话中的 buffe 应该是 buffer。</p>
</blockquote>
<p>理想情况，事务一提交就会进行刷盘操作，但实际上，刷盘的时机是根据策略来进行的。</p>
<blockquote>
<p>小贴士：每条 redo 记录由“表空间号+数据页号+偏移量+修改数据长度+具体修改的数据”组成</p>
</blockquote>
<h3> 刷盘时机</h3>
<p><code>InnoDB</code> 存储引擎为 <code>redo log</code> 的刷盘策略提供了 <code>innodb_flush_log_at_trx_commit</code> 参数，它支持三种策略：</p>
<ul>
<li><strong>0</strong> ：设置为 0 的时候，表示每次事务提交时不进行刷盘操作</li>
<li><strong>1</strong> ：设置为 1 的时候，表示每次事务提交时都将进行刷盘操作（默认值）</li>
<li><strong>2</strong> ：设置为 2 的时候，表示每次事务提交时都只把 redo log buffer 内容写入 page cache</li>
</ul>
<p><code>innodb_flush_log_at_trx_commit</code> 参数默认为 1 ，也就是说当事务提交时会调用 <code>fsync</code> 对 redo log 进行刷盘</p>
<p>另外，<code>InnoDB</code> 存储引擎有一个后台线程，每隔<code>1</code> 秒，就会把 <code>redo log buffer</code> 中的内容写到文件系统缓存（<code>page cache</code>），然后调用 <code>fsync</code> 刷盘。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/04.png" alt=""></p>
<p>也就是说，一个没有提交事务的 <code>redo log</code> 记录，也可能会刷盘。</p>
<p><strong>为什么呢？</strong></p>
<p>因为在事务执行过程 <code>redo log</code> 记录是会写入<code>redo log buffer</code> 中，这些 <code>redo log</code> 记录会被后台线程刷盘。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/05.png" alt=""></p>
<p>除了后台线程每秒<code>1</code>次的轮询操作，还有一种情况，当 <code>redo log buffer</code> 占用的空间即将达到 <code>innodb_log_buffer_size</code> 一半的时候，后台线程会主动刷盘。</p>
<p>下面是不同刷盘策略的流程图。</p>
<h4> innodb_flush_log_at_trx_commit=0</h4>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/06.png" alt=""></p>
<p>为<code>0</code>时，如果<code>MySQL</code>挂了或宕机可能会有<code>1</code>秒数据的丢失。</p>
<h4> innodb_flush_log_at_trx_commit=1</h4>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/07.png" alt=""></p>
<p>为<code>1</code>时， 只要事务提交成功，<code>redo log</code>记录就一定在硬盘里，不会有任何数据丢失。</p>
<p>如果事务执行期间<code>MySQL</code>挂了或宕机，这部分日志丢了，但是事务并没有提交，所以日志丢了也不会有损失。</p>
<h4> innodb_flush_log_at_trx_commit=2</h4>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/09.png" alt=""></p>
<p>为<code>2</code>时， 只要事务提交成功，<code>redo log buffer</code>中的内容只写入文件系统缓存（<code>page cache</code>）。</p>
<p>如果仅仅只是<code>MySQL</code>挂了不会有任何数据丢失，但是宕机可能会有<code>1</code>秒数据的丢失。</p>
<h3> 日志文件组</h3>
<p>硬盘上存储的 <code>redo log</code> 日志文件不只一个，而是以一个<strong>日志文件组</strong>的形式出现的，每个的<code>redo</code>日志文件大小都是一样的。</p>
<p>比如可以配置为一组<code>4</code>个文件，每个文件的大小是 <code>1GB</code>，整个 <code>redo log</code> 日志文件组可以记录<code>4G</code>的内容。</p>
<p>它采用的是环形数组形式，从头开始写，写到末尾又回到头循环写，如下图所示。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/10.png" alt=""></p>
<p>在个<strong>日志文件组</strong>中还有两个重要的属性，分别是 <code>write pos、checkpoint</code></p>
<ul>
<li><strong>write pos</strong> 是当前记录的位置，一边写一边后移</li>
<li><strong>checkpoint</strong> 是当前要擦除的位置，也是往后推移</li>
</ul>
<p>每次刷盘 <code>redo log</code> 记录到<strong>日志文件组</strong>中，<code>write pos</code> 位置就会后移更新。</p>
<p>每次 <code>MySQL</code> 加载<strong>日志文件组</strong>恢复数据时，会清空加载过的 <code>redo log</code> 记录，并把 <code>checkpoint</code> 后移更新。</p>
<p><code>write pos</code> 和 <code>checkpoint</code> 之间的还空着的部分可以用来写入新的 <code>redo log</code> 记录。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/11.png" alt=""></p>
<p>如果 <code>write pos</code> 追上 <code>checkpoint</code> ，表示<strong>日志文件组</strong>满了，这时候不能再写入新的 <code>redo log</code> 记录，<code>MySQL</code> 得停下来，清空一些记录，把 <code>checkpoint</code> 推进一下。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/12.png" alt=""></p>
<h3> redo log 小结</h3>
<p>相信大家都知道 <code>redo log</code> 的作用和它的刷盘时机、存储形式。</p>
<p>现在我们来思考一个问题： <strong>只要每次把修改后的数据页直接刷盘不就好了，还有 <code>redo log</code> 什么事？</strong></p>
<p>它们不都是刷盘么？差别在哪里？</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实际上，数据页大小是<code>16KB</code>，刷盘比较耗时，可能就修改了数据页里的几 <code>Byte</code> 数据，有必要把完整的数据页刷盘吗？</p>
<p>而且数据页刷盘是随机写，因为一个数据页对应的位置可能在硬盘文件的随机位置，所以性能是很差。</p>
<p>如果是写 <code>redo log</code>，一行记录可能就占几十 <code>Byte</code>，只包含表空间号、数据页号、磁盘文件偏移
量、更新值，再加上是顺序写，所以刷盘速度很快。</p>
<p>所以用 <code>redo log</code> 形式记录修改内容，性能会远远超过刷数据页的方式，这也让数据库的并发能力更强。</p>
<blockquote>
<p>其实内存的数据页在一定时机也会刷盘，我们把这称为页合并，讲 <code>Buffer Pool</code>的时候会对这块细说</p>
</blockquote>
<h2> binlog</h2>
<p><code>redo log</code> 它是物理日志，记录内容是“在某个数据页上做了什么修改”，属于 <code>InnoDB</code> 存储引擎。</p>
<p>而 <code>binlog</code> 是逻辑日志，记录内容是语句的原始逻辑，类似于“给 ID=2 这一行的 c 字段加 1”，属于<code>MySQL Server</code> 层。</p>
<p>不管用什么存储引擎，只要发生了表数据更新，都会产生 <code>binlog</code> 日志。</p>
<p>那 <code>binlog</code> 到底是用来干嘛的？</p>
<p>可以说<code>MySQL</code>数据库的<strong>数据备份、主备、主主、主从</strong>都离不开<code>binlog</code>，需要依靠<code>binlog</code>来同步数据，保证数据一致性。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/01-20220305234724956.png" alt=""></p>
<p><code>binlog</code>会记录所有涉及更新数据的逻辑操作，并且是顺序写。</p>
<h3> 记录格式</h3>
<p><code>binlog</code> 日志有三种格式，可以通过<code>binlog_format</code>参数指定。</p>
<ul>
<li><strong>statement</strong></li>
<li><strong>row</strong></li>
<li><strong>mixed</strong></li>
</ul>
<p>指定<code>statement</code>，记录的内容是<code>SQL</code>语句原文，比如执行一条<code>update T set update_time=now() where id=1</code>，记录的内容如下。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/02-20220305234738688.png" alt=""></p>
<p>同步数据时，会执行记录的<code>SQL</code>语句，但是有个问题，<code>update_time=now()</code>这里会获取当前系统时间，直接执行会导致与原库的数据不一致。</p>
<p>为了解决这种问题，我们需要指定为<code>row</code>，记录的内容不再是简单的<code>SQL</code>语句了，还包含操作的具体数据，记录内容如下。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/03-20220305234742460.png" alt=""></p>
<p><code>row</code>格式记录的内容看不到详细信息，要通过<code>mysqlbinlog</code>工具解析出来。</p>
<p><code>update_time=now()</code>变成了具体的时间<code>update_time=1627112756247</code>，条件后面的@1、@2、@3 都是该行数据第 1 个~3 个字段的原始值（<strong>假设这张表只有 3 个字段</strong>）。</p>
<p>这样就能保证同步数据的一致性，通常情况下都是指定为<code>row</code>，这样可以为数据库的恢复与同步带来更好的可靠性。</p>
<p>但是这种格式，需要更大的容量来记录，比较占用空间，恢复与同步时会更消耗<code>IO</code>资源，影响执行速度。</p>
<p>所以就有了一种折中的方案，指定为<code>mixed</code>，记录的内容是前两者的混合。</p>
<p><code>MySQL</code>会判断这条<code>SQL</code>语句是否可能引起数据不一致，如果是，就用<code>row</code>格式，否则就用<code>statement</code>格式。</p>
<h3> 写入机制</h3>
<p><code>binlog</code>的写入时机也非常简单，事务执行过程中，先把日志写到<code>binlog cache</code>，事务提交的时候，再把<code>binlog cache</code>写到<code>binlog</code>文件中。</p>
<p>因为一个事务的<code>binlog</code>不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会给每个线程分配一个块内存作为<code>binlog cache</code>。</p>
<p>我们可以通过<code>binlog_cache_size</code>参数控制单个线程 binlog cache 大小，如果存储内容超过了这个参数，就要暂存到磁盘（<code>Swap</code>）。</p>
<p><code>binlog</code>日志刷盘流程如下</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/04-20220305234747840.png" alt=""></p>
<ul>
<li><strong>上图的 write，是指把日志写入到文件系统的 page cache，并没有把数据持久化到磁盘，所以速度比较快</strong></li>
<li><strong>上图的 fsync，才是将数据持久化到磁盘的操作</strong></li>
</ul>
<p><code>write</code>和<code>fsync</code>的时机，可以由参数<code>sync_binlog</code>控制，默认是<code>0</code>。</p>
<p>为<code>0</code>的时候，表示每次提交事务都只<code>write</code>，由系统自行判断什么时候执行<code>fsync</code>。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/05-20220305234754405.png" alt=""></p>
<p>虽然性能得到提升，但是机器宕机，<code>page cache</code>里面的 binlog 会丢失。</p>
<p>为了安全起见，可以设置为<code>1</code>，表示每次提交事务都会执行<code>fsync</code>，就如同 <strong>redo log 日志刷盘流程</strong> 一样。</p>
<p>最后还有一种折中方式，可以设置为<code>N(N&gt;1)</code>，表示每次提交事务都<code>write</code>，但累积<code>N</code>个事务后才<code>fsync</code>。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/06-20220305234801592.png" alt=""></p>
<p>在出现<code>IO</code>瓶颈的场景里，将<code>sync_binlog</code>设置成一个比较大的值，可以提升性能。</p>
<p>同样的，如果机器宕机，会丢失最近<code>N</code>个事务的<code>binlog</code>日志。</p>
<h2> 两阶段提交</h2>
<p><code>redo log</code>（重做日志）让<code>InnoDB</code>存储引擎拥有了崩溃恢复能力。</p>
<p><code>binlog</code>（归档日志）保证了<code>MySQL</code>集群架构的数据一致性。</p>
<p>虽然它们都属于持久化的保证，但是侧重点不同。</p>
<p>在执行更新语句过程，会记录<code>redo log</code>与<code>binlog</code>两块日志，以基本的事务为单位，<code>redo log</code>在事务执行过程中可以不断写入，而<code>binlog</code>只有在提交事务时才写入，所以<code>redo log</code>与<code>binlog</code>的写入时机不一样。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/01-20220305234816065.png" alt=""></p>
<p>回到正题，<code>redo log</code>与<code>binlog</code>两份日志之间的逻辑不一致，会出现什么问题？</p>
<p>我们以<code>update</code>语句为例，假设<code>id=2</code>的记录，字段<code>c</code>值是<code>0</code>，把字段<code>c</code>值更新成<code>1</code>，<code>SQL</code>语句为<code>update T set c=1 where id=2</code>。</p>
<p>假设执行过程中写完<code>redo log</code>日志后，<code>binlog</code>日志写期间发生了异常，会出现什么情况呢？</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/02-20220305234828662.png" alt=""></p>
<p>由于<code>binlog</code>没写完就异常，这时候<code>binlog</code>里面没有对应的修改记录。因此，之后用<code>binlog</code>日志恢复数据时，就会少这一次更新，恢复出来的这一行<code>c</code>值是<code>0</code>，而原库因为<code>redo log</code>日志恢复，这一行<code>c</code>值是<code>1</code>，最终数据不一致。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/03-20220305235104445.png" alt=""></p>
<p>为了解决两份日志之间的逻辑一致问题，<code>InnoDB</code>存储引擎使用<strong>两阶段提交</strong>方案。</p>
<p>原理很简单，将<code>redo log</code>的写入拆成了两个步骤<code>prepare</code>和<code>commit</code>，这就是<strong>两阶段提交</strong>。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/04-20220305234956774.png" alt=""></p>
<p>使用<strong>两阶段提交</strong>后，写入<code>binlog</code>时发生异常也不会有影响，因为<code>MySQL</code>根据<code>redo log</code>日志恢复数据时，发现<code>redo log</code>还处于<code>prepare</code>阶段，并且没有对应<code>binlog</code>日志，就会回滚该事务。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/05-20220305234937243.png" alt=""></p>
<p>再看一个场景，<code>redo log</code>设置<code>commit</code>阶段发生异常，那会不会回滚事务呢？</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/06-20220305234907651.png" alt=""></p>
<p>并不会回滚事务，它会执行上图框住的逻辑，虽然<code>redo log</code>是处于<code>prepare</code>阶段，但是能通过事务<code>id</code>找到对应的<code>binlog</code>日志，所以<code>MySQL</code>认为是完整的，就会提交事务恢复数据。</p>
<h2> undo log</h2>
<blockquote>
<p>这部分内容为 JavaGuide 的补充：</p>
</blockquote>
<p>我们知道如果想要保证事务的原子性，就需要在异常发生时，对已经执行的操作进行<strong>回滚</strong>，在 MySQL 中，恢复机制是通过 <strong>回滚日志（undo log）</strong> 实现的，所有事务进行的修改都会先记录到这个回滚日志中，然后再执行相关的操作。如果执行过程中遇到异常的话，我们直接利用 <strong>回滚日志</strong> 中的信息将数据回滚到修改之前的样子即可！并且，回滚日志会先于数据持久化到磁盘上。这样就保证了即使遇到数据库突然宕机等情况，当用户再次启动数据库的时候，数据库还能够通过查询回滚日志来回滚将之前未完成的事务。</p>
<p>另外，<code>MVCC</code> 的实现依赖于：<strong>隐藏字段、Read View、undo log</strong>。在内部实现中，<code>InnoDB</code> 通过数据行的 <code>DB_TRX_ID</code> 和 <code>Read View</code> 来判断数据的可见性，如不可见，则通过数据行的 <code>DB_ROLL_PTR</code> 找到 <code>undo log</code> 中的历史版本。每个事务读到的数据版本可能是不一样的，在同一个事务中，用户只能看到该事务创建 <code>Read View</code> 之前已经提交的修改和该事务本身做的修改</p>
<h2> 总结</h2>
<blockquote>
<p>这部分内容为 JavaGuide 的补充：</p>
</blockquote>
<p>MySQL InnoDB 引擎使用 <strong>redo log(重做日志)</strong> 保证事务的<strong>持久性</strong>，使用 <strong>undo log(回滚日志)</strong> 来保证事务的<strong>原子性</strong>。</p>
<p><code>MySQL</code>数据库的<strong>数据备份、主备、主主、主从</strong>都离不开<code>binlog</code>，需要依靠<code>binlog</code>来同步数据，保证数据一致性。</p>
<h2> 站在巨人的肩膀上</h2>
<ul>
<li>《MySQL 实战 45 讲》</li>
<li>《从零开始带你成为 MySQL 实战优化高手》</li>
<li>《MySQL 是怎样运行的：从根儿上理解 MySQL》</li>
<li>《MySQL 技术 Innodb 存储引擎》</li>
</ul>
<h2> MySQL 好文推荐</h2>
<ul>
<li><a href="https://mp.weixin.qq.com/s/R-1km7r0z3oWfwYQV8iiqA" target="_blank" rel="noopener noreferrer">CURD 这么多年，你有了解过 MySQL 的架构设计吗？</a></li>
<li><a href="https://mp.weixin.qq.com/s/7Kab4IQsNcU_bZdbv_MuOg" target="_blank" rel="noopener noreferrer">浅谈 MySQL InnoDB 的内存组件</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/01.png" type="image/png"/>
    </item>
    <item>
      <title>MySQL常见面试题总结</title>
      <link>https://javaguide.cn/database/mysql/mysql-questions-01.html</link>
      <guid>https://javaguide.cn/database/mysql/mysql-questions-01.html</guid>
      <source url="https://javaguide.cn/rss.xml">MySQL常见面试题总结</source>
      <description>MySQL 基础 关系型数据库介绍 顾名思义，关系型数据库就是一种建立在关系模型的基础上的数据库。关系模型表明了数据库中所存储的数据之间的联系（一对一、一对多、多对多）。 关系型数据库中，我们的数据都被存放在了各种表中（比如用户表），表中的每一行就存放着一条数据（比如一个用户的信息）。</description>
      <category>数据库</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<h2> MySQL 基础</h2>
<h3> 关系型数据库介绍</h3>
<p>顾名思义，关系型数据库就是一种建立在关系模型的基础上的数据库。关系模型表明了数据库中所存储的数据之间的联系（一对一、一对多、多对多）。</p>
<p>关系型数据库中，我们的数据都被存放在了各种表中（比如用户表），表中的每一行就存放着一条数据（比如一个用户的信息）。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/java-guide-blog/5e3c1a71724a38245aa43b02_99bf70d46cc247be878de9d3a88f0c44.png" alt="关系型数据库表关系"></p>
<p>大部分关系型数据库都使用 SQL 来操作数据库中的数据。并且，大部分关系型数据库都支持事务的四大特性(ACID)。</p>
<p><strong>有哪些常见的关系型数据库呢？</strong></p>
<p>MySQL、PostgreSQL、Oracle、SQL Server、SQLite（微信本地的聊天记录的存储就是用的 SQLite） ......。</p>
<h3> MySQL 介绍</h3>
<p><img src="https://img-blog.csdnimg.cn/20210327143351823.png" alt=""></p>
<p><strong>MySQL 是一种关系型数据库，主要用于持久化存储我们的系统中的一些数据比如用户信息。</strong></p>
<p>由于 MySQL 是开源免费并且比较成熟的数据库，因此，MySQL 被大量使用在各种系统中。任何人都可以在 GPL(General Public License) 的许可下下载并根据个性化的需要对其进行修改。MySQL 的默认端口号是<strong>3306</strong>。</p>
<h2> MySQL 基础架构</h2>
<blockquote>
<p>建议配合 <a href="/database/mysql/how-sql-executed-in-mysql.html" target="blank">SQL 语句在 MySQL 中的执行过程</a> 这篇文章来理解 MySQL 基础架构。另外，“一个 SQL 语句在 MySQL 中的执行流程”也是面试中比较常问的一个问题。</p>
</blockquote>
<p>下图是 MySQL 的一个简要架构图，从下图你可以很清晰的看到客户端的一条 SQL 语句在 MySQL 内部是如何执行的。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/13526879-3037b144ed09eb88.png" alt=""></p>
<p>从上图可以看出， MySQL 主要由下面几部分构成：</p>
<ul>
<li><strong>连接器：</strong> 身份认证和权限相关(登录 MySQL 的时候)。</li>
<li><strong>查询缓存：</strong> 执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。</li>
<li><strong>分析器：</strong> 没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。</li>
<li><strong>优化器：</strong> 按照 MySQL 认为最优的方案去执行。</li>
<li><strong>执行器：</strong> 执行语句，然后从存储引擎返回数据。 执行语句之前会先判断是否有权限，如果没有权限的话，就会报错。</li>
<li><strong>插件式存储引擎</strong> ： 主要负责数据的存储和读取，采用的是插件式架构，支持 InnoDB、MyISAM、Memory 等多种存储引擎。</li>
</ul>
<h2> MySQL 存储引擎</h2>
<p>MySQL 核心在于存储引擎，想要深入学习 MySQL，必定要深入研究 MySQL 存储引擎。</p>
<h3> MySQL 支持哪些存储引擎？默认使用哪个？</h3>
<p>MySQL 支持多种存储引擎，你可以通过 <code>show engines</code> 命令来查看 MySQL 支持的所有存储引擎。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/mysql/image-20220510105408703.png" alt="查看 MySQL 提供的所有存储引擎"></p>
<p>从上图我们可以查看出， MySQL 当前默认的存储引擎是 InnoDB。并且，所有的存储引擎中只有 InnoDB 是事务性存储引擎，也就是说只有 InnoDB 支持事务。</p>
<p>我这里使用的 MySQL 版本是 8.x，不同的 MySQL 版本之间可能会有差别。</p>
<p>MySQL 5.5.5 之前，MyISAM 是 MySQL 的默认存储引擎。5.5.5 版本之后，InnoDB 是 MySQL 的默认存储引擎。</p>
<p>你可以通过 <code>select version()</code> 命令查看你的 MySQL 版本。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>你也可以通过 <code>show variables like '%storage_engine%'</code> 命令直接查看 MySQL 当前默认的存储引擎。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/mysql/image-20220510105837786.png" alt="查看 MySQL 当前默认的存储引擎"></p>
<p>如果你只想查看数据库中某个表使用的存储引擎的话，可以使用 <code>show table status from db_name where name='table_name'</code>命令。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/mysql/image-20220510110549140.png" alt="查看表的存储引擎"></p>
<p>如果你想要深入了解每个存储引擎以及它们之间的区别，推荐你去阅读以下 MySQL 官方文档对应的介绍(面试不会问这么细，了解即可)：</p>
<ul>
<li>InnoDB 存储引擎详细介绍：https://dev.mysql.com/doc/refman/8.0/en/innodb-storage-engine.html 。</li>
<li>其他存储引擎详细介绍：https://dev.mysql.com/doc/refman/8.0/en/storage-engines.html 。</li>
</ul>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/mysql/image-20220510155143458.png" alt=""></p>
<h3> MySQL 存储引擎架构了解吗？</h3>
<p>MySQL 存储引擎采用的是插件式架构，支持多种存储引擎，我们甚至可以为不同的数据库表设置不同的存储引擎以适应不同场景的需要。<strong>存储引擎是基于表的，而不是数据库。</strong></p>
<p>并且，你还可以根据 MySQL 定义的存储引擎实现标准接口来编写一个属于自己的存储引擎。这些非官方提供的存储引擎可以称为第三方存储引擎，区别于官方存储引擎。像目前最常用的 InnoDB 其实刚开始就是一个第三方存储引擎，后面由于过于优秀，其被 Oracle 直接收购了。</p>
<p>MySQL 官方文档也有介绍到如何编写一个自定义存储引擎，地址：https://dev.mysql.com/doc/internals/en/custom-engine.html 。</p>
<h3> MyISAM 和 InnoDB 的区别是什么？</h3>
<p><img src="https://img-blog.csdnimg.cn/20210327145248960.png" alt=""></p>
<p>MySQL 5.5 之前，MyISAM 引擎是 MySQL 的默认存储引擎，可谓是风光一时。</p>
<p>虽然，MyISAM 的性能还行，各种特性也还不错（比如全文索引、压缩、空间函数等）。但是，MyISAM 不支持事务和行级锁，而且最大的缺陷就是崩溃后无法安全恢复。</p>
<p>MySQL 5.5.5 之前，MyISAM 是 MySQL 的默认存储引擎。5.5.5 版本之后，InnoDB 是 MySQL 的默认存储引擎。</p>
<p>言归正传！咱们下面还是来简单对比一下两者：</p>
<p><strong>1.是否支持行级锁</strong></p>
<p>MyISAM 只有表级锁(table-level locking)，而 InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。</p>
<p>也就说，MyISAM 一锁就是锁住了整张表，这在并发写的情况下是多么滴憨憨啊！这也是为什么 InnoDB 在并发写的时候，性能更牛皮了！</p>
<p><strong>2.是否支持事务</strong></p>
<p>MyISAM 不提供事务支持。</p>
<p>InnoDB 提供事务支持，实现了 SQL 标准定义了四个隔离级别，具有提交(commit)和回滚(rollback)事务的能力。并且，InnoDB 默认使用的 REPEATABLE-READ（可重读）隔离级别是可以解决幻读问题发生的（基于 MVCC 和 Next-Key Lock）。</p>
<p>关于 MySQL 事务的详细介绍，可以看看我写的这篇文章：<a href="https://javaguide.cn/database/mysql/transaction-isolation-level.html" target="_blank" rel="noopener noreferrer">MySQL 事务隔离级别详解</a>。</p>
<p><strong>3.是否支持外键</strong></p>
<p>MyISAM 不支持，而 InnoDB 支持。</p>
<p>外键对于维护数据一致性非常有帮助，但是对性能有一定的损耗。因此，通常情况下，我们是不建议在实际生产项目中使用外键的，在业务代码中进行约束即可！</p>
<p>阿里的《Java 开发手册》也是明确规定禁止使用外键的。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/mysql/image-20220510090309427.png" alt=""></p>
<p>不过，在代码中进行约束的话，对程序员的能力要求更高，具体是否要采用外键还是要根据你的项目实际情况而定。</p>
<p>总结：一般我们也是不建议在数据库层面使用外键的，应用层面可以解决。不过，这样会对数据的一致性造成威胁。具体要不要使用外键还是要根据你的项目来决定。</p>
<p><strong>4.是否支持数据库异常崩溃后的安全恢复</strong></p>
<p>MyISAM 不支持，而 InnoDB 支持。</p>
<p>使用 InnoDB 的数据库在异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于 <code>redo log</code> 。</p>
<p><strong>5.是否支持 MVCC</strong></p>
<p>MyISAM 不支持，而 InnoDB 支持。</p>
<p>讲真，这个对比有点废话，毕竟 MyISAM 连行级锁都不支持。MVCC 可以看作是行级锁的一个升级，可以有效减少加锁操作，提高性能。</p>
<p><strong>6.索引实现不一样。</strong></p>
<p>虽然 MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是两者的实现方式不太一样。</p>
<p>InnoDB 引擎中，其数据文件本身就是索引文件。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。</p>
<p>详细区别，推荐你看看我写的这篇文章：<a href="https://javaguide.cn/database/mysql/mysql-index.html" target="_blank" rel="noopener noreferrer">MySQL 索引详解</a>。</p>
<h3> MyISAM 和 InnoDB 如何选择？</h3>
<p>大多数时候我们使用的都是 InnoDB 存储引擎，在某些读密集的情况下，使用 MyISAM 也是合适的。不过，前提是你的项目不介意 MyISAM 不支持事务、崩溃恢复等缺点（可是~我们一般都会介意啊！）。</p>
<p>《MySQL 高性能》上面有一句话这样写到:</p>
<blockquote>
<p>不要轻易相信“MyISAM 比 InnoDB 快”之类的经验之谈，这个结论往往不是绝对的。在很多我们已知场景中，InnoDB 的速度都可以让 MyISAM 望尘莫及，尤其是用到了聚簇索引，或者需要访问的数据都可以放入内存的应用。</p>
</blockquote>
<p>一般情况下我们选择 InnoDB 都是没有问题的，但是某些情况下你并不在乎可扩展能力和并发能力，也不需要事务支持，也不在乎崩溃后的安全恢复问题的话，选择 MyISAM 也是一个不错的选择。但是一般情况下，我们都是需要考虑到这些问题的。</p>
<p>因此，对于咱们日常开发的业务系统来说，你几乎找不到什么理由再使用 MyISAM 作为自己的 MySQL 数据库的存储引擎。</p>
<h2> MySQL 索引</h2>
<p>MySQL 索引相关的问题比较多，对于面试和工作都比较重要，于是，我单独抽了一篇文章专门来总结 MySQL 索引相关的知识点和问题： <a href="/database/mysql/mysql-index.html" target="blank">MySQL 索引详解</a> 。</p>
<h2> MySQL 查询缓存</h2>
<p>执行查询语句的时候，会先查询缓存。不过，MySQL 8.0 版本后移除，因为这个功能不太实用</p>
<p><code>my.cnf</code> 加入以下配置，重启 MySQL 开启查询缓存</p>
<div class="language-properties line-numbers-mode" data-ext="properties"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>MySQL 执行以下命令也可以开启查询缓存</p>
<div class="language-properties line-numbers-mode" data-ext="properties"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>如上，<strong>开启查询缓存后在同样的查询条件以及数据情况下，会直接在缓存中返回结果</strong>。这里的查询条件包括查询本身、当前要查询的数据库、客户端协议版本号等一些可能影响结果的信息。（<strong>查询缓存不命中的情况：（1）</strong>）因此任何两个查询在任何字符上的不同都会导致缓存不命中。此外，（<strong>查询缓存不命中的情况：（2）</strong>）如果查询中包含任何用户自定义函数、存储函数、用户变量、临时表、MySQL 库中的系统表，其查询结果也不会被缓存。</p>
<p>（<strong>查询缓存不命中的情况：（3）</strong>）<strong>缓存建立之后</strong>，MySQL 的查询缓存系统会跟踪查询中涉及的每张表，如果这些表（数据或结构）发生变化，那么和这张表相关的所有缓存数据都将失效。</p>
<p><strong>缓存虽然能够提升数据库的查询性能，但是缓存同时也带来了额外的开销，每次查询后都要做一次缓存操作，失效后还要销毁。</strong> 因此，开启查询缓存要谨慎，尤其对于写密集的应用来说更是如此。如果开启，要注意合理控制缓存空间大小，一般来说其大小设置为几十 MB 比较合适。此外，<strong>还可以通过 sql_cache 和 sql_no_cache 来控制某个查询语句是否需要缓存：</strong></p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> MySQL 事务</h2>
<h3> 何谓事务？</h3>
<p>我们设想一个场景，这个场景中我们需要插入多条相关联的数据到数据库，不幸的是，这个过程可能会遇到下面这些问题：</p>
<ul>
<li>数据库中途突然因为某些原因挂掉了。</li>
<li>客户端突然因为网络原因连接不上数据库了。</li>
<li>并发访问数据库时，多个线程同时写入数据库，覆盖了彼此的更改。</li>
<li>......</li>
</ul>
<p>上面的任何一个问题都可能会导致数据的不一致性。为了保证数据的一致性，系统必须能够处理这些问题。事务就是我们抽象出来简化这些问题的首选机制。事务的概念起源于数据库，目前，已经成为一个比较广泛的概念。</p>
<p><strong>何为事务？</strong> 一言蔽之，<strong>事务是逻辑上的一组操作，要么都执行，要么都不执行。</strong></p>
<p>事务最经典也经常被拿出来说例子就是转账了。假如小明要给小红转账 1000 元，这个转账会涉及到两个关键操作，这两个操作必须都成功或者都失败。</p>
<ol>
<li>将小明的余额减少 1000 元</li>
<li>将小红的余额增加 1000 元。</li>
</ol>
<p>事务会把这两个操作就可以看成逻辑上的一个整体，这个整体包含的操作要么都成功，要么都要失败。这样就不会出现小明余额减少而小红的余额却并没有增加的情况。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/mysql/事务示意图.png" alt="事务示意图"></p>
<h3> 何谓数据库事务？</h3>
<p>大多数情况下，我们在谈论事务的时候，如果没有特指<strong>分布式事务</strong>，往往指的就是<strong>数据库事务</strong>。</p>
<p>数据库事务在我们日常开发中接触的最多了。如果你的项目属于单体架构的话，你接触到的往往就是数据库事务了。</p>
<p><strong>那数据库事务有什么作用呢？</strong></p>
<p>简单来说，数据库事务可以保证多个对数据库的操作（也就是 SQL 语句）构成一个逻辑上的整体。构成这个逻辑上的整体的这些数据库操作遵循：<strong>要么全部执行成功,要么全部不执行</strong> 。</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/mysql/数据库事务示意图.png" alt="数据库事务示意图"></p>
<p>另外，关系型数据库（例如：<code>MySQL</code>、<code>SQL Server</code>、<code>Oracle</code> 等）事务都有 <strong>ACID</strong> 特性：</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/mysql/ACID.png" alt="ACID"></p>
<ol>
<li><strong>原子性</strong>（<code>Atomicity</code>） ： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li>
<li><strong>一致性</strong>（<code>Consistency</code>）： 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</li>
<li><strong>隔离性</strong>（<code>Isolation</code>）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li>
<li><strong>持久性</strong>（<code>Durability</code>）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li>
</ol>
<p>🌈 这里要额外补充一点：<strong>只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说 A、I、D 是手段，C 是目的！</strong> 想必大家也和我一样，被 ACID 这个概念被误导了很久! 我也是看周志明老师的公开课<a href="https://time.geekbang.org/opencourse/intro/100064201" target="_blank" rel="noopener noreferrer">《周志明的软件架构课》</a>才搞清楚的（多看好书！！！）。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/mysql/AID->C.png" alt="AID->C"></p>
<p>另外，DDIA 也就是 <a href="https://book.douban.com/subject/30329536/" target="_blank" rel="noopener noreferrer">《Designing Data-Intensive Application（数据密集型应用系统设计）》</a> 的作者在他的这本书中如是说：</p>
<blockquote>
<p>Atomicity, isolation, and durability are properties of the database, whereas consis‐
tency (in the ACID sense) is a property of the application. The application may rely
on the database’s atomicity and isolation properties in order to achieve consistency,
but it’s not up to the database alone.</p>
<p>翻译过来的意思是：原子性，隔离性和持久性是数据库的属性，而一致性（在 ACID 意义上）是应用程序的属性。应用可能依赖数据库的原子性和隔离属性来实现一致性，但这并不仅取决于数据库。因此，字母 C 不属于 ACID 。</p>
</blockquote>
<p>《Designing Data-Intensive Application（数据密集型应用系统设计）》这本书强推一波，值得读很多遍！豆瓣有接近 90% 的人看了这本书之后给了五星好评。另外，中文翻译版本已经在 Github 开源，地址：<a href="https://github.com/Vonng/ddia" target="_blank" rel="noopener noreferrer">https://github.com/Vonng/ddia</a> 。</p>
<p><img src="https://img-blog.csdnimg.cn/20210526162552353.png" alt=""></p>
<h3> 并发事务带来了哪些问题?</h3>
<p>在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。</p>
<h4> 脏读（Dirty read）</h4>
<p>一个事务读取数据并且对数据进行了修改，这个修改对其他事务来说是可见的，即使当前事务没有提交。这时另外一个事务读取了这个还未提交的数据，但第一个事务突然回滚，导致数据并没有被提交到数据库，那第二个事务读取到的就是脏数据，这也就是脏读的由来。</p>
<p>例如：事务 1 读取某表中的数据 A=20，事务 1 修改 A=A-1，事务 2 读取到 A = 19,事务 1 回滚导致对 A 的修改并为提交到数据库， A 的值还是 20。</p>
<p></p>
<h4> 丢失修改（Lost to modify）</h4>
<p>在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。</p>
<p>例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 先修改 A=A-1，事务 2 后来也修改 A=A-1，最终结果 A=19，事务 1 的修改被丢失。</p>
<p></p>
<h4> 不可重复读（Unrepeatable read）</h4>
<p>指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</p>
<p>例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 修改 A=A-1，事务 2 再次读取 A =19，此时读取的结果和第一次读取的结果不同。</p>
<p></p>
<h4> 幻读（Phantom read）</h4>
<p>幻读与不可重复读类似。它发生在一个事务读取了几行数据，接着另一个并发事务插入了一些数据时。在随后的查询中，第一个事务就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</p>
<p>例如：事务 2 读取某个范围的数据，事务 1 在这个范围插入了新的数据，事务 1 再次读取这个范围的数据发现相比于第一次读取的结果多了新的数据。</p>
<p></p>
<h3> 不可重复读和幻读有什么区别？</h3>
<ul>
<li>不可重复读的重点是内容修改或者记录减少比如多次读取一条记录发现其中某些记录的值被修改；</li>
<li>幻读的重点在于记录新增比如多次执行同一条查询语句（DQL）时，发现查到的记录增加了。</li>
</ul>
<p>幻读其实可以看作是不可重复读的一种特殊情况，单独把区分幻读的原因主要是解决幻读和不可重复读的方案不一样。</p>
<p>举个例子：执行 <code>delete</code> 和 <code>update</code> 操作的时候，可以直接对记录加锁，保证事务安全。而执行 <code>insert</code> 操作的时候，由于记录锁（Record Lock）只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁（Gap Lock）。也就是说执行 <code>insert</code> 操作的时候需要依赖 Next-Key Lock（Record Lock+Gap Lock） 进行加锁来保证不出现幻读。</p>
<h3> SQL 标准定义了哪些事务隔离级别?</h3>
<p>SQL 标准定义了四个隔离级别：</p>
<ul>
<li><strong>READ-UNCOMMITTED(读取未提交)</strong> ： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li>
<li><strong>READ-COMMITTED(读取已提交)</strong> ： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</li>
<li><strong>REPEATABLE-READ(可重复读)</strong> ： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li>
<li><strong>SERIALIZABLE(可串行化)</strong> ： 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</li>
</ul>
<hr>
<table>
<thead>
<tr>
<th style="text-align:center">隔离级别</th>
<th style="text-align:center">脏读</th>
<th style="text-align:center">不可重复读</th>
<th style="text-align:center">幻读</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">READ-UNCOMMITTED</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:center">READ-COMMITTED</td>
<td style="text-align:center">×</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:center">REPEATABLE-READ</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:center">SERIALIZABLE</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
</tr>
</tbody>
</table>
<h3> MySQL 的隔离级别是基于锁实现的吗？</h3>
<p>MySQL 的隔离级别基于锁和 MVCC 机制共同实现的。</p>
<p>SERIALIZABLE 隔离级别，是通过锁来实现的。除了 SERIALIZABLE 隔离级别，其他的隔离级别都是基于 MVCC 实现。</p>
<p>不过， SERIALIZABLE 之外的其他隔离级别可能也需要用到锁机制，就比如 REPEATABLE-READ 在当前读情况下需要使用加锁读来保证不会出现幻读。</p>
<h3> MySQL 的默认隔离级别是什么?</h3>
<p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong>。我们可以通过<code>SELECT @@tx_isolation;</code>命令来查看，MySQL 8.0 该命令改为<code>SELECT @@transaction_isolation;</code></p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>关于 MySQL 事务隔离级别的详细介绍，可以看看我写的这篇文章：<a href="https://javaguide.cn/database/mysql/transaction-isolation-level.html" target="_blank" rel="noopener noreferrer">MySQL 事务隔离级别详解</a>。</p>
<h2> MySQL 锁</h2>
<h3> 表级锁和行级锁了解吗？有什么区别？</h3>
<p>MyISAM 仅仅支持表级锁(table-level locking)，一锁就锁整张表，这在并发写的情况下性非常差。</p>
<p>InnoDB 不光支持表级锁(table-level locking)，还支持行级锁(row-level locking)，默认为行级锁。行级锁的粒度更小，仅对相关的记录上锁即可（对一行或者多行记录加锁），所以对于并发写入操作来说， InnoDB 的性能更高。</p>
<p><strong>表级锁和行级锁对比</strong> ：</p>
<ul>
<li><strong>表级锁：</strong> MySQL 中锁定粒度最大的一种锁（全局锁除外），是针对非索引字段加的锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM 和 InnoDB 引擎都支持表级锁。</li>
<li><strong>行级锁：</strong> MySQL 中锁定粒度最小的一种锁，是针对索引字段加的锁，只针对当前操作的行记录进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。</li>
</ul>
<h3> 行级锁的使用有什么注意事项？</h3>
<p>InnoDB 的行锁是针对索引字段加的锁，表级锁是针对非索引字段加的锁。当我们执行 <code>UPDATE</code>、<code>DELETE</code> 语句时，如果 <code>WHERE</code>条件中字段没有命中唯一索引或者索引失效的话，就会导致扫描全表对表中的所有行记录进行加锁。这个在我们日常工作开发中经常会遇到，一定要多多注意！！！</p>
<p>不过，很多时候即使用了索引也有可能会走全表扫描，这是因为 MySQL 优化器的原因。</p>
<h3> 共享锁和排他锁呢？</h3>
<p>不论是表级锁还是行级锁，都存在共享锁（Share Lock，S 锁）和排他锁（Exclusive Lock，X 锁）这两类：</p>
<ul>
<li><strong>共享锁（S 锁）</strong> ：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。</li>
<li><strong>排他锁（X 锁）</strong> ：又称写锁/独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条事务加任何类型的锁（锁不兼容）。</li>
</ul>
<p>排他锁与任何的锁都不兼容，共享锁仅和共享锁兼容。</p>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">S 锁</th>
<th style="text-align:left">X 锁</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">S 锁</td>
<td style="text-align:left">不冲突</td>
<td style="text-align:left">冲突</td>
</tr>
<tr>
<td style="text-align:left">X 锁</td>
<td style="text-align:left">冲突</td>
<td style="text-align:left">冲突</td>
</tr>
</tbody>
</table>
<p>由于 MVCC 的存在，对于一般的 <code>SELECT</code> 语句，InnoDB 不会加任何锁。不过， 你可以通过以下语句显式加共享锁或排他锁。</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 意向锁有什么作用？</h3>
<p>如果需要用到表锁的话，如何判断表中的记录没有行锁呢？一行一行遍历肯定是不行，性能太差。我们需要用到一个叫做意向锁的东东来快速判断是否可以对某个表使用表锁。</p>
<p>意向锁是表级锁，共有两种：</p>
<ul>
<li><strong>意向共享锁（Intention Shared Lock，IS 锁）</strong>：事务有意向对表中的某些记录加共享锁（S 锁），加共享锁前必须先取得该表的 IS 锁。</li>
<li><strong>意向排他锁（Intention Exclusive Lock，IX 锁）</strong>：事务有意向对表中的某些记录加排他锁（X 锁），加排他锁之前必须先取得该表的 IX 锁。</li>
</ul>
<p>意向锁是有数据引擎自己维护的，用户无法手动操作意向锁，在为数据行加共享 / 排他锁之前，InooDB 会先获取该数据行所在在数据表的对应意向锁。</p>
<p>意向锁之间是互相兼容的。</p>
<table>
<thead>
<tr>
<th></th>
<th>IS 锁</th>
<th>IX 锁</th>
</tr>
</thead>
<tbody>
<tr>
<td>IS 锁</td>
<td>兼容</td>
<td>兼容</td>
</tr>
<tr>
<td>IX 锁</td>
<td>兼容</td>
<td>兼容</td>
</tr>
</tbody>
</table>
<p>意向锁和共享锁和排它锁互斥（这里指的是表级别的共享锁和排他锁，意向锁不会与行级的共享锁和排他锁互斥）。</p>
<table>
<thead>
<tr>
<th></th>
<th>IS 锁</th>
<th>IX 锁</th>
</tr>
</thead>
<tbody>
<tr>
<td>S 锁</td>
<td>兼容</td>
<td>互斥</td>
</tr>
<tr>
<td>X 锁</td>
<td>互斥</td>
<td>互斥</td>
</tr>
</tbody>
</table>
<p>《MySQL 技术内幕 InnoDB 存储引擎》这本书对应的描述应该是笔误了。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/mysql/image-20220511171419081.png" alt=""></p>
<h3> InnoDB 有哪几类行锁？</h3>
<p>MySQL InnoDB 支持三种行锁定方式：</p>
<ul>
<li><strong>记录锁（Record Lock）</strong> ：也被称为记录锁，属于单个行记录上的锁。</li>
<li><strong>间隙锁（Gap Lock）</strong> ：锁定一个范围，不包括记录本身。</li>
<li><strong>临键锁（Next-key Lock）</strong> ：Record Lock+Gap Lock，锁定一个范围，包含记录本身。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。</li>
</ul>
<p>InnoDB 的默认隔离级别 RR（可重读）是可以解决幻读问题发生的，主要有下面两种情况：</p>
<ul>
<li><strong>快照读</strong>（一致性非锁定读） ：由 MVCC 机制来保证不出现幻读。</li>
<li><strong>当前读</strong> （一致性锁定读）： 使用 Next-Key Lock 进行加锁来保证不出现幻读。</li>
</ul>
<h3> 当前读和快照读有什么区别？</h3>
<p><strong>快照读</strong>（一致性非锁定读）就是单纯的 <code>SELECT</code> 语句，但不包括下面这两类 <code>SELECT</code> 语句：</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>快照即记录的历史版本，每行记录可能存在多个历史版本（多版本技术）。</p>
<p>快照读的情况下，如果读取的记录正在执行 UPDATE/DELETE 操作，读取操作不会因此去等待记录上 X 锁的释放，而是会去读取行的一个快照。</p>
<p>只有在事务隔离级别 RC(读取已提交) 和 RR（可重读）下，InnoDB 才会使用一致性非锁定读：</p>
<ul>
<li>在 RC 级别下，对于快照数据，一致性非锁定读总是读取被锁定行的最新一份快照数据。</li>
<li>在 RR 级别下，对于快照数据，一致性非锁定读总是读取本事务开始时的行数据版本。</li>
</ul>
<p>快照读比较适合对于数据一致性要求不是特别高且追求极致性能的业务场景。</p>
<p><strong>当前读</strong> （一致性锁定读）就是给行记录加 X 锁或 S 锁。</p>
<p>当前读的一些常见 SQL 语句类型如下：</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> MySQL 性能优化</h2>
<p>关于 MySQL 性能优化的建议总结，请看这篇文章：<a href="/database/mysql/mysql-high-performance-optimization-specification-recommendations.html" target="blank">MySQL 高性能优化规范建议总结</a> 。</p>
<h3> 能用 MySQL 直接存储文件（比如图片）吗？</h3>
<p>可以是可以，直接存储文件对应的二进制数据即可。不过，还是建议不要在数据库中存储文件，会严重影响数据库性能，消耗过多存储空间。</p>
<p>可以选择使用云服务厂商提供的开箱即用的文件存储服务，成熟稳定，价格也比较低。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/mysql/oss-search.png" alt=""></p>
<p>也可以选择自建文件存储服务，实现起来也不难，基于 FastDFS、MinIO（推荐） 等开源项目就可以实现分布式文件服务。</p>
<p><strong>数据库只存储文件地址信息，文件由文件存储服务负责存储。</strong></p>
<p>相关阅读：<a href="https://mp.weixin.qq.com/s/xfYCESLOuq3_0e3SFj6ZMQ" target="_blank" rel="noopener noreferrer">Spring Boot 整合 MinIO 实现分布式文件服务，真香！</a> 。</p>
<h3> MySQL 如何存储 IP 地址？</h3>
<p>可以将 IP 地址转换成整形数据存储，性能更好，占用空间也更小。</p>
<p>MySQL 提供了两个方法来处理 ip 地址</p>
<ul>
<li><code>INET_ATON()</code> ： 把 ip 转为无符号整型 (4-8 位)</li>
<li><code>INET_NTOA()</code> :把整型的 ip 转为地址</li>
</ul>
<p>插入数据前，先用 <code>INET_ATON()</code> 把 ip 地址转为整型，显示数据时，使用 <code>INET_NTOA()</code> 把整型的 ip 地址转为地址显示即可。</p>
<h3> 有哪些常见的 SQL 优化手段？</h3>
<p><a href="https://www.yuque.com/docs/share/f37fc804-bfe6-4b0d-b373-9c462188fec7" target="_blank" rel="noopener noreferrer">《Java 面试指北》</a> 的「技术面试题篇」有一篇文章详细介绍了常见的 SQL 优化手段，非常全面，清晰易懂！</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javamianshizhibei/javamianshizhibei-sql-optimization.png" alt="常见的 SQL 优化手段"></p>
<h2> 参考</h2>
<ul>
<li>《高性能 MySQL》第 7 章 MySQL 高级特性</li>
<li>《MySQL 技术内幕 InnoDB 存储引擎》第 6 章 锁</li>
<li>Relational Database：https://www.omnisci.com/technical-glossary/relational-database</li>
<li>技术分享 | 隔离级别：正确理解幻读：https://opensource.actionsky.com/20210818-mysql/</li>
<li>MySQL Server Logs - MySQL 5.7 Reference Manual：https://dev.mysql.com/doc/refman/5.7/en/server-logs.html</li>
<li>Redo Log - MySQL 5.7 Reference Manual：https://dev.mysql.com/doc/refman/5.7/en/innodb-redo-log.html</li>
<li>Locking Reads - MySQL 5.7 Reference Manual：https://dev.mysql.com/doc/refman/5.7/en/innodb-locking-reads.html</li>
<li>深入理解数据库行锁与表锁 https://zhuanlan.zhihu.com/p/52678870</li>
<li>详解 MySQL InnoDB 中意向锁的作用：https://juejin.cn/post/6844903666332368909</li>
<li>在数据库中不可重复读和幻读到底应该怎么分？：https://www.zhihu.com/question/392569386</li>
</ul>
]]></content:encoded>
      <enclosure url="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/java-guide-blog/5e3c1a71724a38245aa43b02_99bf70d46cc247be878de9d3a88f0c44.png" type="image/png"/>
    </item>
    <item>
      <title>MySQL数据库时间类型数据存储建议</title>
      <link>https://javaguide.cn/database/mysql/some-thoughts-on-database-storage-time.html</link>
      <guid>https://javaguide.cn/database/mysql/some-thoughts-on-database-storage-time.html</guid>
      <source url="https://javaguide.cn/rss.xml">MySQL数据库时间类型数据存储建议</source>
      <description>我们平时开发中不可避免的就是要存储时间，比如我们要记录操作表中这条记录的时间、记录转账的交易时间、记录出发时间等等。你会发现时间这个东西与我们开发的联系还是非常紧密的，用的好与不好会给我们的业务甚至功能带来很大的影响。所以，我们有必要重新出发，好好认识一下这个东西。 这是一篇短小精悍的文章，仔细阅读一定能学到不少东西！ 不要用字符串存储日期 我记得我在大学的时候就这样干过，而且现在很多对数据库不太了解的新手也会这样干，可见，这种存储日期的方式的优点还是有的，就是简单直白，容易上手。 但是，这是不正确的做法，主要会有下面两个问题：</description>
      <category>数据库</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<p>我们平时开发中不可避免的就是要存储时间，比如我们要记录操作表中这条记录的时间、记录转账的交易时间、记录出发时间等等。你会发现时间这个东西与我们开发的联系还是非常紧密的，用的好与不好会给我们的业务甚至功能带来很大的影响。所以，我们有必要重新出发，好好认识一下这个东西。</p>
<p>这是一篇短小精悍的文章，仔细阅读一定能学到不少东西！</p>
<h2> 不要用字符串存储日期</h2>
<p>我记得我在大学的时候就这样干过，而且现在很多对数据库不太了解的新手也会这样干，可见，这种存储日期的方式的优点还是有的，就是简单直白，容易上手。</p>
<p>但是，这是不正确的做法，主要会有下面两个问题：</p>
<ol>
<li>字符串占用的空间更大！</li>
<li>字符串存储的日期效率比较低（逐个字符进行比对），无法用日期相关的 API 进行计算和比较。</li>
</ol>
<h2> Datetime 和 Timestamp 之间抉择</h2>
<p>Datetime 和 Timestamp 是 MySQL 提供的两种比较相似的保存时间的数据类型。他们两者究竟该如何选择呢？</p>
<p><strong>通常我们都会首选 Timestamp。</strong> 下面说一下为什么这样做!</p>
<h3> DateTime 类型没有时区信息</h3>
<p><strong>DateTime 类型是没有时区信息的（时区无关）</strong> ，DateTime 类型保存的时间都是当前会话所设置的时区对应的时间。这样就会有什么问题呢？当你的时区更换之后，比如你的服务器更换地址或者更换客户端连接时区设置的话，就会导致你从数据库中读出的时间错误。不要小看这个问题，很多系统就是因为这个问题闹出了很多笑话。</p>
<p><strong>Timestamp 和时区有关</strong>。Timestamp 类型字段的值会随着服务器时区的变化而变化，自动换算成相应的时间，说简单点就是在不同时区，查询到同一个条记录此字段的值会不一样。</p>
<p>下面实际演示一下！</p>
<p>建表 SQL 语句：</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>插入数据：</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>查看数据：</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>结果：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在我们运行</p>
<p>修改当前会话的时区:</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>再次查看数据：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>扩展：一些关于 MySQL 时区设置的一个常用 sql 命令</strong></p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> DateTime 类型耗费空间更大</h3>
<p>Timestamp 只需要使用 4 个字节的存储空间，但是 DateTime 需要耗费 8 个字节的存储空间。但是，这样同样造成了一个问题，Timestamp 表示的时间范围更小。</p>
<ul>
<li>DateTime ：1000-01-01 00:00:00 ~ 9999-12-31 23:59:59</li>
<li>Timestamp： 1970-01-01 00:00:01 ~ 2037-12-31 23:59:59</li>
</ul>
<blockquote>
<p>Timestamp 在不同版本的 MySQL 中有细微差别。</p>
</blockquote>
<h2> 再看 MySQL 日期类型存储空间</h2>
<p>下图是 MySQL 5.6 版本中日期类型所占的存储空间：</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/FhRGUVHFK0ujRPNA75f6CuOXQHTE.jpeg" alt=""></p>
<p>可以看出 5.6.4 之后的 MySQL 多出了一个需要 0 ～ 3 字节的小数位。DateTime 和 Timestamp 会有几种不同的存储空间占用。</p>
<p>为了方便，本文我们还是默认 Timestamp 只需要使用 4 个字节的存储空间，但是 DateTime 需要耗费 8 个字节的存储空间。</p>
<h2> 数值型时间戳是更好的选择吗？</h2>
<p>很多时候，我们也会使用 int 或者 bigint 类型的数值也就是时间戳来表示时间。</p>
<p>这种存储方式的具有 Timestamp 类型的所具有一些优点，并且使用它的进行日期排序以及对比等操作的效率会更高，跨系统也很方便，毕竟只是存放的数值。缺点也很明显，就是数据的可读性太差了，你无法直观的看到具体时间。</p>
<p>时间戳的定义如下：</p>
<blockquote>
<p>时间戳的定义是从一个基准时间开始算起，这个基准时间是「1970-1-1 00:00:00 +0:00」，从这个时间开始，用整数表示，以秒计时，随着时间的流逝这个时间整数不断增加。这样一来，我只需要一个数值，就可以完美地表示时间了，而且这个数值是一个绝对数值，即无论的身处地球的任何角落，这个表示时间的时间戳，都是一样的，生成的数值都是一样的，并且没有时区的概念，所以在系统的中时间的传输中，都不需要进行额外的转换了，只有在显示给用户的时候，才转换为字符串格式的本地时间。</p>
</blockquote>
<p>数据库中实际操作：</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 总结</h2>
<p>MySQL 中时间到底怎么存储才好？Datetime?Timestamp? 数值保存的时间戳？</p>
<p>好像并没有一个银弹，很多程序员会觉得数值型时间戳是真的好，效率又高还各种兼容，但是很多人又觉得它表现的不够直观。这里插一嘴，《高性能 MySQL 》这本神书的作者就是推荐 Timestamp，原因是数值表示时间不够直观。下面是原文：</p>
<img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/高性能mysql-不推荐用数值时间戳.jpg" style="zoom:50%;">
<p>每种方式都有各自的优势，根据实际场景才是王道。下面再对这三种方式做一个简单的对比，以供大家实际开发中选择正确的存放时间的数据类型：</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/总结-常用日期存储方式.jpg" alt=""></p>
]]></content:encoded>
      <enclosure url="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/FhRGUVHFK0ujRPNA75f6CuOXQHTE.jpeg" type="image/jpeg"/>
    </item>
    <item>
      <title>MySQL事务隔离级别详解</title>
      <link>https://javaguide.cn/database/mysql/transaction-isolation-level.html</link>
      <guid>https://javaguide.cn/database/mysql/transaction-isolation-level.html</guid>
      <source url="https://javaguide.cn/rss.xml">MySQL事务隔离级别详解</source>
      <description>本文由 SnailClimb 和 guang19 共同完成。 关于事务基本概览的介绍，请看这篇文章的介绍：MySQL 常见知识点&amp;amp;面试题总结</description>
      <category>数据库</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>本文由 <a href="https://github.com/Snailclimb" target="_blank" rel="noopener noreferrer">SnailClimb</a> 和 <a href="https://github.com/guang19" target="_blank" rel="noopener noreferrer">guang19</a> 共同完成。</p>
</blockquote>
<p>关于事务基本概览的介绍，请看这篇文章的介绍：<a href="/database/mysql/mysql-questions-01.html#MySQL-%E4%BA%8B%E5%8A%A1" target="blank">MySQL 常见知识点&amp;面试题总结</a></p>
<h2> 事务隔离级别总结</h2>
<p>SQL 标准定义了四个隔离级别：</p>
<ul>
<li><strong>READ-UNCOMMITTED(读取未提交)</strong> ： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li>
<li><strong>READ-COMMITTED(读取已提交)</strong> ： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</li>
<li><strong>REPEATABLE-READ(可重复读)</strong> ： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li>
<li><strong>SERIALIZABLE(可串行化)</strong> ： 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</li>
</ul>
<hr>
<table>
<thead>
<tr>
<th style="text-align:center">隔离级别</th>
<th style="text-align:center">脏读</th>
<th style="text-align:center">不可重复读</th>
<th style="text-align:center">幻读</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">READ-UNCOMMITTED</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:center">READ-COMMITTED</td>
<td style="text-align:center">×</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:center">REPEATABLE-READ</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:center">SERIALIZABLE</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
</tr>
</tbody>
</table>
<p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong>。我们可以通过<code>SELECT @@tx_isolation;</code>命令来查看，MySQL 8.0 该命令改为<code>SELECT @@transaction_isolation;</code></p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面对 SQL 标准定义了四个隔离级别的介绍可以看出，标准的 SQL 隔离级别定义里，REPEATABLE-READ(可重复读)是不可以防止幻读的。</p>
<p>但是！InnoDB 实现的 REPEATABLE-READ 隔离级别其实是可以解决幻读问题发生的，主要有下面两种情况：</p>
<ul>
<li><strong>快照读</strong> ：由 MVCC 机制来保证不出现幻读。</li>
<li><strong>当前读</strong> ： 使用 Next-Key Lock 进行加锁来保证不出现幻读，Next-Key Lock 是行锁（Record Lock）和间隙锁（Gap Lock）的结合，行锁只能锁住已经存在的行，为了避免插入新行，需要依赖间隙锁。</li>
</ul>
<p>因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是 <strong>READ-COMMITTED</strong> ，但是你要知道的是 InnoDB 存储引擎默认使用 <strong>REPEATABLE-READ</strong> 并不会有任何性能损失。</p>
<p>InnoDB 存储引擎在分布式事务的情况下一般会用到 SERIALIZABLE 隔离级别。</p>
<p>《MySQL 技术内幕：InnoDB 存储引擎(第 2 版)》7.7 章这样写到：</p>
<blockquote>
<p>InnoDB 存储引擎提供了对 XA 事务的支持，并通过 XA 事务来支持分布式事务的实现。分布式事务指的是允许多个独立的事务资源（transactional resources）参与到一个全局的事务中。事务资源通常是关系型数据库系统，但也可以是其他类型的资源。全局事务要求在其中的所有参与的事务要么都提交，要么都回滚，这对于事务原有的 ACID 要求又有了提高。另外，在使用分布式事务时，InnoDB 存储引擎的事务隔离级别必须设置为 SERIALIZABLE。</p>
</blockquote>
<h2> 实际情况演示</h2>
<p>在下面我会使用 2 个命令行 MySQL ，模拟多线程（多事务）对同一份数据的脏读问题。</p>
<p>MySQL 命令行的默认配置中事务都是自动提交的，即执行 SQL 语句后就会马上执行 COMMIT 操作。如果要显式地开启一个事务需要使用命令：<code>START TRANSACTION</code>。</p>
<p>我们可以通过下面的命令来设置隔离级别。</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>我们再来看一下我们在下面实际操作中使用到的一些并发控制语句:</p>
<ul>
<li><code>START TRANSACTION</code> |<code>BEGIN</code>：显式地开启一个事务。</li>
<li><code>COMMIT</code>：提交事务，使得对数据库做的所有修改成为永久性。</li>
<li><code>ROLLBACK</code>：回滚会结束用户的事务，并撤销正在进行的所有未提交的修改。</li>
</ul>
<h3> 脏读(读未提交)</h3>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-31-1脏读(读未提交)实例.jpg" alt=""></p>
<h3> 避免脏读(读已提交)</h3>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-31-2读已提交实例.jpg" alt=""></p>
<h3> 不可重复读</h3>
<p>还是刚才上面的读已提交的图，虽然避免了读未提交，但是却出现了，一个事务还没有结束，就发生了 不可重复读问题。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-32-1不可重复读实例.jpg" alt=""></p>
<h3> 可重复读</h3>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-33-2可重复读.jpg" alt=""></p>
<h3> 幻读</h3>
<h4> 演示幻读出现的情况</h4>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/phantom_read.png" alt=""></p>
<p>SQL 脚本 1 在第一次查询工资为 500 的记录时只有一条，SQL 脚本 2 插入了一条工资为 500 的记录，提交之后；SQL 脚本 1 在同一个事务中再次使用当前读查询发现出现了两条工资为 500 的记录这种就是幻读。</p>
<h4> 解决幻读的方法</h4>
<p>解决幻读的方式有很多，但是它们的核心思想就是一个事务在操作某张表数据的时候，另外一个事务不允许新增或者删除这张表中的数据了。解决幻读的方式主要有以下几种：</p>
<ol>
<li>将事务隔离级别调整为 <code>SERIALIZABLE</code> 。</li>
<li>在可重复读的事务级别下，给事务操作的这张表添加表锁。</li>
<li>在可重复读的事务级别下，给事务操作的这张表添加 <code>Next-key Lock（Record Lock+Gap Lock）</code>。</li>
</ol>
<h3> 参考</h3>
<ul>
<li>《MySQL 技术内幕：InnoDB 存储引擎》</li>
<li><a href="https://dev.MySQL.com/doc/refman/5.7/en/" target="_blank" rel="noopener noreferrer">https://dev.MySQL.com/doc/refman/5.7/en/</a></li>
<li><a href="https://tech.youzan.com/seven-questions-about-the-lock-of-MySQL/" target="_blank" rel="noopener noreferrer">Mysql 锁：灵魂七拷问</a></li>
<li><a href="https://tech.meituan.com/2014/08/20/innodb-lock.html" target="_blank" rel="noopener noreferrer">Innodb 中的事务隔离级别和锁的关系</a></li>
</ul>
]]></content:encoded>
      <enclosure url="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-31-1脏读(读未提交" type="image/"/>
    </item>
    <item>
      <title>3种常用的缓存读写策略详解</title>
      <link>https://javaguide.cn/database/redis/3-commonly-used-cache-read-and-write-strategies.html</link>
      <guid>https://javaguide.cn/database/redis/3-commonly-used-cache-read-and-write-strategies.html</guid>
      <source url="https://javaguide.cn/rss.xml">3种常用的缓存读写策略详解</source>
      <description>看到很多小伙伴简历上写了“熟练使用缓存”，但是被我问到“缓存常用的3种读写策略”的时候却一脸懵逼。 在我看来，造成这个问题的原因是我们在学习 Redis 的时候，可能只是简单了写一些 Demo，并没有去关注缓存的读写策略，或者说压根不知道这回事。 但是，搞懂3种常见的缓存读写策略对于实际工作中使用缓存以及面试中被问到缓存都是非常有帮助的！ 下面介绍到的三种模式各有优劣，不存在最佳模式，根据具体的业务场景选择适合自己的缓存读写模式。 Cache Aside Pattern（旁路缓存模式）</description>
      <category>数据库</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<p>看到很多小伙伴简历上写了“<strong>熟练使用缓存</strong>”，但是被我问到“<strong>缓存常用的3种读写策略</strong>”的时候却一脸懵逼。</p>
<p>在我看来，造成这个问题的原因是我们在学习 Redis 的时候，可能只是简单了写一些 Demo，并没有去关注缓存的读写策略，或者说压根不知道这回事。</p>
<p>但是，搞懂3种常见的缓存读写策略对于实际工作中使用缓存以及面试中被问到缓存都是非常有帮助的！</p>
<p><strong>下面介绍到的三种模式各有优劣，不存在最佳模式，根据具体的业务场景选择适合自己的缓存读写模式。</strong></p>
<h3> Cache Aside Pattern（旁路缓存模式）</h3>
<p><strong>Cache Aside Pattern 是我们平时使用比较多的一个缓存读写模式，比较适合读请求比较多的场景。</strong></p>
<p>Cache Aside Pattern 中服务端需要同时维系 db 和 cache，并且是以 db 的结果为准。</p>
<p>下面我们来看一下这个策略模式下的缓存读写步骤。</p>
<p><strong>写</strong> ：</p>
<ul>
<li>先更新 db</li>
<li>然后直接删除 cache 。</li>
</ul>
<p>简单画了一张图帮助大家理解写的步骤。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/cache-aside-write.png" alt=""></p>
<p><strong>读</strong> :</p>
<ul>
<li>从 cache 中读取数据，读取到就直接返回</li>
<li>cache 中读取不到的话，就从 db 中读取数据返回</li>
<li>再把数据放到 cache 中。</li>
</ul>
<p>简单画了一张图帮助大家理解读的步骤。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/cache-aside-read.png" alt=""></p>
<p>你仅仅了解了上面这些内容的话是远远不够的，我们还要搞懂其中的原理。</p>
<p>比如说面试官很可能会追问：“<strong>在写数据的过程中，可以先删除 cache ，后更新 db 么？</strong>”</p>
<p><strong>答案：</strong> 那肯定是不行的！因为这样可能会造成 <strong>数据库（db）和缓存（Cache）数据不一致</strong>的问题。</p>
<p>举例：请求 1 先写数据 A，请求 2 随后读数据 A 的话，就很有可能产生数据不一致性的问题。</p>
<p>这个过程可以简单描述为：</p>
<blockquote>
<p>请求 1 先把 cache 中的 A 数据删除 -&gt; 请求 2 从 db 中读取数据-&gt;请求 1 再把 db 中的 A 数据更新</p>
</blockquote>
<p>当你这样回答之后，面试官可能会紧接着就追问：“<strong>在写数据的过程中，先更新 db，后删除 cache 就没有问题了么？</strong>”</p>
<p><strong>答案：</strong> 理论上来说还是可能会出现数据不一致性的问题，不过概率非常小，因为缓存的写入速度是比数据库的写入速度快很多。</p>
<p>举例：请求 1 先读数据 A，请求 2 随后写数据 A，并且数据 A 在请求 1 请求之前不在缓存中的话，也有可能产生数据不一致性的问题。</p>
<p>这个过程可以简单描述为：</p>
<blockquote>
<p>请求 1 从 db 读数据 A-&gt; 请求 2 更新 db 中的数据 A（此时缓存中无数据 A ，故不用执行删除缓存操作 ） -&gt; 请求 1 将数据 A 写入 cache</p>
</blockquote>
<p>现在我们再来分析一下 <strong>Cache Aside Pattern 的缺陷</strong>。</p>
<p><strong>缺陷 1：首次请求数据一定不在 cache 的问题</strong></p>
<p>解决办法：可以将热点数据可以提前放入 cache 中。</p>
<p><strong>缺陷 2：写操作比较频繁的话导致 cache 中的数据会被频繁被删除，这样会影响缓存命中率 。</strong></p>
<p>解决办法：</p>
<ul>
<li>数据库和缓存数据强一致场景 ：更新 db 的时候同样更新 cache，不过我们需要加一个锁/分布式锁来保证更新 cache 的时候不存在线程安全问题。</li>
<li>可以短暂地允许数据库和缓存数据不一致的场景 ：更新 db 的时候同样更新 cache，但是给缓存加一个比较短的过期时间，这样的话就可以保证即使数据不一致的话影响也比较小。</li>
</ul>
<h3> Read/Write Through Pattern（读写穿透）</h3>
<p>Read/Write Through Pattern 中服务端把 cache 视为主要数据存储，从中读取数据并将数据写入其中。cache 服务负责将此数据读取和写入 db，从而减轻了应用程序的职责。</p>
<p>这种缓存读写策略小伙伴们应该也发现了在平时在开发过程中非常少见。抛去性能方面的影响，大概率是因为我们经常使用的分布式缓存 Redis 并没有提供 cache 将数据写入 db 的功能。</p>
<p><strong>写（Write Through）：</strong></p>
<ul>
<li>先查 cache，cache 中不存在，直接更新 db。</li>
<li>cache 中存在，则先更新 cache，然后 cache 服务自己更新 db（<strong>同步更新 cache 和 db</strong>）。</li>
</ul>
<p>简单画了一张图帮助大家理解写的步骤。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/write-through.png" alt=""></p>
<p><strong>读(Read Through)：</strong></p>
<ul>
<li>从 cache 中读取数据，读取到就直接返回 。</li>
<li>读取不到的话，先从 db 加载，写入到 cache 后返回响应。</li>
</ul>
<p>简单画了一张图帮助大家理解读的步骤。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/read-through.png" alt=""></p>
<p>Read-Through Pattern 实际只是在 Cache-Aside Pattern 之上进行了封装。在 Cache-Aside Pattern 下，发生读请求的时候，如果 cache 中不存在对应的数据，是由客户端自己负责把数据写入 cache，而 Read Through Pattern 则是 cache 服务自己来写入缓存的，这对客户端是透明的。</p>
<p>和 Cache Aside Pattern 一样， Read-Through Pattern 也有首次请求数据一定不再 cache 的问题，对于热点数据可以提前放入缓存中。</p>
<h3> Write Behind Pattern（异步缓存写入）</h3>
<p>Write Behind Pattern 和 Read/Write Through Pattern 很相似，两者都是由 cache 服务来负责 cache 和 db 的读写。</p>
<p>但是，两个又有很大的不同：<strong>Read/Write Through 是同步更新 cache 和 db，而 Write Behind 则是只更新缓存，不直接更新 db，而是改为异步批量的方式来更新 db。</strong></p>
<p>很明显，这种方式对数据一致性带来了更大的挑战，比如 cache 数据可能还没异步更新 db 的话，cache 服务可能就就挂掉了。</p>
<p>这种策略在我们平时开发过程中也非常非常少见，但是不代表它的应用场景少，比如消息队列中消息的异步写入磁盘、MySQL 的 Innodb Buffer Pool 机制都用到了这种策略。</p>
<p>Write Behind Pattern 下 db 的写性能非常高，非常适合一些数据经常变化又对数据一致性要求没那么高的场景，比如浏览量、点赞量。</p>
]]></content:encoded>
      <enclosure url="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/cache-aside-write.png" type="image/png"/>
    </item>
    <item>
      <title>缓存基础常见面试题总结(付费)</title>
      <link>https://javaguide.cn/database/redis/cache-basics.html</link>
      <guid>https://javaguide.cn/database/redis/cache-basics.html</guid>
      <source url="https://javaguide.cn/rss.xml">缓存基础常见面试题总结(付费)</source>
      <description>缓存基础常见知识点&amp;amp;面试题总结 相关的面试题为我的知识星球（点击链接即可查看详细介绍以及加入方法）专属内容，已经整理到了《Java 面试指北》（点击链接即可查看详细介绍以及获取方法）中。</description>
      <category>数据库</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<p><strong>缓存基础常见知识点&amp;面试题总结</strong> 相关的面试题为我的<a href="https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc" target="_blank" rel="noopener noreferrer">知识星球</a>（点击链接即可查看详细介绍以及加入方法）专属内容，已经整理到了<a href="https://www.yuque.com/docs/share/f37fc804-bfe6-4b0d-b373-9c462188fec7" target="_blank" rel="noopener noreferrer">《Java 面试指北》</a>（点击链接即可查看详细介绍以及获取方法）中。</p>
<p><a href="https://www.yuque.com/docs/share/f37fc804-bfe6-4b0d-b373-9c462188fec7" target="_blank" rel="noopener noreferrer">《Java 面试指北》</a> 的部分内容展示如下，你可以将其看作是 <a href="https://javaguide.cn/#/" target="_blank" rel="noopener noreferrer">JavaGuide</a> 的补充完善，两者可以配合使用。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220304102536445.png" alt=""></p>
<p><a href="https://www.yuque.com/docs/share/f37fc804-bfe6-4b0d-b373-9c462188fec7" target="_blank" rel="noopener noreferrer">《Java 面试指北》</a>只是星球内部众多资料中的一个，星球还有很多其他优质资料比如<a href="https://javaguide.cn/zhuanlan/" target="_blank" rel="noopener noreferrer">专属专栏</a>、Java 编程视频、PDF 资料。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220211231206733.png" alt=""></p>
<p>最近几年，市面上有越来越多的“技术大佬”开始办培训班/训练营，动辄成千上万的学费，却并没有什么干货，单纯的就是割韭菜。</p>
<p>为了帮助更多同学准备 Java 面试以及学习 Java ，我创建了一个纯粹的<a href="https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc" target="_blank" rel="noopener noreferrer">知识星球</a>。虽然收费只有培训班/训练营的百分之一，但是<a href="https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc" target="_blank" rel="noopener noreferrer">知识星球</a>里的内容质量更高，提供的服务也更全面。</p>
<p>欢迎准备 Java 面试以及学习 Java 的同学加入我的<a href="https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc" target="_blank" rel="noopener noreferrer">知识星球</a>，干货非常多，学习氛围非常好！收费虽然是白菜价，但星球里的内容或许比你参加上万的培训班质量还要高。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220311203414600.png" alt=""></p>
<p>下面是星球提供的部分服务（点击下方图片即可获取知识星球的详细介绍）：</p>
<div align="center">
  <a href="https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html">
    <img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/xingqiufuwu.png" style="margin: 0 auto; ">
  </a>
</div>
<p>我有自己的原则，不割韭菜，用心做内容，真心希望帮助到你！</p>
<p>如果你感兴趣的话，不妨花 3 分钟左右看看星球的详细介绍： <a href="https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc" target="_blank" rel="noopener noreferrer">JavaGuide 知识星球详细介绍</a>（文末有优惠券）。</p>
<div align="center">
  <a href="https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html">
    <img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/xingqiuyouhuijuanheyi.png" style="margin: 0 auto; ">
  </a>
</div>]]></content:encoded>
      <enclosure url="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220304102536445.png" type="image/png"/>
    </item>
    <item>
      <title>Redis 集群详解(付费)</title>
      <link>https://javaguide.cn/database/redis/redis-cluster.html</link>
      <guid>https://javaguide.cn/database/redis/redis-cluster.html</guid>
      <source url="https://javaguide.cn/rss.xml">Redis 集群详解(付费)</source>
      <description>Redis 集群 相关的面试题为我的知识星球（点击链接即可查看详细介绍以及加入方法）专属内容，已经整理到了《Java 面试指北》（点击链接即可查看详细介绍以及获取方法）中。</description>
      <category>数据库</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<p><strong>Redis 集群</strong> 相关的面试题为我的<a href="https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc" target="_blank" rel="noopener noreferrer">知识星球</a>（点击链接即可查看详细介绍以及加入方法）专属内容，已经整理到了<a href="https://www.yuque.com/docs/share/f37fc804-bfe6-4b0d-b373-9c462188fec7" target="_blank" rel="noopener noreferrer">《Java 面试指北》</a>（点击链接即可查看详细介绍以及获取方法）中。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/redis-cluster-javamianshizhibei.png" alt=""></p>
<p><a href="https://www.yuque.com/docs/share/f37fc804-bfe6-4b0d-b373-9c462188fec7" target="_blank" rel="noopener noreferrer">《Java 面试指北》</a> 的部分内容展示如下，你可以将其看作是 <a href="https://javaguide.cn/#/" target="_blank" rel="noopener noreferrer">JavaGuide</a> 的补充完善，两者可以配合使用。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220304102536445.png" alt=""></p>
<p><a href="https://www.yuque.com/docs/share/f37fc804-bfe6-4b0d-b373-9c462188fec7" target="_blank" rel="noopener noreferrer">《Java 面试指北》</a>只是星球内部众多资料中的一个，星球还有很多其他优质资料比如<a href="https://javaguide.cn/zhuanlan/" target="_blank" rel="noopener noreferrer">专属专栏</a>、Java 编程视频、PDF 资料。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220211231206733.png" alt=""></p>
<p>最近几年，市面上有越来越多的“技术大佬”开始办培训班/训练营，动辄成千上万的学费，却并没有什么干货，单纯的就是割韭菜。</p>
<p>为了帮助更多同学准备 Java 面试以及学习 Java ，我创建了一个纯粹的<a href="https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc" target="_blank" rel="noopener noreferrer">知识星球</a>。虽然收费只有培训班/训练营的百分之一，但是<a href="https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc" target="_blank" rel="noopener noreferrer">知识星球</a>里的内容质量更高，提供的服务也更全面。</p>
<p>欢迎准备 Java 面试以及学习 Java 的同学加入我的<a href="https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc" target="_blank" rel="noopener noreferrer">知识星球</a>，干货非常多，学习氛围非常好！收费虽然是白菜价，但星球里的内容或许比你参加上万的培训班质量还要高。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/image-20220311203414600.png" alt=""></p>
<p>下面是星球提供的部分服务（点击下方图片即可获取知识星球的详细介绍）：</p>
<div align="center">
  <a href="https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html">
    <img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/xingqiufuwu.png" style="margin: 0 auto; ">
  </a>
</div>
<p>我有自己的原则，不割韭菜，用心做内容，真心希望帮助到你！</p>
<p>如果你感兴趣的话，不妨花 3 分钟左右看看星球的详细介绍： <a href="https://www.yuque.com/docs/share/8a30ffb5-83f3-40f9-baf9-38de68b906dc" target="_blank" rel="noopener noreferrer">JavaGuide 知识星球详细介绍</a>（文末有优惠券）。</p>
<div align="center">
  <a href="https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html">
    <img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/xingqiu/xingqiuyouhuijuanheyi.png" style="margin: 0 auto; ">
  </a>
</div>]]></content:encoded>
      <enclosure url="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/redis-cluster-javamianshizhibei.png" type="image/png"/>
    </item>
    <item>
      <title>Redis 5 种基本数据结构详解</title>
      <link>https://javaguide.cn/database/redis/redis-data-structures-01.html</link>
      <guid>https://javaguide.cn/database/redis/redis-data-structures-01.html</guid>
      <source url="https://javaguide.cn/rss.xml">Redis 5 种基本数据结构详解</source>
      <description>Redis 共有 5 种基本数据结构：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。 这 5 种数据结构是直接提供给用户使用的，是数据的保存形式，其底层实现主要依赖这 8 种数据结构：简单动态字符串（SDS）、LinkedList（双向链表）、Hash Table（哈希表）、SkipList（跳跃表）、Intset（整数集合）、ZipList（压缩列表）、QuickList（快速列表）。 Redis 基本数据结构的底层数据结构实现如下： String List Hash Set Zset SDS LinkedList/ZipList/QuickList Hash Table、ZipList ZipList、Intset ZipList、SkipList</description>
      <category>数据库</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<p>Redis 共有 5 种基本数据结构：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。</p>
<p>这 5 种数据结构是直接提供给用户使用的，是数据的保存形式，其底层实现主要依赖这 8 种数据结构：简单动态字符串（SDS）、LinkedList（双向链表）、Hash Table（哈希表）、SkipList（跳跃表）、Intset（整数集合）、ZipList（压缩列表）、QuickList（快速列表）。</p>
<p>Redis 基本数据结构的底层数据结构实现如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">String</th>
<th style="text-align:left">List</th>
<th style="text-align:left">Hash</th>
<th style="text-align:left">Set</th>
<th style="text-align:left">Zset</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">SDS</td>
<td style="text-align:left">LinkedList/ZipList/QuickList</td>
<td style="text-align:left">Hash Table、ZipList</td>
<td style="text-align:left">ZipList、Intset</td>
<td style="text-align:left">ZipList、SkipList</td>
</tr>
</tbody>
</table>
<p>Redis 3.2 之前，List 底层实现是 LinkedList 或者 ZipList。 Redis 3.2 之后，引入了 LinkedList 和 ZipList 的结合 QuickList，List 的底层实现变为 QuickList。</p>
<p>你可以在 Redis 官网上找到 Redis 数据结构非常详细的介绍：</p>
<ul>
<li><a href="https://redis.com/redis-enterprise/data-structures/" target="_blank" rel="noopener noreferrer">Redis Data Structures</a></li>
<li><a href="https://redis.io/docs/manual/data-types/data-types-tutorial/" target="_blank" rel="noopener noreferrer">Redis Data types tutorial</a></li>
</ul>
<p>未来随着 Redis 新版本的发布，可能会有新的数据结构出现，通过查阅 Redis 官网对应的介绍，你总能获取到最靠谱的信息。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/image-20220720181630203.png" alt=""></p>
<h2> String（字符串）</h2>
<h3> 介绍</h3>
<p>String 是 Redis 中最简单同时也是最常用的一个数据结构。</p>
<p>String 是一种二进制安全的数据结构，可以用来存储任何类型的数据比如字符串、整数、浮点数、图片（图片的 base64 编码或者解码或者图片的路径）、序列化后的对象。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/image-20220719124403897.png" alt=""></p>
<p>虽然 Redis 是用 C 语言写的，但是 Redis 并没有使用 C 的字符串表示，而是自己构建了一种 <strong>简单动态字符串</strong>（Simple Dynamic String，<strong>SDS</strong>）。相比于 C 的原生字符串，Redis 的 SDS 不光可以保存文本数据还可以保存二进制数据，并且获取字符串长度复杂度为 O(1)（C 字符串为 O(N)）,除此之外，Redis 的 SDS API 是安全的，不会造成缓冲区溢出。</p>
<h3> 常用命令</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td>SET key value</td>
<td>设置指定 key 的值</td>
</tr>
<tr>
<td>SETNX key value</td>
<td>只有在 key 不存在时设置 key 的值</td>
</tr>
<tr>
<td>GET key</td>
<td>获取指定 key 的值</td>
</tr>
<tr>
<td>MSET key1 value1 key2 value2 …</td>
<td>设置一个或多个指定 key 的值</td>
</tr>
<tr>
<td>MGET key1 key2 ...</td>
<td>获取一个或多个指定 key 的值</td>
</tr>
<tr>
<td>STRLEN key</td>
<td>返回 key 所储存的字符串值的长度</td>
</tr>
<tr>
<td>INCR key</td>
<td>将 key 中储存的数字值增一</td>
</tr>
<tr>
<td>DECR key</td>
<td>将 key 中储存的数字值减一</td>
</tr>
<tr>
<td>EXISTS key</td>
<td>判断指定 key 是否存在</td>
</tr>
<tr>
<td>DEL key（通用）</td>
<td>删除指定的 key</td>
</tr>
<tr>
<td>EXPIRE key seconds（通用）</td>
<td>给指定 key 设置过期时间</td>
</tr>
</tbody>
</table>
<p>更多 Redis String 命令以及详细使用指南，请查看 Redis 官网对应的介绍：https://redis.io/commands/?group=string 。</p>
<p><strong>基本操作</strong> ：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>批量设置</strong> ：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>计数器（字符串的内容为整数的时候可以使用）：</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>设置过期时间（默认为永不过期）</strong>：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 应用场景</h3>
<p><strong>需要存储常规数据的场景</strong></p>
<ul>
<li>举例 ：缓存 session、token、图片地址、序列化后的对象(相比较于 Hash 存储更节省内存)。</li>
<li>相关命令 ： <code>SET</code>、<code>GET</code>。</li>
</ul>
<p><strong>需要计数的场景</strong></p>
<ul>
<li>举例 ：用户单位时间的请求数（简单限流可以用到）、页面单位时间的访问数。</li>
<li>相关命令 ：<code>SET</code>、<code>GET</code>、 <code>INCR</code>、<code>DECR</code> 。</li>
</ul>
<p><strong>分布式锁</strong></p>
<p>利用 <code>SETNX key value</code> 命令可以实现一个最简易的分布式锁（存在一些缺陷，通常不建议这样实现分布式锁）。</p>
<h2> List（列表）</h2>
<h3> 介绍</h3>
<p>Redis 中的 List 其实就是链表数据结构的实现。我在 <a href="https://javaguide.cn/cs-basics/data-structure/linear-data-structure.html" target="_blank" rel="noopener noreferrer">线性数据结构 :数组、链表、栈、队列</a> 这篇文章中详细介绍了链表这种数据结构，我这里就不多做介绍了。</p>
<p>许多高级编程语言都内置了链表的实现比如 Java 中的 <code>LinkedList</code>，但是 C 语言并没有实现链表，所以 Redis 实现了自己的链表数据结构。Redis 的 List 的实现为一个 <strong>双向链表</strong>，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/image-20220719124413287.png" alt=""></p>
<h3> 常用命令</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td>RPUSH key value1 value2 ...</td>
<td>在指定列表的尾部（右边）添加一个或多个元素</td>
</tr>
<tr>
<td>LPUSH key value1 value2 ...</td>
<td>在指定列表的头部（左边）添加一个或多个元素</td>
</tr>
<tr>
<td>LSET key index value</td>
<td>将指定列表索引 index 位置的值设置为 value</td>
</tr>
<tr>
<td>LPOP key</td>
<td>移除并获取指定列表的第一个元素(最左边)</td>
</tr>
<tr>
<td>RPOP key</td>
<td>移除并获取指定列表的最后一个元素(最右边)</td>
</tr>
<tr>
<td>LLEN key</td>
<td>获取列表元素数量</td>
</tr>
<tr>
<td>LRANGE key start end</td>
<td>获取列表 start 和 end 之间 的元素</td>
</tr>
</tbody>
</table>
<p>更多 Redis List 命令以及详细使用指南，请查看 Redis 官网对应的介绍：https://redis.io/commands/?group=list 。</p>
<p><strong>通过 <code>RPUSH/LPOP</code> 或者 <code>LPUSH/RPOP</code>实现队列</strong> ：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>通过 <code>RPUSH/RPOP</code>或者<code>LPUSH/LPOP</code> 实现栈</strong> ：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我专门画了一个图方便大家理解 <code>RPUSH</code> , <code>LPOP</code> , <code>lpush</code> , <code>RPOP</code> 命令：</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/redis-list.png" alt=""></p>
<p><strong>通过 <code>LRANGE</code> 查看对应下标范围的列表元素</strong> ：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过 <code>LRANGE</code> 命令，你可以基于 List 实现分页查询，性能非常高！</p>
<p><strong>通过 <code>LLEN</code> 查看链表长度</strong> ：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 应用场景</h3>
<p><strong>信息流展示</strong></p>
<ul>
<li>举例 ：最新文章、最新动态。</li>
<li>相关命令 ： <code>LPUSH</code>、<code>LRANGE</code>。</li>
</ul>
<p><strong>消息队列</strong></p>
<p>Redis List 数据结构可以用来做消息队列，只是功能过于简单且存在很多缺陷，不建议这样做。</p>
<p>相对来说，Redis 5.0 新增加的一个数据结构 <code>Stream</code> 更适合做消息队列一些，只是功能依然非常简陋。和专业的消息队列相比，还是有很多欠缺的地方比如消息丢失和堆积问题不好解决。</p>
<h2> Hash（哈希）</h2>
<h3> 介绍</h3>
<p>Redis 中的 Hash 是一个 String 类型的 field-value（键值对） 的映射表，特别适合用于存储对象，后续操作的时候，你可以直接修改这个对象中的某些字段的值。</p>
<p>Hash 类似于 JDK1.8 前的 <code>HashMap</code>，内部实现也差不多(数组 + 链表)。不过，Redis 的 Hash 做了更多优化。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/image-20220719124421703.png" alt=""></p>
<h3> 常用命令</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td>HSET key field value</td>
<td>设置指定哈希表中指定字段的值</td>
</tr>
<tr>
<td>HSETNX key field value</td>
<td>只有指定字段不存在时设置指定字段的值</td>
</tr>
<tr>
<td>HMSET key field1 value1 field2 value2 ...</td>
<td>同时将一个或多个 field-value (域-值)对设置到指定哈希表中</td>
</tr>
<tr>
<td>HGET key field</td>
<td>获取指定哈希表中指定字段的值</td>
</tr>
<tr>
<td>HMGET key field1 field2 ...</td>
<td>获取指定哈希表中一个或者多个指定字段的值</td>
</tr>
<tr>
<td>HGETALL key</td>
<td>获取指定哈希表中所有的键值对</td>
</tr>
<tr>
<td>HEXISTS key field</td>
<td>查看指定哈希表中指定的字段是否存在</td>
</tr>
<tr>
<td>HDEL key field1 field2 ...</td>
<td>删除一个或多个哈希表字段</td>
</tr>
<tr>
<td>HLEN key</td>
<td>获取指定哈希表中字段的数量</td>
</tr>
<tr>
<td>HINCRBY key field increment</td>
<td>对指定哈希中的指定字段做运算操作（正数为加，负数为减）</td>
</tr>
</tbody>
</table>
<p>更多 Redis Hash 命令以及详细使用指南，请查看 Redis 官网对应的介绍：https://redis.io/commands/?group=hash 。</p>
<p><strong>模拟对象数据存储</strong> ：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 应用场景</h3>
<p><strong>对象数据存储场景</strong></p>
<ul>
<li>举例 ：用户信息、商品信息、文章信息、购物车信息。</li>
<li>相关命令 ：<code>HSET</code> （设置单个字段的值）、<code>HMSET</code>（设置多个字段的值）、<code>HGET</code>（获取单个字段的值）、<code>HMGET</code>（获取多个字段的值）。</li>
</ul>
<h2> Set（集合）</h2>
<h3> 介绍</h3>
<p>Redis 中的 Set 类型是一种无序集合，集合中的元素没有先后顺序但都唯一，有点类似于 Java 中的 <code>HashSet</code> 。当你需要存储一个列表数据，又不希望出现重复数据时，Set 是一个很好的选择，并且 Set 提供了判断某个元素是否在一个 Set 集合内的重要接口，这个也是 List 所不能提供的。</p>
<p>你可以基于 Set 轻易实现交集、并集、差集的操作，比如你可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。这样的话，Set 可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/image-20220719124430264.png" alt=""></p>
<h3> 常用命令</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td>SADD key member1 member2 ...</td>
<td>向指定集合添加一个或多个元素</td>
</tr>
<tr>
<td>SMEMBERS key</td>
<td>获取指定集合中的所有元素</td>
</tr>
<tr>
<td>SCARD key</td>
<td>获取指定集合的元素数量</td>
</tr>
<tr>
<td>SISMEMBER key member</td>
<td>判断指定元素是否在指定集合中</td>
</tr>
<tr>
<td>SINTER key1 key2 ...</td>
<td>获取给定所有集合的交集</td>
</tr>
<tr>
<td>SINTERSTORE destination key1 key2 ...</td>
<td>将给定所有集合的交集存储在 destination 中</td>
</tr>
<tr>
<td>SUNION key1 key2 ...</td>
<td>获取给定所有集合的并集</td>
</tr>
<tr>
<td>SUNIONSTORE destination key1 key2 ...</td>
<td>将给定所有集合的并集存储在 destination 中</td>
</tr>
<tr>
<td>SDIFF key1 key2 ...</td>
<td>获取给定所有集合的差集</td>
</tr>
<tr>
<td>SDIFFSTORE destination key1 key2 ...</td>
<td>将给定所有集合的差集存储在 destination 中</td>
</tr>
<tr>
<td>SPOP key count</td>
<td>随机移除并获取指定集合中一个或多个元素</td>
</tr>
<tr>
<td>SRANDMEMBER key count</td>
<td>随机获取指定集合中指定数量的元素</td>
</tr>
</tbody>
</table>
<p>更多 Redis Set 命令以及详细使用指南，请查看 Redis 官网对应的介绍：https://redis.io/commands/?group=set 。</p>
<p><strong>基本操作</strong> ：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li><code>mySet</code> : <code>value1</code>、<code>value2</code> 。</li>
<li><code>mySet2</code> ： <code>value2</code> 、<code>value3</code> 。</li>
</ul>
<p><strong>求交集</strong> ：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>求并集</strong> ：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>求差集</strong> ：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3> 应用场景</h3>
<p><strong>需要存放的数据不能重复的场景</strong></p>
<ul>
<li>举例：网站 UV 统计（数据量巨大的场景还是 <code>HyperLogLog</code>更适合一些）、文章点赞、动态点赞等场景。</li>
<li>相关命令：<code>SCARD</code>（获取集合数量） 。</li>
</ul>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/image-20220719073733851.png" alt=""></p>
<p><strong>需要获取多个数据源交集、并集和差集的场景</strong></p>
<ul>
<li>举例 ：共同好友(交集)、共同粉丝(交集)、共同关注(交集)、好友推荐（差集）、音乐推荐（差集） 、订阅号推荐（差集+交集） 等场景。</li>
<li>相关命令：<code>SINTER</code>（交集）、<code>SINTERSTORE</code> （交集）、<code>SUNION</code> （并集）、<code>SUNIONSTORE</code>（并集）、<code>SDIFF</code>（差集）、<code>SDIFFSTORE</code> （差集）。</li>
</ul>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/image-20220719074543513.png" alt=""></p>
<p><strong>需要随机获取数据源中的元素的场景</strong></p>
<ul>
<li>举例 ：抽奖系统、随机。</li>
<li>相关命令：<code>SPOP</code>（随机获取集合中的元素并移除，适合不允许重复中奖的场景）、<code>SRANDMEMBER</code>（随机获取集合中的元素，适合允许重复中奖的场景）。</li>
</ul>
<h2> Sorted Set（有序集合）</h2>
<h3> 介绍</h3>
<p>Sorted Set 类似于 Set，但和 Set 相比，Sorted Set 增加了一个权重参数 <code>score</code>，使得集合中的元素能够按 <code>score</code> 进行有序排列，还可以通过 <code>score</code> 的范围来获取元素的列表。有点像是 Java 中 <code>HashMap</code> 和 <code>TreeSet</code> 的结合体。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/image-20220719124437791.png" alt=""></p>
<h3> 常用命令</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td>ZADD key score1 member1 score2 member2 ...</td>
<td>向指定有序集合添加一个或多个元素</td>
</tr>
<tr>
<td>ZCARD KEY</td>
<td>获取指定有序集合的元素数量</td>
</tr>
<tr>
<td>ZSCORE key member</td>
<td>获取指定有序集合中指定元素的 score 值</td>
</tr>
<tr>
<td>ZINTERSTORE destination numkeys key1 key2 ...</td>
<td>将给定所有有序集合的交集存储在 destination 中，对相同元素对应的 score 值进行 SUM 聚合操作，numkeys 为集合数量</td>
</tr>
<tr>
<td>ZUNIONSTORE destination numkeys key1 key2 ...</td>
<td>求并集，其它和 ZINTERSTORE 类似</td>
</tr>
<tr>
<td>ZDIFF destination numkeys key1 key2 ...</td>
<td>求差集，其它和 ZINTERSTORE 类似</td>
</tr>
<tr>
<td>ZRANGE key start end</td>
<td>获取指定有序集合 start 和 end 之间的元素（score 从低到高）</td>
</tr>
<tr>
<td>ZREVRANGE key start end</td>
<td>获取指定有序集合 start 和 end 之间的元素（score 从高到底）</td>
</tr>
<tr>
<td>ZREVRANK key member</td>
<td>获取指定有序集合中指定元素的排名(score 从大到小排序)</td>
</tr>
</tbody>
</table>
<p>更多 Redis Sorted Set 命令以及详细使用指南，请查看 Redis 官网对应的介绍：https://redis.io/commands/?group=sorted-set 。</p>
<p><strong>基本操作</strong> ：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li><code>myZset</code> : <code>value1</code>(2.0)、<code>value2</code>(1.0) 。</li>
<li><code>myZset2</code> ： <code>value2</code> （4.0）、<code>value3</code>(3.0) 。</li>
</ul>
<p><strong>获取指定元素的排名</strong> ：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>求交集</strong> ：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>求并集</strong> ：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>求差集</strong> ：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 应用场景</h3>
<p><strong>需要随机获取数据源中的元素根据某个权重进行排序的场景</strong></p>
<ul>
<li>举例 ：各种排行榜比如直播间送礼物的排行榜、朋友圈的微信步数排行榜、王者荣耀中的段位排行榜、话题热度排行榜等等。</li>
<li>相关命令 ：<code>ZRANGE</code> (从小到大排序) 、 <code>ZREVRANGE</code> （从大到小排序）、<code>ZREVRANK</code> (指定元素排名)。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/2021060714195385.png" alt=""></p>
<p><a href="https://www.yuque.com/docs/share/f37fc804-bfe6-4b0d-b373-9c462188fec7" target="_blank" rel="noopener noreferrer">《Java 面试指北》</a> 的「技术面试题篇」就有一篇文章详细介绍如何使用 Sorted Set 来设计制作一个排行榜。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/image-20220719071115140.png" alt=""></p>
<p><strong>需要存储的数据有优先级或者重要程度的场景</strong> 比如优先级任务队列。</p>
<ul>
<li>举例 ：优先级任务队列。</li>
<li>相关命令 ：<code>ZRANGE</code> (从小到大排序) 、 <code>ZREVRANGE</code> （从大到小排序）、<code>ZREVRANK</code> (指定元素排名)。</li>
</ul>
<h2> 参考</h2>
<ul>
<li>Redis Data Structures ：https://redis.com/redis-enterprise/data-structures/ 。</li>
<li>Redis Commands ： https://redis.io/commands/ 。</li>
<li>Redis Data types tutorial：https://redis.io/docs/manual/data-types/data-types-tutorial/ 。</li>
<li>Redis 存储对象信息是用 Hash 还是 String : https://segmentfault.com/a/1190000040032006</li>
</ul>
]]></content:encoded>
      <enclosure url="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/image-20220720181630203.png" type="image/png"/>
    </item>
    <item>
      <title>Redis 3 种特殊数据结构详解</title>
      <link>https://javaguide.cn/database/redis/redis-data-structures-02.html</link>
      <guid>https://javaguide.cn/database/redis/redis-data-structures-02.html</guid>
      <source url="https://javaguide.cn/rss.xml">Redis 3 种特殊数据结构详解</source>
      <description>除了 5 种基本的数据结构之外，Redis 还支持 3 种特殊的数据结构 ：Bitmap、HyperLogLog、GEO。 Bitmap 介绍 Bitmap 存储的是连续的二进制数字（0 和 1），通过 Bitmap, 只需要一个 bit 位来表示某个元素对应的值或者状态，key 就是对应元素本身 。我们知道 8 个 bit 可以组成一个 byte，所以 Bitmap 本身会极大的节省储存空间。 你可以将 Bitmap 看作是一个存储二进制数字（0 和 1）的数组，数组中每个元素的下标叫做 offset（偏移量）。</description>
      <category>数据库</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<p>除了 5 种基本的数据结构之外，Redis 还支持 3 种特殊的数据结构 ：Bitmap、HyperLogLog、GEO。</p>
<h2> Bitmap</h2>
<h3> 介绍</h3>
<p>Bitmap 存储的是连续的二进制数字（0 和 1），通过 Bitmap, 只需要一个 bit 位来表示某个元素对应的值或者状态，key 就是对应元素本身 。我们知道 8 个 bit 可以组成一个 byte，所以 Bitmap 本身会极大的节省储存空间。</p>
<p>你可以将 Bitmap 看作是一个存储二进制数字（0 和 1）的数组，数组中每个元素的下标叫做 offset（偏移量）。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/image-20220720194154133.png" alt=""></p>
<h3> 常用命令</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td>SETBIT key offset value</td>
<td>设置指定 offset 位置的值</td>
</tr>
<tr>
<td>GETBIT key offset</td>
<td>获取指定 offset 位置的值</td>
</tr>
<tr>
<td>BITCOUNT key start end</td>
<td>获取 start 和 end 之前值为 1 的元素个数</td>
</tr>
<tr>
<td>BITOP operation destkey key1 key2 ...</td>
<td>对一个或多个 Bitmap 进行运算，可用运算符有 AND, OR, XOR 以及 NOT</td>
</tr>
</tbody>
</table>
<p><strong>Bitmap 基本操作演示</strong> ：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 应用场景</h3>
<p><strong>需要保存状态信息（0/1 即可表示）的场景</strong></p>
<ul>
<li>举例 ：用户签到情况、活跃用户情况、用户行为统计（比如是否点赞过某个视频）。</li>
<li>相关命令 ：<code>SETBIT</code>、<code>GETBIT</code>、<code>BITCOUNT</code>、<code>BITOP</code>。</li>
</ul>
<h2> HyperLogLog</h2>
<h3> 介绍</h3>
<p>HyperLogLog 是一种有名的基数计数概率算法 ，基于 LogLog Counting(LLC)优化改进得来，并不是 Redis 特有的，Redis 只是实现了这个算法并提供了一些开箱即用的 API。</p>
<p>Redis 提供的 HyperLogLog 占用空间非常非常小，只需要 12k 的空间就能存储接近<code>2^64</code>个不同元素。这是真的厉害，这就是数学的魅力么！并且，Redis 对 HyperLogLog 的存储结构做了优化，采用两种方式计数：</p>
<ul>
<li><strong>稀疏矩阵</strong> ：计数较少的时候，占用空间很小。</li>
<li><strong>稠密矩阵</strong> ：计数达到某个阈值的时候，占用 12k 的空间。</li>
</ul>
<p>Redis 官方文档中有对应的详细说明：</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/image-20220721091424563.png" alt=""></p>
<p>基数计数概率算法为了节省内存并不会直接存储元数据，而是通过一定的概率统计方法预估基数值（集合中包含元素的个数）。因此， HyperLogLog 的计数结果并不是一个精确值，存在一定的误差（标准误差为 <code>0.81%</code> 。）。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/image-20220720194154133.png" alt=""></p>
<p>HyperLogLog 的使用非常简单，但原理非常复杂。HyperLogLog 的原理以及在 Redis 中的实现可以看这篇文章：<a href="https://juejin.cn/post/6844903785744056333" target="_blank" rel="noopener noreferrer">HyperLogLog 算法的原理讲解以及 Redis 是如何应用它的</a> 。</p>
<p>再推荐一个可以帮助理解 HyperLogLog 原理的工具：<a href="http://content.research.neustar.biz/blog/hll.html" target="_blank" rel="noopener noreferrer">Sketch of the Day: HyperLogLog — Cornerstone of a Big Data Infrastructure</a> 。</p>
<h3> 常用命令</h3>
<p>HyperLogLog 相关的命令非常少，最常用的也就 3 个。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td>PFADD key element1 element2 ...</td>
<td>添加一个或多个元素到 HyperLogLog 中</td>
</tr>
<tr>
<td>PFCOUNT key1 key2</td>
<td>获取一个或者多个 HyperLogLog 的唯一计数。</td>
</tr>
<tr>
<td>PFMERGE destkey sourcekey1 sourcekey2 ...</td>
<td>将多个 HyperLogLog 合并到 destkey 中，destkey 会结合多个源，算出对应的唯一计数。</td>
</tr>
</tbody>
</table>
<p><strong>HyperLogLog 基本操作演示</strong> ：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 应用场景</h3>
<p><strong>数量量巨大（百万、千万级别以上）的计数场景</strong></p>
<ul>
<li>举例 ：热门网站每日/每周/每月访问 ip 数统计、热门帖子 uv 统计、</li>
<li>相关命令 ：<code>PFADD</code>、<code>PFCOUNT</code> 。</li>
</ul>
<h2> Geospatial index</h2>
<h3> 介绍</h3>
<p>Geospatial index（地理空间索引，简称 GEO） 主要用于存储地理位置信息，基于 Sorted Set 实现。</p>
<p>通过 GEO 我们可以轻松实现两个位置距离的计算、获取指定位置附近的元素等功能。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/image-20220720194359494.png" alt=""></p>
<h3> 常用命令</h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td>GEOADD key longitude1 latitude1 member1 ...</td>
<td>添加一个或多个元素对应的经纬度信息到 GEO 中</td>
</tr>
<tr>
<td>GEOPOS key member1 member2 ...</td>
<td>返回给定元素的经纬度信息</td>
</tr>
<tr>
<td>GEODIST key member1 member2 M/KM/FT/MI</td>
<td>返回两个给定元素之间的距离</td>
</tr>
<tr>
<td>GEORADIUS key longitude latitude radius distance</td>
<td>获取指定位置附近 distance 范围内的其他元素，支持 ASC(由近到远)、DESC（由远到近）、Count(数量) 等参数</td>
</tr>
<tr>
<td>GEORADIUSBYMEMBER key member radius distance</td>
<td>类似于 GEORADIUS 命令，只是参照的中心点是 GEO 中的元素</td>
</tr>
</tbody>
</table>
<p><strong>基本操作</strong> ：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过 Redis 可视化工具查看 <code>personLocation</code> ，果不其然，底层就是 Sorted Set。</p>
<p>GEO 中存储的地理位置信息的经纬度数据通过 GeoHash 算法转换成了一个整数，这个整数作为 Sorted Set 的 score(权重参数)使用。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/image-20220721201545147.png" alt=""></p>
<p><strong>获取指定位置范围内的其他元素</strong> ：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>GEORADIUS</code> 命令的底层原理解析可以看看阿里的这篇文章：<a href="https://juejin.cn/post/6844903966061363207" target="_blank" rel="noopener noreferrer">Redis 到底是怎么实现“附近的人”这个功能的呢？</a> 。</p>
<p><strong>移除元素</strong> ：</p>
<p>GEO 底层是 Sorted Set ，你可以对 GEO 使用 Sorted Set 相关的命令。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 应用场景</h3>
<p><strong>需要管理使用地理空间数据的场景</strong></p>
<ul>
<li>举例：附近的人。</li>
<li>相关命令: <code>GEOADD</code>、<code>GEORADIUS</code>、<code>GEORADIUSBYMEMBER</code> 。</li>
</ul>
<h2> 参考</h2>
<ul>
<li>Redis Data Structures ：https://redis.com/redis-enterprise/data-structures/ 。</li>
<li>《Redis 深度历险：核心原理与应用实践》1.6 四两拨千斤——HyperLogLog</li>
<li>布隆过滤器,位图,HyperLogLog：https://hogwartsrico.github.io/2020/06/08/BloomFilter-HyperLogLog-BitMap/index.html</li>
</ul>
]]></content:encoded>
      <enclosure url="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/image-20220720194154133.png" type="image/png"/>
    </item>
    <item>
      <title>Redis 内存碎片详解</title>
      <link>https://javaguide.cn/database/redis/redis-memory-fragmentation.html</link>
      <guid>https://javaguide.cn/database/redis/redis-memory-fragmentation.html</guid>
      <source url="https://javaguide.cn/rss.xml">Redis 内存碎片详解</source>
      <description>什么是内存碎片? 你可以将内存碎片简单地理解为那些不可用的空闲内存。 举个例子：操作系统为你分配了 32 字节的连续内存空间，而你存储数据实际只需要使用 24 字节内存空间，那这多余出来的 8 字节内存空间如果后续没办法再被分配存储其他数据的话，就可以被称为内存碎片。 Redis 内存碎片虽然不会影响 Redis 性能，但是会增加内存消耗。</description>
      <category>数据库</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 什么是内存碎片?</h2>
<p>你可以将内存碎片简单地理解为那些不可用的空闲内存。</p>
<p>举个例子：操作系统为你分配了 32 字节的连续内存空间，而你存储数据实际只需要使用 24 字节内存空间，那这多余出来的 8 字节内存空间如果后续没办法再被分配存储其他数据的话，就可以被称为内存碎片。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/memory-fragmentation.png" alt="内存碎片"></p>
<p>Redis 内存碎片虽然不会影响 Redis 性能，但是会增加内存消耗。</p>
<h2> 为什么会有 Redis 内存碎片?</h2>
<p>Redis 内存碎片产生比较常见的 2 个原因：</p>
<p><strong>1、Redis 存储存储数据的时候向操作系统申请的内存空间可能会大于数据实际需要的存储空间。</strong></p>
<p>以下是这段 Redis 官方的原话：</p>
<blockquote>
<p>To store user keys, Redis allocates at most as much memory as the <code>maxmemory</code> setting enables (however there are small extra allocations possible).</p>
</blockquote>
<p>Redis 使用 <code>zmalloc</code> 方法(Redis 自己实现的内存分配方法)进行内存分配的时候，除了要分配 <code>size</code> 大小的内存之外，还会多分配 <code>PREFIX_SIZE</code> 大小的内存。</p>
<p><code>zmalloc</code> 方法源码如下（源码地址：https://github.com/antirez/redis-tools/blob/master/zmalloc.c）：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>另外，Redis 可以使用多种内存分配器来分配内存（ libc、jemalloc、tcmalloc），默认使用 <a href="https://github.com/jemalloc/jemalloc" target="_blank" rel="noopener noreferrer">jemalloc</a>，而 jemalloc 按照一系列固定的大小（8 字节、16 字节、32 字节......）来分配内存的。jemalloc 划分的内存单元如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/6803d3929e3e46c1b1c9d0bb9ee8e717.png" alt="jemalloc 内存单元示意图"></p>
<p>当程序申请的内存最接近某个固定值时，jemalloc 会给它分配相应大小的空间，就比如说程序需要申请 17 字节的内存，jemalloc 会直接给它分配 32 字节的内存，这样会导致有 15 字节内存的浪费。不过，jemalloc 专门针对内存碎片问题做了优化，一般不会存在过度碎片化的问题。</p>
<p><strong>2、频繁修改 Redis 中的数据也会产生内存碎片。</strong></p>
<p>当 Redis 中的某个数据删除时，Redis 通常不会轻易释放内存给操作系统。</p>
<p>这个在 Redis 官方文档中也有对应的原话:</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/redis-docs-memory-optimization.png" alt=""></p>
<p>文档地址：https://redis.io/topics/memory-optimization 。</p>
<h2> 如何查看 Redis 内存碎片的信息？</h2>
<p>使用 <code>info memory</code> 命令即可查看 Redis 内存相关的信息。下图中每个参数具体的含义，Redis 官方文档有详细的介绍：https://redis.io/commands/INFO 。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/redis-info-memory.png" alt=""></p>
<p>Redis 内存碎片率的计算公式：<code>mem_fragmentation_ratio</code> （内存碎片率）= <code>used_memory_rss</code> (操作系统实际分配给 Redis 的物理内存空间大小)/ <code>used_memory</code>(Redis 内存分配器为了存储数据实际申请使用的内存空间大小)</p>
<p>也就是说，<code>mem_fragmentation_ratio</code> （内存碎片率）的值越大代表内存碎片率越严重。</p>
<p>一定不要误认为<code>used_memory_rss</code> 减去 <code>used_memory</code>值就是内存碎片的大小！！！这不仅包括内存碎片，还包括其他进程开销，以及共享库、堆栈等的开销。</p>
<p>很多小伙伴可能要问了：“多大的内存碎片率才是需要清理呢？”。</p>
<p>通常情况下，我们认为 <code>mem_fragmentation_ratio &gt; 1.5</code> 的话才需要清理内存碎片。 <code>mem_fragmentation_ratio &gt; 1.5</code> 意味着你使用 Redis 存储实际大小 2G 的数据需要使用大于 3G 的内存。</p>
<p>如果想要快速查看内存碎片率的话，你还可以通过下面这个命令：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>另外，内存碎片率可能存在小于 1 的情况。这种情况我在日常使用中还没有遇到过，感兴趣的小伙伴可以看看这篇文章 <a href="https://mp.weixin.qq.com/s/drlDvp7bfq5jt2M5pTqJCw" target="_blank" rel="noopener noreferrer">故障分析 | Redis 内存碎片率太低该怎么办？- 爱可生开源社区</a> 。</p>
<h2> 如何清理 Redis 内存碎片？</h2>
<p>Redis4.0-RC3 版本以后自带了内存整理，可以避免内存碎片率过大的问题。</p>
<p>直接通过 <code>config set</code> 命令将 <code>activedefrag</code> 配置项设置为 <code>yes</code> 即可。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>具体什么时候清理需要通过下面两个参数控制：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过 Redis 自动内存碎片清理机制可能会对 Redis 的性能产生影响，我们可以通过下面两个参数来减少对 Redis 性能的影响：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>另外，重启节点可以做到内存碎片重新整理。如果你采用的是高可用架构的 Redis 集群的话，你可以将碎片率过高的主节点转换为从节点，以便进行安全重启。</p>
<h2> 参考</h2>
<ul>
<li>Redis 官方文档：https://redis.io/topics/memory-optimization</li>
<li>Redis 核心技术与实战 - 极客时间 - 删除数据后，为什么内存占用率还是很高？：https://time.geekbang.org/column/article/289140</li>
<li>Redis 源码解析——内存分配：https://shinerio.cc/2020/05/17/redis/Redis%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E2%80%94%E2%80%94%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</li>
</ul>
]]></content:encoded>
      <enclosure url="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/memory-fragmentation.png" type="image/png"/>
    </item>
    <item>
      <title>Redis常见面试题总结(上)</title>
      <link>https://javaguide.cn/database/redis/redis-questions-01.html</link>
      <guid>https://javaguide.cn/database/redis/redis-questions-01.html</guid>
      <source url="https://javaguide.cn/rss.xml">Redis常见面试题总结(上)</source>
      <description>Redis 基础 什么是 Redis？ Redis 是一个基于 C 语言开发的开源数据库（BSD 许可），与传统数据库不同的是 Redis 的数据是存在内存中的（内存数据库），读写速度非常快，被广泛应用于缓存方向。并且，Redis 存储的是 KV 键值对数据。 为了满足不同的业务场景，Redis 内置了多种数据类型实现（比如 String、Hash、Sorted Set、Bitmap）。并且，Redis 还支持事务 、持久化、Lua 脚本、多种开箱即用的集群方案（Redis Sentinel、Redis Cluster）。</description>
      <category>数据库</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<h2> Redis 基础</h2>
<h3> 什么是 Redis？</h3>
<p><a href="https://redis.io/" target="_blank" rel="noopener noreferrer">Redis</a> 是一个基于 C 语言开发的开源数据库（BSD 许可），与传统数据库不同的是 Redis 的数据是存在内存中的（内存数据库），读写速度非常快，被广泛应用于缓存方向。并且，Redis 存储的是 KV 键值对数据。</p>
<p>为了满足不同的业务场景，Redis 内置了多种数据类型实现（比如 String、Hash、Sorted Set、Bitmap）。并且，Redis 还支持事务 、持久化、Lua 脚本、多种开箱即用的集群方案（Redis Sentinel、Redis Cluster）。</p>
<p>Redis 没有外部依赖，Linux 和 OS X 是 Redis 开发和测试最多的两个操作系统，官方推荐生产环境使用 Linux 部署 Redis。</p>
<p>个人学习的话，你可以自己本机安装 Redis 或者通过 Redis 官网提供的<a href="https://try.redis.io/" target="_blank" rel="noopener noreferrer">在线 Redis 环境</a>来实际体验 Redis。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/try.redis.io.png" alt="try-redis"></p>
<p>全世界有非常多的网站使用到了 Redis ，<a href="https://techstacks.io/" target="_blank" rel="noopener noreferrer">techstacks.io</a> 专门维护了一个<a href="https://techstacks.io/tech/redis" target="_blank" rel="noopener noreferrer">使用 Redis 的热门站点列表</a> ，感兴趣的话可以看看。</p>
<h3> Redis 为什么这么快？</h3>
<p>Redis 内部做了非常多的性能优化，比较重要的主要有下面 3 点：</p>
<ul>
<li>Redis 基于内存，内存的访问速度是磁盘的上千倍；</li>
<li>Redis 基于 Reactor 模式设计开发了一套高效的事件处理模型，主要是单线程事件循环和 IO 多路复用（Redis 线程模式后面会详细介绍到）；</li>
<li>Redis 内置了多种优化过后的数据结构实现，性能非常高。</li>
</ul>
<p>下面这张图片总结的挺不错的，分享一下，出自 <a href="https://twitter.com/alexxubyte/status/1498703822528544770" target="_blank" rel="noopener noreferrer">Why is Redis so fast?</a> 。</p>
<p></p>
<h3> 分布式缓存常见的技术选型方案有哪些？</h3>
<p>分布式缓存的话，比较老牌同时也是使用的比较多的还是 <strong>Memcached</strong> 和 <strong>Redis</strong>。不过，现在基本没有看过还有项目使用 <strong>Memcached</strong> 来做缓存，都是直接用 <strong>Redis</strong>。</p>
<p>Memcached 是分布式缓存最开始兴起的那会，比较常用的。后来，随着 Redis 的发展，大家慢慢都转而使用更加强大的 Redis 了。</p>
<p>另外，腾讯也开源了一款类似于 Redis 的分布式高性能 KV 存储数据库，基于知名的开源项目 <a href="https://github.com/facebook/rocksdb" target="_blank" rel="noopener noreferrer">RocksDB</a> 作为存储引擎 ，100% 兼容 Redis 协议和 Redis4.0 所有数据模型，名为 <a href="https://github.com/Tencent/Tendis" target="_blank" rel="noopener noreferrer">Tendis</a>。</p>
<p>关于 Redis 和 Tendis 的对比，腾讯官方曾经发过一篇文章：<a href="https://mp.weixin.qq.com/s/MeYkfOIdnU6LYlsGb24KjQ" target="_blank" rel="noopener noreferrer">Redis vs Tendis：冷热混合存储版架构揭秘</a> ，可以简单参考一下。</p>
<p>从这个项目的 Github 提交记录可以看出，Tendis 开源版几乎已经没有被维护更新了，加上其关注度并不高，使用的公司也比较少。因此，不建议你使用 Tendis 来实现分布式缓存。</p>
<h3> 说一下 Redis 和 Memcached 的区别和共同点</h3>
<p>现在公司一般都是用 Redis 来实现缓存，而且 Redis 自身也越来越强大了！不过，了解 Redis 和 Memcached 的区别和共同点，有助于我们在做相应的技术选型的时候，能够做到有理有据！</p>
<p><strong>共同点</strong> ：</p>
<ol>
<li>都是基于内存的数据库，一般都用来当做缓存使用。</li>
<li>都有过期策略。</li>
<li>两者的性能都非常高。</li>
</ol>
<p><strong>区别</strong> ：</p>
<ol>
<li><strong>Redis 支持更丰富的数据类型（支持更复杂的应用场景）</strong>。Redis 不仅仅支持简单的 k/v 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。Memcached 只支持最简单的 k/v 数据类型。</li>
<li><strong>Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而 Memcached 把数据全部存在内存之中。</strong></li>
<li><strong>Redis 有灾难恢复机制。</strong> 因为可以把缓存中的数据持久化到磁盘上。</li>
<li><strong>Redis 在服务器内存使用完之后，可以将不用的数据放到磁盘上。但是，Memcached 在服务器内存使用完之后，就会直接报异常。</strong></li>
<li><strong>Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 Redis 目前是原生支持 cluster 模式的。</strong></li>
<li><strong>Memcached 是多线程，非阻塞 IO 复用的网络模型；Redis 使用单线程的多路 IO 复用模型。</strong> （Redis 6.0 引入了多线程 IO ）</li>
<li><strong>Redis 支持发布订阅模型、Lua 脚本、事务等功能，而 Memcached 不支持。并且，Redis 支持更多的编程语言。</strong></li>
<li><strong>Memcached 过期数据的删除策略只用了惰性删除，而 Redis 同时使用了惰性删除与定期删除。</strong></li>
</ol>
<p>相信看了上面的对比之后，我们已经没有什么理由可以选择使用 Memcached 来作为自己项目的分布式缓存了。</p>
<h3> 为什么要用 Redis/为什么要用缓存？</h3>
<p>下面我们主要从“高性能”和“高并发”这两点来回答这个问题。</p>
<p><strong>高性能</strong></p>
<p>假如用户第一次访问数据库中的某些数据的话，这个过程是比较慢，毕竟是从硬盘中读取的。但是，如果说，用户访问的数据属于高频数据并且不会经常改变的话，那么我们就可以很放心地将该用户访问的数据存在缓存中。</p>
<p><strong>这样有什么好处呢？</strong> 那就是保证用户下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。</p>
<p><strong>高并发</strong></p>
<p>一般像 MySQL 这类的数据库的 QPS 大概都在 1w 左右（4 核 8g） ，但是使用 Redis 缓存之后很容易达到 10w+，甚至最高能达到 30w+（就单机 Redis 的情况，Redis 集群的话会更高）。</p>
<blockquote>
<p>QPS（Query Per Second）：服务器每秒可以执行的查询次数；</p>
</blockquote>
<p>由此可见，直接操作缓存能够承受的数据库请求数量是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。进而，我们也就提高了系统整体的并发。</p>
<h3> Redis 除了做缓存，还能做什么？</h3>
<ul>
<li><strong>分布式锁</strong> ： 通过 Redis 来做分布式锁是一种比较常见的方式。通常情况下，我们都是基于 Redisson 来实现分布式锁。关于 Redis 实现分布式锁的详细介绍，可以看我写的这篇文章：<a href="https://javaguide.cn/distributed-system/distributed-lock.html" target="_blank" rel="noopener noreferrer">分布式锁详解</a> 。</li>
<li><strong>限流</strong> ：一般是通过 Redis + Lua 脚本的方式来实现限流。相关阅读：<a href="https://mp.weixin.qq.com/s/kyFAWH3mVNJvurQDt4vchA" target="_blank" rel="noopener noreferrer">《我司用了 6 年的 Redis 分布式限流器，可以说是非常厉害了！》</a>。</li>
<li><strong>消息队列</strong> ：Redis 自带的 list 数据结构可以作为一个简单的队列使用。Redis 5.0 中增加的 Stream 类型的数据结构更加适合用来做消息队列。它比较类似于 Kafka，有主题和消费组的概念，支持消息持久化以及 ACK 机制。</li>
<li><strong>复杂业务场景</strong> ：通过 Redis 以及 Redis 扩展（比如 Redisson）提供的数据结构，我们可以很方便地完成很多复杂的业务场景比如通过 bitmap 统计活跃用户、通过 sorted set 维护排行榜。</li>
<li>......</li>
</ul>
<h3> Redis 可以做消息队列么？</h3>
<p>Redis 5.0 新增加的一个数据结构 <code>Stream</code> 可以用来做消息队列，<code>Stream</code> 支持：</p>
<ul>
<li>发布 / 订阅模式</li>
<li>按照消费者组进行消费</li>
<li>消息持久化（ RDB 和 AOF）</li>
</ul>
<p>不过，和专业的消息队列相比，还是有很多欠缺的地方比如消息丢失和堆积问题不好解决。因此，我们通常建议是不使用 Redis 来做消息队列的，你完全可以选择市面上比较成熟的一些消息队列比如 RocketMQ、Kafka。</p>
<p>相关文章推荐：<a href="https://javakeeper.starfish.ink/data-management/Redis/Redis-MQ.html" target="_blank" rel="noopener noreferrer">Redis 消息队列的三种方案（List、Streams、Pub/Sub）</a>。</p>
<h3> 如何基于 Redis 实现分布式锁？</h3>
<p>关于 Redis 实现分布式锁的详细介绍，可以看我写的这篇文章：<a href="https://javaguide.cn/distributed-system/distributed-lock.html" target="_blank" rel="noopener noreferrer">分布式锁详解</a> 。</p>
<h2> Redis 数据结构</h2>
<h3> Redis 常用的数据结构有哪些？</h3>
<ul>
<li><strong>5 种基础数据结构</strong> ：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。</li>
<li><strong>3 种特殊数据结构</strong> ：HyperLogLogs（基数统计）、Bitmap （位存储）、Geospatial (地理位置)。</li>
</ul>
<p>关于 5 种基础数据结构的详细介绍请看这篇文章：<a href="/database/redis/redis-data-structures-01.html" target="blank">Redis 5 种基本数据结构详解</a>。</p>
<p>关于 3 种特殊数据结构的详细介绍请看这篇文章：<a href="/database/redis/redis-data-structures-02.html" target="blank">Redis 3 种特殊数据结构详解</a>。</p>
<h3> String 的应用场景有哪些？</h3>
<ul>
<li>常规数据（比如 session、token、、序列化后的对象）的缓存；</li>
<li>计数比如用户单位时间的请求数（简单限流可以用到）、页面单位时间的访问数；</li>
<li>分布式锁(利用 <code>SETNX key value</code> 命令可以实现一个最简易的分布式锁)；</li>
<li>......</li>
</ul>
<p>关于 String 的详细介绍请看这篇文章：<a href="/database/redis/redis-data-structures-01.html" target="blank">Redis 5 种基本数据结构详解</a>。</p>
<h3> String 还是 Hash 存储对象数据更好呢？</h3>
<ul>
<li>String 存储的是序列化后的对象数据，存放的是整个对象。Hash 是对对象的每个字段单独存储，可以获取部分字段的信息，也可以修改或者添加部分字段，节省网络流量。如果对象中某些字段需要经常变动或者经常需要单独查询对象中的个别字段信息，Hash 就非常适合。</li>
<li>String 存储相对来说更加节省内存，缓存相同数量的对象数据，String 消耗的内存约是 Hash 的一半。并且，存储具有多层嵌套的对象时也方便很多。如果系统对性能和资源消耗非常敏感的话，String 就非常适合。</li>
</ul>
<p>在绝大部分情况，我们建议使用 String 来存储对象数据即可！</p>
<h3> String 的底层实现是什么？</h3>
<p>Redis 是基于 C 语言编写的，但 Redis 的 String 类型的底层实现并不是 C 语言中的字符串（即以空字符 <code>\0</code> 结尾的字符数组），而是自己编写了 <a href="https://github.com/antirez/sds" target="_blank" rel="noopener noreferrer">SDS</a>（Simple Dynamic String，简单动态字符串） 来作为底层实现。</p>
<p>SDS 最早是 Redis 作者为日常 C 语言开发而设计的 C 字符串，后来被应用到了 Redis 上，并经过了大量的修改完善以适合高性能操作。</p>
<p>Redis7.0 的 SDS 的部分源码如下（https://github.com/redis/redis/blob/7.0/src/sds.h）：</p>
<div class="language-c line-numbers-mode" data-ext="c"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过源码可以看出，SDS 共有五种实现方式 SDS_TYPE_5（并未用到）、SDS_TYPE_8、SDS_TYPE_16、SDS_TYPE_32、SDS_TYPE_64，其中只有后四种实际用到。Redis 会根据初始化的长度决定使用哪种类型，从而减少内存的使用。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>字节</th>
<th>位</th>
</tr>
</thead>
<tbody>
<tr>
<td>sdshdr5</td>
<td>&lt; 1</td>
<td>&lt;8</td>
</tr>
<tr>
<td>sdshdr8</td>
<td>1</td>
<td>8</td>
</tr>
<tr>
<td>sdshdr16</td>
<td>2</td>
<td>16</td>
</tr>
<tr>
<td>sdshdr32</td>
<td>4</td>
<td>32</td>
</tr>
<tr>
<td>sdshdr64</td>
<td>8</td>
<td>64</td>
</tr>
</tbody>
</table>
<p>对于后四种实现都包含了下面这 4 个属性：</p>
<ul>
<li><code>len</code> ：字符串的长度也就是已经使用的字节数</li>
<li><code>alloc</code>：总共可用的字符空间大小，alloc-len 就是 SDS 剩余的空间大小</li>
<li><code>buf[]</code> ：实际存储字符串的数组</li>
<li><code>flags</code> ：低三位保存类型标志</li>
</ul>
<p>SDS 相比于 C 语言中的字符串有如下提升：</p>
<ol>
<li><strong>可以避免缓冲区溢出</strong> ：C 语言中的字符串被修改（比如拼接）时，一旦没有分配足够长度的内存空间，就会造成缓冲区溢出。SDS 被修改时，会先根据 len 属性检查空间大小是否满足要求，如果不满足，则先扩展至所需大小再进行修改操作。</li>
<li><strong>获取字符串长度的复杂度较低</strong> ： C 语言中的字符串的长度通常是经过遍历计数来实现的，时间复杂度为 O(n)。SDS 的长度获取直接读取 len 属性即可，时间复杂度为 O(1)。</li>
<li><strong>减少内存分配次数</strong> ： 为了避免修改（增加/减少）字符串时，每次都需要重新分配内存（C 语言的字符串是这样的），SDS 实现了空间预分配和惰性空间释放两种优化策略。当 SDS 需要增加字符串时，Redis 会为 SDS 分配好内存，并且根据特定的算法分配多余的内存，这样可以减少连续执行字符串增长操作所需的内存重分配次数。当 SDS 需要减少字符串时，这部分内存不会立即被回收，会被记录下来，等待后续使用（支持手动释放，有对应的 API）。</li>
<li><strong>二进制安全</strong> ：C 语言中的字符串以空字符 <code>\0</code> 作为字符串结束的标识，这存在一些问题，像一些二进制文件（比如图片、视频、音频）就可能包括空字符，C 字符串无法正确保存。SDS 使用 len 属性判断字符串是否结束，不存在这个问题。</li>
</ol>
<p>多提一嘴，很多文章里 SDS 的定义是下面这样的：</p>
<div class="language-c line-numbers-mode" data-ext="c"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个也没错，Redis 3.2 之前就是这样定义的。后来，由于这种方式的定义存在问题，<code>len</code> 和 <code>free</code> 的定义用了 4 个字节，造成了浪费。Redis 3.2 之后，Redis 改进了 SDS 的定义，将其划分为了现在的 5 种类型。</p>
<h3> 购物车信息用 String 还是 Hash 存储更好呢?</h3>
<p>由于购物车中的商品频繁修改和变动，购物车信息建议使用 Hash 存储：</p>
<ul>
<li>用户 id 为 key</li>
<li>商品 id 为 field，商品数量为 value</li>
</ul>
<p></p>
<p>那用户购物车信息的维护具体应该怎么操作呢？</p>
<ul>
<li>用户添加商品就是往 Hash 里面增加新的 field 与 value；</li>
<li>查询购物车信息就是遍历对应的 Hash；</li>
<li>更改商品数量直接修改对应的 value 值（直接 set 或者做运算皆可）；</li>
<li>删除商品就是删除 Hash 中对应的 field；</li>
<li>清空购物车直接删除对应的 key 即可。</li>
</ul>
<p>这里只是以业务比较简单的购物车场景举例，实际电商场景下，field 只保存一个商品 id 是没办法满足需求的。</p>
<h3> 使用 Redis 实现一个排行榜怎么做？</h3>
<p>Redis 中有一个叫做 <code>sorted set</code> 的数据结构经常被用在各种排行榜的场景，比如直播间送礼物的排行榜、朋友圈的微信步数排行榜、王者荣耀中的段位排行榜、话题热度排行榜等等。</p>
<p>相关的一些 Redis 命令: <code>ZRANGE</code> (从小到大排序) 、 <code>ZREVRANGE</code> （从大到小排序）、<code>ZREVRANK</code> (指定元素排名)。</p>
<p><img src="https://img-blog.csdnimg.cn/2021060714195385.png" alt=""></p>
<p><a href="https://www.yuque.com/docs/share/f37fc804-bfe6-4b0d-b373-9c462188fec7" target="_blank" rel="noopener noreferrer">《Java 面试指北》</a> 的「技术面试题篇」就有一篇文章详细介绍如何使用 Sorted Set 来设计制作一个排行榜。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/image-20220719071115140.png" alt=""></p>
<h3> 使用 Set 实现抽奖系统需要用到什么命令？</h3>
<ul>
<li><code>SPOP key count</code> ： 随机移除并获取指定集合中一个或多个元素，适合不允许重复中奖的场景。</li>
<li><code>SRANDMEMBER key count</code> : 随机获取指定集合中指定数量的元素，适合允许重复中奖的场景。</li>
</ul>
<h3> 使用 Bitmap 统计活跃用户怎么做？</h3>
<p>使用日期（精确到天）作为 key，然后用户 ID 为 offset，如果当日活跃过就设置为 1。</p>
<p>初始化数据：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>统计 20210308~20210309 总活跃用户数:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>统计 20210308~20210309 在线活跃用户数:</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 使用 HyperLogLog 统计页面 UV 怎么做？</h3>
<p>1、将访问指定页面的每个用户 ID 添加到 <code>HyperLogLog</code> 中。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>2、统计指定页面的 UV。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2> Redis 线程模型</h2>
<p>对于读写命令来说，Redis 一直是单线程模型。不过，在 Redis 4.0 版本之后引入了多线程来执行一些大键值对的异步删除操作， Redis 6.0 版本之后引入了多线程来处理网络请求（提高网络 IO 读写性能）。</p>
<h3> Redis 单线程模型了解吗？</h3>
<p><strong>Redis 基于 Reactor 模式设计开发了一套高效的事件处理模型</strong> （Netty 的线程模型也基于 Reactor 模式，Reactor 模式不愧是高性能 IO 的基石），这套事件处理模型对应的是 Redis 中的文件事件处理器（file event handler）。由于文件事件处理器（file event handler）是单线程方式运行的，所以我们一般都说 Redis 是单线程模型。</p>
<p>《Redis 设计与实现》有一段话是如是介绍文件事件处理器的，我觉得写得挺不错。</p>
<blockquote>
<p>Redis 基于 Reactor 模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器（file event handler）。</p>
<ul>
<li>文件事件处理器使用 I/O 多路复用（multiplexing）程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</li>
<li>当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关 闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</li>
</ul>
<p><strong>虽然文件事件处理器以单线程方式运行，但通过使用 I/O 多路复用程序来监听多个套接字</strong>，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与 Redis 服务器中其他同样以单线程方式运行的模块进行对接，这保持了 Redis 内部单线程设计的简单性。</p>
</blockquote>
<p><strong>既然是单线程，那怎么监听大量的客户端连接呢？</strong></p>
<p>Redis 通过 <strong>IO 多路复用程序</strong> 来监听来自客户端的大量连接（或者说是监听多个 socket），它会将感兴趣的事件及类型（读、写）注册到内核中并监听每个事件是否发生。</p>
<p>这样的好处非常明显： <strong>I/O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗</strong>（和 NIO 中的 <code>Selector</code> 组件很像）。</p>
<p>文件事件处理器（file event handler）主要是包含 4 个部分：</p>
<ul>
<li>多个 socket（客户端连接）</li>
<li>IO 多路复用程序（支持多个客户端连接的关键）</li>
<li>文件事件分派器（将 socket 关联到相应的事件处理器）</li>
<li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li>
</ul>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/redis-event-handler.png" alt="文件事件处理器"></p>
<p>相关阅读：<a href="http://remcarpediem.net/article/1aa2da89/" target="_blank" rel="noopener noreferrer">Redis 事件机制详解</a> 。</p>
<h3> Redis6.0 之前为什么不使用多线程？</h3>
<p>虽然说 Redis 是单线程模型，但是，实际上，<strong>Redis 在 4.0 之后的版本中就已经加入了对多线程的支持。</strong></p>
<p>不过，Redis 4.0 增加的多线程主要是针对一些大键值对的删除操作的命令，使用这些命令就会使用主线程之外的其他线程来“异步处理”。</p>
<p>为此，Redis 4.0 之后新增了<code>UNLINK</code>（可以看作是 <code>DEL</code> 的异步版本）、<code>FLUSHALL ASYNC</code>（清空所有数据库的所有 key，不仅仅是当前 <code>SELECT</code> 的数据库）、<code>FLUSHDB ASYNC</code>（清空当前 <code>SELECT</code> 数据库中的所有 key）等异步命令。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/redis4.0-more-thread.png" alt="redis4.0 more thread"></p>
<p>大体上来说，Redis 6.0 之前主要还是单线程处理。</p>
<p><strong>那 Redis6.0 之前为什么不使用多线程？</strong> 我觉得主要原因有 3 点：</p>
<ul>
<li>单线程编程容易并且更容易维护；</li>
<li>Redis 的性能瓶颈不在 CPU ，主要在内存和网络；</li>
<li>多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。</li>
</ul>
<p>相关阅读：<a href="https://draveness.me/whys-the-design-redis-single-thread/" target="_blank" rel="noopener noreferrer">为什么 Redis 选择单线程模型</a> 。</p>
<h3> Redis6.0 之后为何引入了多线程？</h3>
<p><strong>Redis6.0 引入多线程主要是为了提高网络 IO 读写性能</strong>，因为这个算是 Redis 中的一个性能瓶颈（Redis 的瓶颈主要受限于内存和网络）。</p>
<p>虽然，Redis6.0 引入了多线程，但是 Redis 的多线程只是在网络数据的读写这类耗时操作上使用了，执行命令仍然是单线程顺序执行。因此，你也不需要担心线程安全问题。</p>
<p>Redis6.0 的多线程默认是禁用的，只使用主线程。如需开启需要设置IO线程数 &gt; 1，需要修改 redis 配置文件 <code>redis.conf</code> ：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>另外：</p>
<ul>
<li>io-threads的个数一旦设置，不能通过config动态设置</li>
<li>当设置ssl后，io-threads将不工作</li>
</ul>
<p>开启多线程后，默认只会使用多线程进行IO写入writes，即发送数据给客户端，如果需要开启多线程IO读取reads，同样需要修改 redis 配置文件 <code>redis.conf</code> :</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>但是官网描述开启多线程读并不能有太大提升，因此一般情况下并不建议开启</p>
<p>相关阅读：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/FZu3acwK6zrCBZQ_3HoUgw" target="_blank" rel="noopener noreferrer">Redis 6.0 新特性-多线程连环 13 问！</a></li>
<li><a href="https://segmentfault.com/a/1190000039223696" target="_blank" rel="noopener noreferrer">Redis 多线程网络模型全面揭秘</a>（推荐）</li>
</ul>
<h2> Redis 内存管理</h2>
<h3> Redis 给缓存数据设置过期时间有啥用？</h3>
<p>一般情况下，我们设置保存的缓存数据的时候都会设置一个过期时间。为什么呢？</p>
<p>因为内存是有限的，如果缓存中的所有数据都是一直保存的话，分分钟直接 Out of memory。</p>
<p>Redis 自带了给缓存数据设置过期时间的功能，比如：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意：<strong>Redis 中除了字符串类型有自己独有设置过期时间的命令 <code>setex</code> 外，其他方法都需要依靠 <code>expire</code> 命令来设置过期时间 。另外， <code>persist</code> 命令可以移除一个键的过期时间。</strong></p>
<p><strong>过期时间除了有助于缓解内存的消耗，还有什么其他用么？</strong></p>
<p>很多时候，我们的业务场景就是需要某个数据只在某一时间段内存在，比如我们的短信验证码可能只在 1 分钟内有效，用户登录的 token 可能只在 1 天内有效。</p>
<p>如果使用传统的数据库来处理的话，一般都是自己判断过期，这样更麻烦并且性能要差很多。</p>
<h3> Redis 是如何判断数据是否过期的呢？</h3>
<p>Redis 通过一个叫做过期字典（可以看作是 hash 表）来保存数据过期的时间。过期字典的键指向 Redis 数据库中的某个 key(键)，过期字典的值是一个 long long 类型的整数，这个整数保存了 key 所指向的数据库键的过期时间（毫秒精度的 UNIX 时间戳）。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/redis-expired-dictionary.png" alt="redis过期字典"></p>
<p>过期字典是存储在 redisDb 这个结构里的：</p>
<div class="language-c line-numbers-mode" data-ext="c"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 过期的数据的删除策略了解么？</h3>
<p>如果假设你设置了一批 key 只能存活 1 分钟，那么 1 分钟后，Redis 是怎么对这批 key 进行删除的呢？</p>
<p>常用的过期数据的删除策略就两个（重要！自己造缓存轮子的时候需要格外考虑的东西）：</p>
<ol>
<li><strong>惰性删除</strong> ：只会在取出 key 的时候才对数据进行过期检查。这样对 CPU 最友好，但是可能会造成太多过期 key 没有被删除。</li>
<li><strong>定期删除</strong> ： 每隔一段时间抽取一批 key 执行删除过期 key 操作。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。</li>
</ol>
<p>定期删除对内存更加友好，惰性删除对 CPU 更加友好。两者各有千秋，所以 Redis 采用的是 <strong>定期删除+惰性/懒汉式删除</strong> 。</p>
<p>但是，仅仅通过给 key 设置过期时间还是有问题的。因为还是可能存在定期删除和惰性删除漏掉了很多过期 key 的情况。这样就导致大量过期 key 堆积在内存里，然后就 Out of memory 了。</p>
<p>怎么解决这个问题呢？答案就是：<strong>Redis 内存淘汰机制。</strong></p>
<h3> Redis 内存淘汰机制了解么？</h3>
<blockquote>
<p>相关问题：MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数据都是热点数据?</p>
</blockquote>
<p>Redis 提供 6 种数据淘汰策略：</p>
<ol>
<li><strong>volatile-lru（least recently used）</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li>
<li><strong>volatile-ttl</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li>
<li><strong>volatile-random</strong>：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li>
<li><strong>allkeys-lru（least recently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）</li>
<li><strong>allkeys-random</strong>：从数据集（server.db[i].dict）中任意选择数据淘汰</li>
<li><strong>no-eviction</strong>：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！</li>
</ol>
<p>4.0 版本后增加以下两种：</p>
<ol start="7">
<li><strong>volatile-lfu（least frequently used）</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选最不经常使用的数据淘汰</li>
<li><strong>allkeys-lfu（least frequently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key</li>
</ol>
<h2> Redis 持久化机制</h2>
<h3> 怎么保证 Redis 挂掉之后再重启数据可以进行恢复？</h3>
<p>很多时候我们需要持久化数据也就是将内存中的数据写入到硬盘里面，大部分原因是为了之后重用数据（比如重启机器、机器故障之后恢复数据），或者是为了防止系统故障而将数据备份到一个远程位置。</p>
<p>Redis 不同于 Memcached 的很重要一点就是，Redis 支持持久化，而且支持两种不同的持久化操作。<strong>Redis 的一种持久化方式叫快照（snapshotting，RDB），另一种方式是只追加文件（append-only file, AOF）</strong>。这两种方法各有千秋，下面我会详细这两种持久化方法是什么，怎么用，如何选择适合自己的持久化方法。</p>
<h3> 什么是 RDB 持久化？</h3>
<p>Redis 可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。Redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis 主从结构，主要用来提高 Redis 性能），还可以将快照留在原地以便重启服务器的时候使用。</p>
<p>快照持久化是 Redis 默认采用的持久化方式，在 <code>redis.conf</code> 配置文件中默认有此下配置：</p>
<div class="language-clojure line-numbers-mode" data-ext="clojure"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> RDB 创建快照时会阻塞主线程吗？</h3>
<p>Redis 提供了两个命令来生成 RDB 快照文件：</p>
<ul>
<li><code>save</code> : 主线程执行，会阻塞主线程；</li>
<li><code>bgsave</code> : 子线程执行，不会阻塞主线程，默认选项。</li>
</ul>
<h3> 什么是 AOF 持久化？</h3>
<p>与快照持久化相比，AOF 持久化的实时性更好，因此已成为主流的持久化方案。默认情况下 Redis 没有开启 AOF（append only file）方式的持久化，可以通过 appendonly 参数开启：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入到内存缓存 <code>server.aof_buf</code> 中，然后再根据 <code>appendfsync</code> 配置来决定何时将其同步到硬盘中的 AOF 文件。</p>
<p>AOF 文件的保存位置和 RDB 文件的位置相同，都是通过 dir 参数设置的，默认的文件名是 <code>appendonly.aof</code>。</p>
<p>在 Redis 的配置文件中存在三种不同的 AOF 持久化方式，它们分别是：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为了兼顾数据和写入性能，用户可以考虑 <code>appendfsync everysec</code> 选项 ，让 Redis 每秒同步一次 AOF 文件，Redis 性能几乎没受到任何影响。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。当硬盘忙于执行写入操作的时候，Redis 还会优雅的放慢自己的速度以便适应硬盘的最大写入速度。</p>
<p><strong>相关 issue</strong> ：</p>
<ul>
<li><a href="https://github.com/Snailclimb/JavaGuide/issues/783" target="_blank" rel="noopener noreferrer">Redis 的 AOF 方式 #783</a></li>
<li><a href="https://github.com/Snailclimb/JavaGuide/issues/1439" target="_blank" rel="noopener noreferrer">Redis AOF 重写描述不准确 #1439</a></li>
</ul>
<h3> AOF 日志是如何实现的？</h3>
<p>关系型数据库（如 MySQL）通常都是执行命令之前记录日志（方便故障恢复），而 Redis AOF 持久化机制是在执行完命令之后再记录日志。</p>
<p></p>
<p><strong>为什么是在执行完命令之后记录日志呢？</strong></p>
<ul>
<li>避免额外的检查开销，AOF 记录日志不会对命令进行语法检查；</li>
<li>在命令执行完之后再记录，不会阻塞当前的命令执行。</li>
</ul>
<p>这样也带来了风险（我在前面介绍 AOF 持久化的时候也提到过）：</p>
<ul>
<li>如果刚执行完命令 Redis 就宕机会导致对应的修改丢失；</li>
<li>可能会阻塞后续其他命令的执行（AOF 记录日志是在 Redis 主线程中进行的）。</li>
</ul>
<h3> AOF 重写了解吗？</h3>
<p>当 AOF 变得太大时，Redis 能够在后台自动重写 AOF 产生一个新的 AOF 文件，这个新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。</p>
<p>AOF 重写是一个有歧义的名字，该功能是通过读取数据库中的键值对来实现的，程序无须对现有 AOF 文件进行任何读入、分析或者写入操作。</p>
<p>在执行 <code>BGREWRITEAOF</code> 命令时，Redis 服务器会维护一个 AOF 重写缓冲区，该缓冲区会在子进程创建新 AOF 文件期间，记录服务器执行的所有写命令。当子进程完成创建新 AOF 文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新 AOF 文件的末尾，使得新的 AOF 文件保存的数据库状态与现有的数据库状态一致。最后，服务器用新的 AOF 文件替换旧的 AOF 文件，以此来完成 AOF 文件重写操作。</p>
<p>Redis 7.0 版本之前，如果在重写期间有写入命令，AOF 可能会使用大量内存，重写期间到达的所有写入命令都会写入磁盘两次。</p>
<h3> 如何选择 RDB 和 AOF？</h3>
<p>关于 RDB 和 AOF 的优缺点，官网上面也给了比较详细的说明<a href="https://redis.io/docs/manual/persistence/" target="_blank" rel="noopener noreferrer">Redis persistence</a>，这里结合自己的理解简单总结一下。</p>
<p><strong>RDB 比 AOF 优秀的地方</strong> ：</p>
<ul>
<li>RDB 文件存储的内容是经过压缩的二进制数据， 保存着某个时间点的数据集，文件很小，适合做数据的备份，灾难恢复。AOF 文件存储的是每一次写命令，类似于 MySQL 的 binlog 日志，通常会必 RDB 文件大很多。当 AOF 变得太大时，Redis 能够在后台自动重写 AOF。新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。不过， Redis 7.0 版本之前，如果在重写期间有写入命令，AOF 可能会使用大量内存，重写期间到达的所有写入命令都会写入磁盘两次。</li>
<li>使用 RDB 文件恢复数据，直接解析还原数据即可，不需要一条一条地执行命令，速度非常快。而 AOF 则需要依次执行每个写命令，速度非常慢。也就是说，与 AOF 相比，恢复大数据集的时候，RDB 速度更快。</li>
</ul>
<p><strong>AOF 比 RDB 优秀的地方</strong> ：</p>
<ul>
<li>RDB 的数据安全性不如 AOF，没有办法实时或者秒级持久化数据。生成 RDB 文件的过程是比繁重的， 虽然 BGSAVE 子进程写入 RDB 文件的工作不会阻塞主线程，但会对机器的 CPU 资源和内存资源产生影响，严重的情况下甚至会直接把 Redis 服务干宕机。AOF 支持秒级数据丢失（取决 fsync 策略，如果是 everysec，最多丢失 1 秒的数据），仅仅是追加命令到 AOF 文件，操作轻量。</li>
<li>RDB 文件是以特定的二进制格式保存的，并且在 Redis 版本演进中有多个版本的 RDB，所以存在老版本的 Redis 服务不兼容新版本的 RDB 格式的问题。</li>
<li>AOF 以一种易于理解和解析的格式包含所有操作的日志。你可以轻松地导出 AOF 文件进行分析，你也可以直接操作 AOF 文件来解决一些问题。比如，如果执行<code>FLUSHALL</code>命令意外地刷新了所有内容后，只要 AOF 文件没有被重写，删除最新命令并重启即可恢复之前的状态。</li>
</ul>
<h3> Redis 4.0 对于持久化机制做了什么优化？</h3>
<p>由于 RDB 和 AOF 各有优势，于是，Redis 4.0 开始支持 RDB 和 AOF 的混合持久化（默认关闭，可以通过配置项 <code>aof-use-rdb-preamble</code> 开启）。</p>
<p>如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。这样做的好处是可以结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据。当然缺点也是有的， AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，可读性较差。</p>
<p>官方文档地址：https://redis.io/topics/persistence</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/redis4.0-persitence.png" alt=""></p>
<h2> 参考</h2>
<ul>
<li>《Redis 开发与运维》</li>
<li>《Redis 设计与实现》</li>
<li>Redis 命令手册：https://www.redis.com.cn/commands.html</li>
<li>WHY Redis choose single thread (vs multi threads): <a href="https://medium.com/@jychen7/sharing-redis-single-thread-vs-multi-threads-5870bd44d153" target="_blank" rel="noopener noreferrer">https://medium.com/@jychen7/sharing-redis-single-thread-vs-multi-threads-5870bd44d153</a></li>
<li>The difference between AOF and RDB persistence：https://www.sobyte.net/post/2022-04/redis-rdb-and-aof/</li>
</ul>
]]></content:encoded>
      <enclosure url="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/try.redis.io.png" type="image/png"/>
    </item>
    <item>
      <title>Redis常见面试题总结(下)</title>
      <link>https://javaguide.cn/database/redis/redis-questions-02.html</link>
      <guid>https://javaguide.cn/database/redis/redis-questions-02.html</guid>
      <source url="https://javaguide.cn/rss.xml">Redis常见面试题总结(下)</source>
      <description>Redis 事务 如何使用 Redis 事务？ Redis 可以通过 MULTI，EXEC，DISCARD 和 WATCH 等命令来实现事务(transaction)功能。 &amp;gt; MULTI OK &amp;gt; SET PROJECT &amp;quot;JavaGuide&amp;quot; QUEUED &amp;gt; GET PROJECT QUEUED &amp;gt; EXEC 1) OK 2) &amp;quot;JavaGuide&amp;quot;</description>
      <category>数据库</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<h2> Redis 事务</h2>
<h3> 如何使用 Redis 事务？</h3>
<p>Redis 可以通过 <strong><code>MULTI</code>，<code>EXEC</code>，<code>DISCARD</code> 和 <code>WATCH</code></strong> 等命令来实现事务(transaction)功能。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><a href="https://redis.io/commands/multi" target="_blank" rel="noopener noreferrer"><code>MULTI</code></a> 命令后可以输入多个命令，Redis 不会立即执行这些命令，而是将它们放到队列，当调用了 <a href="https://redis.io/commands/exec" target="_blank" rel="noopener noreferrer"><code>EXEC</code></a> 命令后，再执行所有的命令。</p>
<p>这个过程是这样的：</p>
<ol>
<li>开始事务（<code>MULTI</code>）；</li>
<li>命令入队(批量操作 Redis 的命令，先进先出（FIFO）的顺序执行)；</li>
<li>执行事务(<code>EXEC</code>)。</li>
</ol>
<p>你也可以通过 <a href="https://redis.io/commands/discard" target="_blank" rel="noopener noreferrer"><code>DISCARD</code></a> 命令取消一个事务，它会清空事务队列中保存的所有命令。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>你可以通过<a href="https://redis.io/commands/watch" target="_blank" rel="noopener noreferrer"><code>WATCH</code></a> 命令监听指定的 Key，当调用 <code>EXEC</code> 命令执行事务时，如果一个被 <code>WATCH</code> 命令监视的 Key 被 <strong>其他客户端/Session</strong> 修改的话，整个事务都不会被执行。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>不过，如果 <strong>WATCH</strong> 与 <strong>事务</strong> 在同一个 Session 里，并且被 <strong>WATCH</strong> 监视的 Key 被修改的操作发生在事务内部，这个事务是可以被执行成功的（相关 issue ：<a href="https://github.com/Snailclimb/JavaGuide/issues/1714" target="_blank" rel="noopener noreferrer">WATCH 命令碰到 MULTI 命令时的不同效果</a>）。</p>
<p>事务内部修改 WATCH 监视的 Key：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>事务外部修改 WATCH 监视的 Key：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Redis 官网相关介绍 <a href="https://redis.io/topics/transactions" target="_blank" rel="noopener noreferrer">https://redis.io/topics/transactions</a> 如下：</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/redis-transactions.png" alt="Redis 事务"></p>
<h3> Redis 支持原子性吗？</h3>
<p>Redis 的事务和我们平时理解的关系型数据库的事务不同。我们知道事务具有四大特性： <strong>1. 原子性</strong>，<strong>2. 隔离性</strong>，<strong>3. 持久性</strong>，<strong>4. 一致性</strong>。</p>
<ol>
<li><strong>原子性（Atomicity）：</strong> 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li>
<li><strong>隔离性（Isolation）：</strong> 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li>
<li><strong>持久性（Durability）：</strong> 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li>
<li><strong>一致性（Consistency）：</strong> 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；</li>
</ol>
<p>Redis 事务在运行错误的情况下，除了执行过程中出现错误的命令外，其他命令都能正常执行。并且，Redis 是不支持回滚（roll back）操作的。因此，Redis 事务其实是不满足原子性的（而且不满足持久性）。</p>
<p>Redis 官网也解释了自己为啥不支持回滚。简单来说就是 Redis 开发者们觉得没必要支持回滚，这样更简单便捷并且性能更好。Redis 开发者觉得即使命令执行错误也应该在开发过程中就被发现而不是生产过程中。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/redis-rollback.png" alt="Redis 为什么不支持回滚"></p>
<p>你可以将 Redis 中的事务就理解为 ：<strong>Redis 事务提供了一种将多个命令请求打包的功能。然后，再按顺序执行打包的所有命令，并且不会被中途打断。</strong></p>
<p>除了不满足原子性之外，事务中的每条命令都会与 Redis 服务器进行网络交互，这是比较浪费资源的行为。明明一次批量执行多个命令就可以了，这种操作实在是看不懂。</p>
<p>因此，Redis 事务是不建议在日常开发中使用的。</p>
<p><strong>相关 issue</strong> :</p>
<ul>
<li><a href="https://github.com/Snailclimb/JavaGuide/issues/452" target="_blank" rel="noopener noreferrer">issue452: 关于 Redis 事务不满足原子性的问题</a> 。</li>
<li><a href="https://github.com/Snailclimb/JavaGuide/issues/491" target="_blank" rel="noopener noreferrer">Issue491:关于 redis 没有事务回滚？</a></li>
</ul>
<h3> 如何解决 Redis 事务的缺陷？</h3>
<p>Redis 从 2.6 版本开始支持执行 Lua 脚本，它的功能和事务非常类似。我们可以利用 Lua 脚本来批量执行多条 Redis 命令，这些 Redis 命令会被提交到 Redis 服务器一次性执行完成，大幅减小了网络开销。</p>
<p>一段 Lua 脚本可以视作一条命令执行，一段 Lua 脚本执行过程中不会有其他脚本或 Redis 命令同时执行，保证了操作不会被其他指令插入或打扰。</p>
<p>如果 Lua 脚本运行时出错并中途结束，出错之后的命令是不会被执行的。并且，出错之前执行的命令是无法被撤销的。因此，严格来说，通过 Lua 脚本来批量执行 Redis 命令也是不满足原子性的。</p>
<p>另外，Redis 7.0 新增了 <a href="https://redis.io/docs/manual/programmability/functions-intro/" target="_blank" rel="noopener noreferrer">Redis functions</a> 特性，你可以将 Redis functions 看作是比 Lua 更强大的脚本。</p>
<h2> Redis 性能优化</h2>
<h3> Redis bigkey</h3>
<h4> 什么是 bigkey？</h4>
<p>简单来说，如果一个 key 对应的 value 所占用的内存比较大，那这个 key 就可以看作是 bigkey。具体多大才算大呢？有一个不是特别精确的参考标准：string 类型的 value 超过 10 kb，复合类型的 value 包含的元素超过 5000 个（对于复合类型的 value 来说，不一定包含的元素越多，占用的内存就越多）。</p>
<h4> bigkey 有什么危害？</h4>
<p>除了会消耗更多的内存空间，bigkey 对性能也会有比较大的影响。</p>
<p>因此，我们应该尽量避免写入 bigkey！</p>
<h4> 如何发现 bigkey？</h4>
<p><strong>1、使用 Redis 自带的 <code>--bigkeys</code> 参数来查找。</strong></p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从这个命令的运行结果，我们可以看出：这个命令会扫描(Scan) Redis 中的所有 key ，会对 Redis 的性能有一点影响。并且，这种方式只能找出每种数据结构 top 1 bigkey（占用内存最大的 string 数据类型，包含元素最多的复合数据类型）。</p>
<p><strong>2、分析 RDB 文件</strong></p>
<p>通过分析 RDB 文件来找出 big key。这种方案的前提是你的 Redis 采用的是 RDB 持久化。</p>
<p>网上有现成的代码/工具可以直接拿来使用：</p>
<ul>
<li><a href="https://github.com/sripathikrishnan/redis-rdb-tools" target="_blank" rel="noopener noreferrer">redis-rdb-tools</a> ：Python 语言写的用来分析 Redis 的 RDB 快照文件用的工具</li>
<li><a href="https://github.com/weiyanwei412/rdb_bigkeys" target="_blank" rel="noopener noreferrer">rdb_bigkeys</a> : Go 语言写的用来分析 Redis 的 RDB 快照文件用的工具，性能更好。</li>
</ul>
<h3> 大量 key 集中过期问题</h3>
<p>我在上面提到过：对于过期 key，Redis 采用的是 <strong>定期删除+惰性/懒汉式删除</strong> 策略。</p>
<p>定期删除执行过程中，如果突然遇到大量过期 key 的话，客户端请求必须等待定期清理过期 key 任务线程执行完成，因为这个这个定期任务线程是在 Redis 主线程中执行的。这就导致客户端请求没办法被及时处理，响应速度会比较慢。</p>
<p>如何解决呢？下面是两种常见的方法：</p>
<ol>
<li>给 key 设置随机过期时间。</li>
<li>开启 lazy-free（惰性删除/延迟释放） 。lazy-free 特性是 Redis 4.0 开始引入的，指的是让 Redis 采用异步方式延迟释放 key 使用的内存，将该操作交给单独的子线程处理，避免阻塞主线程。</li>
</ol>
<p>个人建议不管是否开启 lazy-free，我们都尽量给 key 设置随机过期时间。</p>
<h2> Redis 生产问题</h2>
<h3> 缓存穿透</h3>
<h4> 什么是缓存穿透？</h4>
<p>缓存穿透说简单点就是大量请求的 key 是不合理的，<strong>根本不存在于缓存中，也不存在于数据库中</strong> 。这就导致这些请求直接到了数据库上，根本没有经过缓存这一层，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/redis-cache-penetration.png" alt="缓存穿透"></p>
<p>举个例子：某个黑客故意制造一些非法的 key 发起大量请求，导致大量请求落到数据库，结果数据库上也没有查到对应的数据。也就是说这些请求最终都落到了数据库上，对数据库造成了巨大的压力。</p>
<h4> 有哪些解决办法？</h4>
<p>最基本的就是首先做好参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端。比如查询的数据库 id 不能小于 0、传入的邮箱格式不对的时候直接返回错误消息给客户端等等。</p>
<p><strong>1）缓存无效 key</strong></p>
<p>如果缓存和数据库都查不到某个 key 的数据就写一个到 Redis 中去并设置过期时间，具体命令如下： <code>SET key value EX 10086</code> 。这种方式可以解决请求的 key 变化不频繁的情况，如果黑客恶意攻击，每次构建不同的请求 key，会导致 Redis 中缓存大量无效的 key 。很明显，这种方案并不能从根本上解决此问题。如果非要用这种方式来解决穿透问题的话，尽量将无效的 key 的过期时间设置短一点比如 1 分钟。</p>
<p>另外，这里多说一嘴，一般情况下我们是这样设计 key 的： <code>表名:列名:主键名:主键值</code> 。</p>
<p>如果用 Java 代码展示的话，差不多是下面这样的：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>2）布隆过滤器</strong></p>
<p>布隆过滤器是一个非常神奇的数据结构，通过它我们可以非常方便地判断一个给定数据是否存在于海量数据中。我们需要的就是判断 key 是否合法，有没有感觉布隆过滤器就是我们想要找的那个“人”。</p>
<p>具体是这样做的：把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。</p>
<p>加入布隆过滤器之后的缓存处理流程图如下。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/redis-cache-penetration-bloom-filter.png" alt="加入布隆过滤器之后的缓存处理流程图"></p>
<p>但是，需要注意的是布隆过滤器可能会存在误判的情况。总结来说就是： <strong>布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。</strong></p>
<p><em>为什么会出现误判的情况呢? 我们还要从布隆过滤器的原理来说！</em></p>
<p>我们先来看一下，<strong>当一个元素加入布隆过滤器中的时候，会进行哪些操作：</strong></p>
<ol>
<li>使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。</li>
<li>根据得到的哈希值，在位数组中把对应下标的值置为 1。</li>
</ol>
<p>我们再来看一下，<strong>当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行哪些操作：</strong></p>
<ol>
<li>对给定元素再次进行相同的哈希计算；</li>
<li>得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。</li>
</ol>
<p>然后，一定会出现这样一种情况：<strong>不同的字符串可能哈希出来的位置相同。</strong> （可以适当增加位数组大小或者调整我们的哈希函数来降低概率）</p>
<p>更多关于布隆过滤器的内容可以看我的这篇原创：<a href="https://javaguide.cn/cs-basics/data-structure/bloom-filter/" target="_blank" rel="noopener noreferrer">《不了解布隆过滤器？一文给你整的明明白白！》</a> ，强烈推荐，个人感觉网上应该找不到总结的这么明明白白的文章了。</p>
<h3> 缓存击穿</h3>
<h4> 什么是缓存击穿？</h4>
<p>缓存击穿中，请求的 key 对应的是 <strong>热点数据</strong> ，该数据 <strong>存在于数据库中，但不存在于缓存中（通常是因为缓存中的那份数据已经过期）</strong> 。这就可能会导致瞬时大量的请求直接打到了数据库上，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/redis-cache-breakdown.png" alt="缓存击穿"></p>
<p>举个例子 ：秒杀进行过程中，缓存中的某个秒杀商品的数据突然过期，这就导致瞬时大量对该商品的请求直接落到数据库上，对数据库造成了巨大的压力。</p>
<h4> 有哪些解决办法？</h4>
<ul>
<li>设置热点数据永不过期或者过期时间比较长。</li>
<li>针对热点数据提前预热，将其存入缓存中并设置合理的过期时间比如秒杀场景下的数据在秒杀结束之前不过期。</li>
<li>请求数据库写数据到缓存之前，先获取互斥锁，保证只有一个请求会落到数据库上，减少数据库的压力。</li>
</ul>
<h4> 缓存穿透和缓存击穿有什么区别？</h4>
<p>缓存穿透中，请求的 key 既不存在于缓存中，也不存在于数据库中。</p>
<p>缓存击穿中，请求的 key 对应的是 <strong>热点数据</strong> ，该数据 <strong>存在于数据库中，但不存在于缓存中（通常是因为缓存中的那份数据已经过期）</strong> 。</p>
<h3> 缓存雪崩</h3>
<h4> 什么是缓存雪崩？</h4>
<p>我发现缓存雪崩这名字起的有点意思，哈哈。</p>
<p>实际上，缓存雪崩描述的就是这样一个简单的场景：<strong>缓存在同一时间大面积的失效，导致大量的请求都直接落到了数据库上，对数据库造成了巨大的压力。</strong> 这就好比雪崩一样，摧枯拉朽之势，数据库的压力可想而知，可能直接就被这么多请求弄宕机了。</p>
<p>另外，缓存服务宕机也会导致缓存雪崩现象，导致所有的请求都落到了数据库上。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/redis-cache-avalanche.png" alt="缓存雪崩"></p>
<p>举个例子 ：数据库中的大量数据在同一时间过期，这个时候突然有大量的请求需要访问这些过期的数据。这就导致大量的请求直接落到数据库上，对数据库造成了巨大的压力。</p>
<h4> 有哪些解决办法？</h4>
<p><strong>针对 Redis 服务不可用的情况：</strong></p>
<ol>
<li>采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。</li>
<li>限流，避免同时处理大量的请求。</li>
</ol>
<p><strong>针对热点缓存失效的情况：</strong></p>
<ol>
<li>设置不同的失效时间比如随机设置缓存的失效时间。</li>
<li>缓存永不失效（不太推荐，实用性太差）。</li>
<li>设置二级缓存。</li>
</ol>
<h4> 缓存雪崩和缓存击穿有什么区别？</h4>
<p>缓存雪崩和缓存击穿比较像，但缓存雪崩导致的原因是缓存中的大量或者所有数据失效，缓存击穿导致的原因主要是某个热点数据不存在与缓存中（通常是因为缓存中的那份数据已经过期）。</p>
<h3> 如何保证缓存和数据库数据的一致性？</h3>
<p>细说的话可以扯很多，但是我觉得其实没太大必要（小声 BB：很多解决方案我也没太弄明白）。我个人觉得引入缓存之后，如果为了短时间的不一致性问题，选择让系统设计变得更加复杂的话，完全没必要。</p>
<p>下面单独对 <strong>Cache Aside Pattern（旁路缓存模式）</strong> 来聊聊。</p>
<p>Cache Aside Pattern 中遇到写请求是这样的：更新 DB，然后直接删除 cache 。</p>
<p>如果更新数据库成功，而删除缓存这一步失败的情况的话，简单说两个解决方案：</p>
<ol>
<li><strong>缓存失效时间变短（不推荐，治标不治本）</strong> ：我们让缓存数据的过期时间变短，这样的话缓存就会从数据库中加载数据。另外，这种解决办法对于先操作缓存后操作数据库的场景不适用。</li>
<li><strong>增加 cache 更新重试机制（常用）</strong>： 如果 cache 服务当前不可用导致缓存删除失败的话，我们就隔一段时间进行重试，重试次数可以自己定。如果多次重试还是失败的话，我们可以把当前更新失败的 key 存入队列中，等缓存服务可用之后，再将缓存中对应的 key 删除即可。</li>
</ol>
<p>相关文章推荐：<a href="https://mp.weixin.qq.com/s?__biz=MzIyOTYxNDI5OA==&amp;mid=2247487312&amp;idx=1&amp;sn=fa19566f5729d6598155b5c676eee62d&amp;chksm=e8beb8e5dfc931f3e35655da9da0b61c79f2843101c130cf38996446975014f958a6481aacf1&amp;scene=178&amp;cur_album_id=1699766580538032128#rd" target="_blank" rel="noopener noreferrer">缓存和数据库一致性问题，看这篇就够了 - 水滴与银弹</a></p>
<h2> Redis 集群</h2>
<p><strong>Redis Sentinel</strong> ：</p>
<ol>
<li>什么是 Sentinel？ 有什么用？</li>
<li>Sentinel 如何检测节点是否下线？主观下线与客观下线的区别?</li>
<li>Sentinel 是如何实现故障转移的？</li>
<li>为什么建议部署多个 sentinel 节点（哨兵集群）？</li>
<li>Sentinel 如何选择出新的 master（选举机制）?</li>
<li>如何从 Sentinel 集群中选择出 Leader ？</li>
<li>Sentinel 可以防止脑裂吗？</li>
</ol>
<p><strong>Redis Cluster</strong> ：</p>
<ol>
<li>为什么需要 Redis Cluster？解决了什么问题？有什么优势？</li>
<li>Redis Cluster 是如何分片的？</li>
<li>为什么 Redis Cluster 的哈希槽是 16384 个?</li>
<li>如何确定给定 key 的应该分布到哪个哈希槽中？</li>
<li>Redis Cluster 支持重新分配哈希槽吗？</li>
<li>Redis Cluster 扩容缩容期间可以提供服务吗？</li>
<li>Redis Cluster 中的节点是怎么进行通信的？</li>
</ol>
<p><strong>参考答案</strong> ：<a href="/database/redis/redis-cluster.html" target="blank">Redis 集群详解（付费）</a>。</p>
<h2> 参考</h2>
<ul>
<li>《Redis 开发与运维》</li>
<li>《Redis 设计与实现》</li>
<li>Redis Transactions : https://redis.io/docs/manual/transactions/ 。</li>
</ul>
]]></content:encoded>
      <enclosure url="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/database/redis/redis-transactions.png" type="image/png"/>
    </item>
    <item>
      <title>CAP &amp; BASE理论</title>
      <link>https://javaguide.cn/distributed-system/theorem_algorithm_protocol/cap_base-theorem.html</link>
      <guid>https://javaguide.cn/distributed-system/theorem_algorithm_protocol/cap_base-theorem.html</guid>
      <source url="https://javaguide.cn/rss.xml">CAP &amp; BASE理论</source>
      <description>经历过技术面试的小伙伴想必对 CAP &amp;amp; BASE 这个两个理论已经再熟悉不过了！ 我当年参加面试的时候，不夸张地说，只要问到分布式相关的内容，面试官几乎是必定会问这两个分布式相关的理论。一是因为这两个分布式基础理论是学习分布式知识的必备前置基础，二是因为很多面试官自己比较熟悉这两个理论（方便提问）。 我们非常有必要将这两个理论搞懂，并且能够用自己的理解给别人讲出来。 CAP 理论 CAP 理论/定理起源于 2000 年，由加州大学伯克利分校的 Eric Brewer 教授在分布式计算原理研讨会（PODC）上提出，因此 CAP 定理又被称作 布鲁尔定理（Brewer’s theorem）</description>
      <category>分布式</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<p>经历过技术面试的小伙伴想必对 CAP &amp; BASE 这个两个理论已经再熟悉不过了！</p>
<p>我当年参加面试的时候，不夸张地说，只要问到分布式相关的内容，面试官几乎是必定会问这两个分布式相关的理论。一是因为这两个分布式基础理论是学习分布式知识的必备前置基础，二是因为很多面试官自己比较熟悉这两个理论（方便提问）。</p>
<p>我们非常有必要将这两个理论搞懂，并且能够用自己的理解给别人讲出来。</p>
<h2> CAP 理论</h2>
<p><a href="https://zh.wikipedia.org/wiki/CAP%E5%AE%9A%E7%90%86" target="_blank" rel="noopener noreferrer">CAP 理论/定理</a>起源于 2000 年，由加州大学伯克利分校的 Eric Brewer 教授在分布式计算原理研讨会（PODC）上提出，因此 CAP 定理又被称作 <strong>布鲁尔定理（Brewer’s theorem）</strong></p>
<p>2 年后，麻省理工学院的 Seth Gilbert 和 Nancy Lynch 发表了布鲁尔猜想的证明，CAP 理论正式成为分布式领域的定理。</p>
<h3> 简介</h3>
<p><strong>CAP</strong> 也就是 <strong>Consistency（一致性）</strong>、<strong>Availability（可用性）</strong>、<strong>Partition Tolerance（分区容错性）</strong> 这三个单词首字母组合。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-11/cap.png" alt=""></p>
<p>CAP 理论的提出者布鲁尔在提出 CAP 猜想的时候，并没有详细定义 <strong>Consistency</strong>、<strong>Availability</strong>、<strong>Partition Tolerance</strong> 三个单词的明确定义。</p>
<p>因此，对于 CAP 的民间解读有很多，一般比较被大家推荐的是下面 👇 这种版本的解读。</p>
<p>在理论计算机科学中，CAP 定理（CAP theorem）指出对于一个分布式系统来说，当设计读写操作时，只能同时满足以下三点中的两个：</p>
<ul>
<li><strong>一致性（Consistency）</strong> : 所有节点访问同一份最新的数据副本</li>
<li><strong>可用性（Availability）</strong>: 非故障的节点在合理的时间内返回合理的响应（不是错误或者超时的响应）。</li>
<li><strong>分区容错性（Partition Tolerance）</strong> : 分布式系统出现网络分区的时候，仍然能够对外提供服务。</li>
</ul>
<p><strong>什么是网络分区？</strong></p>
<p>分布式系统中，多个节点之前的网络本来是连通的，但是因为某些故障（比如部分节点网络出了问题）某些节点之间不连通了，整个网络就分成了几块区域，这就叫 <strong>网络分区</strong>。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-11/partition-tolerance.png" alt="partition-tolerance"></p>
<h3> 不是所谓的“3 选 2”</h3>
<p>大部分人解释这一定律时，常常简单的表述为：“一致性、可用性、分区容忍性三者你只能同时达到其中两个，不可能同时达到”。实际上这是一个非常具有误导性质的说法，而且在 CAP 理论诞生 12 年之后，CAP 之父也在 2012 年重写了之前的论文。</p>
<blockquote>
<p><strong>当发生网络分区的时候，如果我们要继续服务，那么强一致性和可用性只能 2 选 1。也就是说当网络分区之后 P 是前提，决定了 P 之后才有 C 和 A 的选择。也就是说分区容错性（Partition tolerance）我们是必须要实现的。</strong></p>
<p>简而言之就是：CAP 理论中分区容错性 P 是一定要满足的，在此基础上，只能满足可用性 A 或者一致性 C。</p>
</blockquote>
<p>因此，<strong>分布式系统理论上不可能选择 CA 架构，只能选择 CP 或者 AP 架构。</strong> 比如 ZooKeeper、HBase 就是 CP 架构，Cassandra、Eureka 就是 AP 架构，Nacos 不仅支持 CP 架构也支持 AP 架构。</p>
<p><strong>为啥不可能选择 CA 架构呢？</strong> 举个例子：若系统出现“分区”，系统中的某个节点在进行写操作。为了保证 C， 必须要禁止其他节点的读写操作，这就和 A 发生冲突了。如果为了保证 A，其他节点的读写操作正常的话，那就和 C 发生冲突了。</p>
<p><strong>选择 CP 还是 AP 的关键在于当前的业务场景，没有定论，比如对于需要确保强一致性的场景如银行一般会选择保证 CP 。</strong></p>
<p>另外，需要补充说明的一点是： <strong>如果网络分区正常的话（系统在绝大部分时候所处的状态），也就说不需要保证 P 的时候，C 和 A 能够同时保证。</strong></p>
<h3> CAP 实际应用案例</h3>
<p>我这里以注册中心来探讨一下 CAP 的实际应用。考虑到很多小伙伴不知道注册中心是干嘛的，这里简单以 Dubbo 为例说一说。</p>
<p>下图是 Dubbo 的架构图。<strong>注册中心 Registry 在其中扮演了什么角色呢？提供了什么服务呢？</strong></p>
<p>注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力较小。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-11/dubbo-architecture.png" alt=""></p>
<p>常见的可以作为注册中心的组件有：ZooKeeper、Eureka、Nacos...。</p>
<ol>
<li><strong>ZooKeeper 保证的是 CP。</strong> 任何时刻对 ZooKeeper 的读请求都能得到一致性的结果，但是， ZooKeeper 不保证每次请求的可用性比如在 Leader 选举过程中或者半数以上的机器不可用的时候服务就是不可用的。</li>
<li><strong>Eureka 保证的则是 AP。</strong> Eureka 在设计的时候就是优先保证 A （可用性）。在 Eureka 中不存在什么 Leader 节点，每个节点都是一样的、平等的。因此 Eureka 不会像 ZooKeeper 那样出现选举过程中或者半数以上的机器不可用的时候服务就是不可用的情况。 Eureka 保证即使大部分节点挂掉也不会影响正常提供服务，只要有一个节点是可用的就行了。只不过这个节点上的数据可能并不是最新的。</li>
<li><strong>Nacos 不仅支持 CP 也支持 AP。</strong></li>
</ol>
<h3> 总结</h3>
<p>在进行分布式系统设计和开发时，我们不应该仅仅局限在 CAP 问题上，还要关注系统的扩展性、可用性等等</p>
<p>在系统发生“分区”的情况下，CAP 理论只能满足 CP 或者 AP。要注意的是，这里的前提是系统发生了“分区”</p>
<p>如果系统没有发生“分区”的话，节点间的网络连接通信正常的话，也就不存在 P 了。这个时候，我们就可以同时保证 C 和 A 了。</p>
<p>总结：<strong>如果系统发生“分区”，我们要考虑选择 CP 还是 AP。如果系统没有发生“分区”的话，我们要思考如何保证 CA 。</strong></p>
<h3> 推荐阅读</h3>
<ol>
<li><a href="https://medium.com/@ravindraprasad/cap-theorem-simplified-28499a67eab4" target="_blank" rel="noopener noreferrer">CAP 定理简化</a> （英文，有趣的案例）</li>
<li><a href="https://juejin.im/post/6844903936718012430" target="_blank" rel="noopener noreferrer">神一样的 CAP 理论被应用在何方</a> （中文，列举了很多实际的例子）</li>
<li><a href="https://martin.kleppmann.com/2015/05/11/please-stop-calling-databases-cp-or-ap.html" target="_blank" rel="noopener noreferrer">请停止呼叫数据库 CP 或 AP </a> （英文，带给你不一样的思考）</li>
</ol>
<h2> BASE 理论</h2>
<p><a href="https://dl.acm.org/doi/10.1145/1394127.1394128" target="_blank" rel="noopener noreferrer">BASE 理论</a>起源于 2008 年， 由 eBay 的架构师 Dan Pritchett 在 ACM 上发表。</p>
<h3> 简介</h3>
<p><strong>BASE</strong> 是 <strong>Basically Available（基本可用）</strong> 、<strong>Soft-state（软状态）</strong> 和 <strong>Eventually Consistent（最终一致性）</strong> 三个短语的缩写。BASE 理论是对 CAP 中一致性 C 和可用性 A 权衡的结果，其来源于对大规模互联网系统分布式实践的总结，是基于 CAP 定理逐步演化而来的，它大大降低了我们对系统的要求。</p>
<h3> BASE 理论的核心思想</h3>
<p>即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。</p>
<blockquote>
<p>也就是牺牲数据的一致性来满足系统的高可用性，系统中一部分数据不可用或者不一致时，仍需要保持系统整体“主要可用”。</p>
</blockquote>
<p><strong>BASE 理论本质上是对 CAP 的延伸和补充，更具体地说，是对 CAP 中 AP 方案的一个补充。</strong></p>
<p><strong>为什么这样说呢？</strong></p>
<p>CAP 理论这节我们也说过了：</p>
<blockquote>
<p>如果系统没有发生“分区”的话，节点间的网络连接通信正常的话，也就不存在 P 了。这个时候，我们就可以同时保证 C 和 A 了。因此，<strong>如果系统发生“分区”，我们要考虑选择 CP 还是 AP。如果系统没有发生“分区”的话，我们要思考如何保证 CA 。</strong></p>
</blockquote>
<p>因此，AP 方案只是在系统发生分区的时候放弃一致性，而不是永远放弃一致性。在分区故障恢复后，系统应该达到最终一致性。这一点其实就是 BASE 理论延伸的地方。</p>
<h3> BASE 理论三要素</h3>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOC81LzI0LzE2MzkxNDgwNmQ5ZTE1YzY?x-oss-process=image/format,png" alt="BASE理论三要素"></p>
<h4> 基本可用</h4>
<p>基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性。但是，这绝不等价于系统不可用。</p>
<p><strong>什么叫允许损失部分可用性呢？</strong></p>
<ul>
<li><strong>响应时间上的损失</strong>: 正常情况下，处理用户请求需要 0.5s 返回结果，但是由于系统出现故障，处理用户请求的时间变为 3 s。</li>
<li><strong>系统功能上的损失</strong>：正常情况下，用户可以使用系统的全部功能，但是由于系统访问量突然剧增，系统的部分非核心功能无法使用。</li>
</ul>
<h4> 软状态</h4>
<p>软状态指允许系统中的数据存在中间状态（<strong>CAP 理论中的数据不一致</strong>），并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。</p>
<h4> 最终一致性</h4>
<p>最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。</p>
<blockquote>
<p>分布式一致性的 3 种级别：</p>
<ol>
<li>
<p><strong>强一致性</strong> ：系统写入了什么，读出来的就是什么。</p>
</li>
<li>
<p><strong>弱一致性</strong> ：不一定可以读取到最新写入的值，也不保证多少时间之后读取到的数据是最新的，只是会尽量保证某个时刻达到数据一致的状态。</p>
</li>
<li>
<p><strong>最终一致性</strong> ：弱一致性的升级版，系统会保证在一定时间内达到数据一致的状态。</p>
</li>
</ol>
<p><strong>业界比较推崇是最终一致性级别，但是某些对数据一致要求十分严格的场景比如银行转账还是要保证强一致性。</strong></p>
</blockquote>
<p>那实现最终一致性的具体方式是什么呢? <a href="http://gk.link/a/10rZM" target="_blank" rel="noopener noreferrer">《分布式协议与算法实战》</a> 中是这样介绍：</p>
<blockquote>
<ul>
<li><strong>读时修复</strong> : 在读取数据时，检测数据的不一致，进行修复。比如 Cassandra 的 Read Repair 实现，具体来说，在向 Cassandra 系统查询数据的时候，如果检测到不同节点 的副本数据不一致，系统就自动修复数据。</li>
<li><strong>写时修复</strong> : 在写入数据，检测数据的不一致时，进行修复。比如 Cassandra 的 Hinted Handoff 实现。具体来说，Cassandra 集群的节点之间远程写数据的时候，如果写失败 就将数据缓存下来，然后定时重传，修复数据的不一致性。</li>
<li><strong>异步修复</strong> : 这个是最常用的方式，通过定时对账检测副本数据的一致性，并修复。</li>
</ul>
</blockquote>
<p>比较推荐 <strong>写时修复</strong>，这种方式对性能消耗比较低。</p>
<h3> 总结</h3>
<p><strong>ACID 是数据库事务完整性的理论，CAP 是分布式系统设计理论，BASE 是 CAP 理论中 AP 方案的延伸。</strong></p>
]]></content:encoded>
      <enclosure url="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/2020-11/cap.png" type="image/png"/>
    </item>
    <item>
      <title></title>
      <link>https://javaguide.cn/distributed-system/theorem_algorithm_protocol/gossip.html</link>
      <guid>https://javaguide.cn/distributed-system/theorem_algorithm_protocol/gossip.html</guid>
      <source url="https://javaguide.cn/rss.xml"></source>
      <description>背景 在分布式系统中，不同的节点进行数据/信息共享是一个基本的需求。 一种比较简单粗暴的方法就是 集中式发散消息，简单来说就是一个主节点同时共享最新信息给其他所有节点，比较适合中心化系统。这种方法的缺陷也很明显，节点多的时候不光同步消息的效率低，还太依赖与中心节点，存在单点风险问题。 于是，分散式发散消息 的 Gossip 协议 就诞生了。 Gossip 协议介绍 Gossip 直译过来就是闲话、流言蜚语的意思。流言蜚语有什么特点呢？容易被传播且传播速度还快，你传我我传他，然后大家都知道了。</description>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 背景</h2>
<p>在分布式系统中，不同的节点进行数据/信息共享是一个基本的需求。</p>
<p>一种比较简单粗暴的方法就是 <strong>集中式发散消息</strong>，简单来说就是一个主节点同时共享最新信息给其他所有节点，比较适合中心化系统。这种方法的缺陷也很明显，节点多的时候不光同步消息的效率低，还太依赖与中心节点，存在单点风险问题。</p>
<p>于是，<strong>分散式发散消息</strong> 的 <strong>Gossip 协议</strong> 就诞生了。</p>
<h2> Gossip 协议介绍</h2>
<p>Gossip 直译过来就是闲话、流言蜚语的意思。流言蜚语有什么特点呢？容易被传播且传播速度还快，你传我我传他，然后大家都知道了。</p>
<p></p>
<p>Gossip 协议也叫 Epidemic 协议（流行病协议）或者 Epidemic propagation 算法（疫情传播算法），别名很多。不过，这些名字的特点都具有 <strong>随机传播特性</strong> （联想一下病毒传播、癌细胞扩散等生活中常见的情景），这也正是 Gossip 协议最主要的特点。</p>
<p>Gossip 协议最早是在 ACM 上的一篇 1987 年发表的论文 <a href="https://dl.acm.org/doi/10.1145/41840.41841" target="_blank" rel="noopener noreferrer">《Epidemic Algorithms for Replicated Database Maintenance》</a>中被提出的。根据论文标题，我们大概就能知道 Gossip 协议当时提出的主要应用是在分布式数据库系统中各个副本节点同步数据。</p>
<p>正如 Gossip 协议其名一样，这是一种随机且带有传染性的方式将信息传播到整个网络中，并在一定时间内，使得系统内的所有节点数据一致。</p>
<p>在 Gossip 协议下，没有所谓的中心节点，每个节点周期性地随机找一个节点互相同步彼此的信息，理论上来说，各个节点的状态最终会保持一致。</p>
<p>下面我们来对 Gossip 协议的定义做一个总结： <strong>Gossip 协议是一种允许在分布式系统中共享状态的去中心化通信协议，通过这种通信协议，我们可以将信息传播给网络或集群中的所有成员。</strong></p>
<h2> Gossip 协议应用</h2>
<p>1、我们经常使用的分布式缓存 Redis 的官方集群解决方案（3.0 版本引入） Redis Cluster 就是基于 Gossip 协议来实现集群中各个节点数据的最终一致性。</p>
<p><img src="https://img-blog.csdnimg.cn/85fbed524d8342adb054961525c6e257.png" alt=""></p>
<p>Redis Cluster 中的每个 Redis 节点都维护了一份集群的状态信息，各个节点利用 Gossip 协议传递的信息就是集群的状态信息。</p>
<p>下图就是主从架构的 Redis Cluster 的示意图，图中的虚线代表的就是各个节点之间使用 Gossip 进行通信 ，实线表示主从复制。</p>
<p></p>
<p>2、NoSQL 数据库 Apache Cassandra 集群通过 Gossip 协议来进行动态管理集群节点状态（节点故障检测和恢复）。</p>
<p>3、服务网格解决方案 Consul 使用 Gossip 协议网络内可靠有效地传输新服务和事件的信息。</p>
<p>4、Bitcoin 使用 Gossip 协议来传播交易和区块信息。不过，为了提供更好的隐私保护，CMU 的研究人员提出 <strong>蒲公英协议</strong>。</p>
<p>5、......</p>
<p>还有非常多使用 Gossip 协议的应用，学习 Gossip 协议有助于我们搞清很多技术的底层原理。</p>
<h2> Gossip 协议消息传播模式</h2>
<p>Gossip 设计了两种可能的消息传播模式：<strong>反熵（Anti-Entropy）</strong> 和 <strong>传谣（Rumor-Mongering）</strong>。</p>
<h3> 反熵(Anti-entropy)</h3>
<p>根据维基百科：</p>
<blockquote>
<p>熵的概念最早起源于<a href="https://zh.wikipedia.org/wiki/%E7%89%A9%E7%90%86%E5%AD%A6" target="_blank" rel="noopener noreferrer">物理学</a>，用于度量一个热力学系统的混乱程度。熵最好理解为不确定性的量度而不是确定性的量度，因为越随机的信源的熵越大。</p>
</blockquote>
<p>在这里，你可以把反熵中的熵了解为节点之间数据的混乱程度/差异性，反熵就是指消除不同节点中数据的差异，提升节点间数据的相似度，从而降低熵值。</p>
<p>具体是如何反熵的呢？集群中的节点，每隔段时间就随机选择某个其他节点，然后通过互相交换自己的所有数据来消除两者之间的差异，实现数据的最终一致性。</p>
<p>在实现反熵的时候，主要有推、拉和推拉三种方式：</p>
<ul>
<li>推方式，就是将自己的所有副本数据，推给对方，修复对方副本中的熵。</li>
<li>拉方式，就是拉取对方的所有副本数据，修复自己副本中的熵。</li>
<li>推拉就是同时修复自己副本和对方副本中的熵。</li>
</ul>
<p>伪代码如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20210605165106728.png" alt=""></p>
<p>在我们实际应用场景中，一般不会采用随机的节点进行反熵，而是需要可以的设计一个闭环。这样的话，我们能够在一个确定的时间范围内实现各个节点数据的最终一致性，而不是基于随机的概率。像 InfluxDB 就是这样来实现反熵的。</p>
<p></p>
<ol>
<li>节点 A 推送数据给节点 B，节点 B 获取到节点 A 中的最新数据。</li>
<li>节点 B 推送数据给 C，节点 C 获取到节点 A，B 中的最新数据。</li>
<li>节点 C 推送数据给 A，节点 A 获取到节点 B，C 中的最新数据。</li>
<li>节点 A 再推送数据给 B 形成闭环，这样节点 B 就获取到节点 C 中的最新数据。</li>
</ol>
<p>虽然反熵很简单实用，但是，节点过多或者节点动态变化的话，反熵就不太适用了。这个时候，我们想要实现最终一致性就要靠 **谣言传播(Rumor mongering) ** 。</p>
<h3> 谣言传播(Rumor mongering)</h3>
<p>谣言传播指的是分布式系统中的一个节点一旦有了新数据之后，就会变为活跃节点，活跃节点会周期性地联系其他节点向其发送新数据，直到所有的节点都存储了该新数据。</p>
<p>如下图所示（下图来自于<a href="https://managementfromscratch.wordpress.com/2016/04/01/introduction-to-gossip/" target="_blank" rel="noopener noreferrer">INTRODUCTION TO GOSSIP</a> 这篇文章）：</p>
<p>![Gossip 传播示意图](./images/gossip/gossip-rumor- mongering.gif)</p>
<p>伪代码如下：</p>
<p><img src="https://img-blog.csdnimg.cn/20210605170707933.png" alt=""></p>
<p>谣言传播比较适合节点数量比较多的情况，不过，这种模式下要尽量避免传播的信息包不能太大，避免网络消耗太大。</p>
<h3> 总结</h3>
<ul>
<li>反熵（Anti-Entropy）会传播节点的所有数据，而谣言传播（Rumor-Mongering）只会传播节点新增的数据。</li>
<li>我们一般会给反熵设计一个闭环。</li>
<li>谣言传播（Rumor-Mongering）比较适合节点数量比较多或者节点动态变化的场景。</li>
</ul>
<h2> Gossip 协议优势和缺陷</h2>
<p><strong>优势：</strong></p>
<p>1、相比于其他分布式协议/算法来说，Gossip 协议理解起来非常简单。</p>
<p>2、能够容忍网络上节点的随意地增加或者减少，宕机或者重启，因为 Gossip 协议下这些节点都是平等的，去中心化的。新增加或者重启的节点在理想情况下最终是一定会和其他节点的状态达到一致。</p>
<p>3、速度相对较快。节点数量比较多的情况下，扩散速度比一个主节点向其他节点传播信息要更快（多播）。</p>
<p><strong>缺陷</strong> :</p>
<p>1、消息需要通过多个传播的轮次才能传播到整个网络中，因此，必然会出现各节点状态不一致的情况。毕竟，Gossip 协议强调的是最终一致，至于达到各个节点的状态一致需要多长时间，谁也无从得知。</p>
<p>2、由于拜占庭将军问题，不允许存在恶意节点。</p>
<p>3、可能会出现消息冗余的问题。由于消息传播的随机性，同一个节点可能会重复收到相同的消息。</p>
<h2> 总结</h2>
<ul>
<li>Gossip 协议是一种允许在分布式系统中共享状态的通信协议，通过这种通信协议，我们可以将信息传播给网络或集群中的所有成员。</li>
<li>Gossip 协议被 Redis 、Apache Cassandra、Consul 等项目应用。</li>
<li>谣言传播（Rumor-Mongering）比较适合节点数量比较多或者节点动态变化的场景。</li>
</ul>
<h2> 参考</h2>
<ul>
<li>一万字详解 Redis Cluster Gossip 协议：https://segmentfault.com/a/1190000038373546</li>
<li>《分布式协议与算法实战》</li>
<li>《Redis 设计与实现》</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Paxos 算法</title>
      <link>https://javaguide.cn/distributed-system/theorem_algorithm_protocol/paxos-algorithm.html</link>
      <guid>https://javaguide.cn/distributed-system/theorem_algorithm_protocol/paxos-algorithm.html</guid>
      <source url="https://javaguide.cn/rss.xml">Paxos 算法</source>
      <description>背景 Paxos 算法是 Leslie Lamport（莱斯利·兰伯特）在 1990 年提出了一种分布式系统 共识 算法。这也是第一个被证明完备的共识算法（前提是不存在拜占庭将军问题，也就是没有恶意节点）。</description>
      <category>分布式</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<h2> 背景</h2>
<p>Paxos 算法是 Leslie Lamport（<a href="https://zh.wikipedia.org/wiki/%E8%8E%B1%E6%96%AF%E5%88%A9%C2%B7%E5%85%B0%E4%BC%AF%E7%89%B9" target="_blank" rel="noopener noreferrer">莱斯利·兰伯特</a>）在 <strong>1990</strong> 年提出了一种分布式系统 <strong>共识</strong> 算法。这也是第一个被证明完备的共识算法（前提是不存在拜占庭将军问题，也就是没有恶意节点）。</p>
<p>为了介绍 Paxos 算法，兰伯特专门写了一篇幽默风趣的论文。在这篇论文中，他虚拟了一个叫做 Paxos 的希腊城邦来更形象化地介绍 Paxos 算法。</p>
<p>不过，审稿人并不认可这篇论文的幽默。于是，他们就给兰伯特说：“如果你想要成功发表这篇论文的话，必须删除所有 Paxos 相关的故事背景”。兰伯特一听就不开心了：“我凭什么修改啊，你们这些审稿人就是缺乏幽默细胞，发不了就不发了呗！”。</p>
<p>于是乎，提出 Paxos 算法的那篇论文在当时并没有被成功发表。</p>
<p>直到 1998 年，系统研究中心 (Systems Research Center，SRC）的两个技术研究员需要找一些合适的分布式算法来服务他们正在构建的分布式系统，Paxos 算法刚好可以解决他们的部分需求。因此，兰伯特就把论文发给了他们。在看了论文之后，这俩大佬觉得论文还是挺不错的。于是，兰伯特在 <strong>1998</strong> 年重新发表论文 <a href="http://lamport.azurewebsites.net/pubs/lamport-paxos.pdf" target="_blank" rel="noopener noreferrer">《The Part-Time Parliament》</a>。</p>
<p>论文发表之后，各路学者直呼看不懂，言语中还略显调侃之意。这谁忍得了，在 <strong>2001</strong> 年的时候，兰伯特专门又写了一篇 <a href="http://lamport.azurewebsites.net/pubs/paxos-simple.pdf" target="_blank" rel="noopener noreferrer">《Paxos Made Simple》</a> 的论文来简化对 Paxos 的介绍，主要讲述两阶段共识协议部分，顺便还不忘嘲讽一下这群学者。</p>
<p>《Paxos Made Simple》这篇论文就 14 页，相比于 《The Part-Time Parliament》的 33 页精简了不少。最关键的是这篇论文的摘要就一句话：</p>
<p></p>
<blockquote>
<p>The Paxos algorithm, when presented in plain English, is very simple.</p>
</blockquote>
<p>翻译过来的意思大概就是：当我用无修饰的英文来描述时，Paxos 算法真心简单！</p>
<p>有没有感觉到来自兰伯特大佬满满地嘲讽的味道？</p>
<h2> 介绍</h2>
<p>Paxos 算法是第一个被证明完备的分布式系统共识算法。共识算法的作用是让分布式系统中的多个节点之间对某个提案（Proposal）达成一致的看法。提案的含义在分布式系统中十分宽泛，像哪一个节点是 Leader 节点、多个事件发生的顺序等等都可以是一个提案。</p>
<p>兰伯特当时提出的 Paxos 算法主要包含 2 个部分:</p>
<ul>
<li><strong>Basic Paxos 算法</strong> ： 描述的是多节点之间如何就某个值(提案 Value)达成共识。</li>
<li><strong>Multi-Paxos 思想</strong> ： 描述的是执行多个 Basic Paxos 实例，就一系列值达成共识。Multi-Paxos 说白了就是执行多次 Basic Paxos ，核心还是 Basic Paxos 。</li>
</ul>
<p>由于 Paxos 算法在国际上被公认的非常难以理解和实现，因此不断有人尝试简化这一算法。到了 2013 年才诞生了一个比 Paxos 算法更易理解和实现的共识算法—<a href="https://javaguide.cn/distributed-system/theorem&amp;algorithm&amp;protocol/raft-algorithm.html" target="_blank" rel="noopener noreferrer">Raft 算法</a> 。更具体点来说，Raft 是 Multi-Paxos 的一个变种，其简化了 Multi-Paxos 的思想，变得更容易被理解以及工程实现。</p>
<p>针对没有恶意节点的情况，除了 Raft 算法之外，当前最常用的一些共识算法比如 <strong>ZAB 协议</strong> 、 <strong>Fast Paxos</strong> 算法都是基于 Paxos 算法改进的。</p>
<p>针对存在恶意节点的情况，一般使用的是 <strong>工作量证明（POW，Proof-of-Work）</strong> 、 <strong>权益证明（PoS，Proof-of-Stake ）</strong> 等共识算法。这类共识算法最典型的应用就是区块链，就比如说前段时间以太坊官方宣布其共识机制正在从工作量证明(PoW)转变为权益证明(PoS)。</p>
<p>区块链系统使用的共识算法需要解决的核心问题是 <strong>拜占庭将军问题</strong> ，这和我们日常接触到的 ZooKeeper、Etcd、Consul 等分布式中间件不太一样。</p>
<p>下面我们来对 Paxos 算法的定义做一个总结：</p>
<ul>
<li>Paxos 算法是兰伯特在 <strong>1990</strong> 年提出了一种分布式系统共识算法。</li>
<li>兰伯特当时提出的 Paxos 算法主要包含 2 个部分: Basic Paxos 算法和 Multi-Paxos 思想。</li>
<li>Raft 算法、ZAB 协议、 Fast Paxos 算法都是基于 Paxos 算法改进而来。</li>
</ul>
<h2> Basic Paxos 算法</h2>
<p>Basic Paxos 中存在 3 个重要的角色：</p>
<ol>
<li><strong>提议者（Proposer）</strong>：也可以叫做协调者（coordinator），提议者负责接受客户端的请求并发起提案。提案信息通常包括提案编号 (Proposal ID) 和提议的值 (Value)。</li>
<li><strong>接受者（Acceptor）</strong>：也可以叫做投票员（voter），负责对提议者的提案进行投票，同时需要记住自己的投票历史；</li>
<li><strong>学习者（Learner）</strong>：如果有超过半数接受者就某个提议达成了共识，那么学习者就需要接受这个提议，并就该提议作出运算，然后将运算结果返回给客户端。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20210603145613753.png" alt=""></p>
<p>为了减少实现该算法所需的节点数，一个节点可以身兼多个角色。并且，一个提案被选定需要被半数以上的 Acceptor 接受。这样的话，Basic Paxos 算法还具备容错性，在少于一半的节点出现故障时，集群仍能正常工作。</p>
<h2> Multi Paxos 思想</h2>
<p>Basic Paxos 算法的仅能就单个值达成共识，为了能够对一系列的值达成共识，我们需要用到 Basic Paxos 思想。</p>
<p>⚠️<strong>注意</strong> ： Multi-Paxos 只是一种思想，这种思想的核心就是通过多个 Basic Paxos 实例就一系列值达成共识。也就是说，Basic Paxos 是 Multi-Paxos 思想的核心，Multi-Paxos 就是多执行几次 Basic Paxos。</p>
<p>由于兰伯特提到的 Multi-Paxos 思想缺少代码实现的必要细节(比如怎么选举领导者)，所以在理解和实现上比较困难。</p>
<p>不过，也不需要担心，我们并不需要自己实现基于  Multi-Paxos 思想的共识算法，业界已经有了比较出名的实现。像 Raft 算法就是 Multi-Paxos 的一个变种，其简化了 Multi-Paxos 的思想，变得更容易被理解以及工程实现，实际项目中可以优先考虑 Raft 算法。</p>
<h2> 参考</h2>
<ul>
<li>https://zh.wikipedia.org/wiki/Paxos</li>
<li>分布式系统中的一致性与共识算法：http://www.xuyasong.com/?p=1970</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Raft 算法</title>
      <link>https://javaguide.cn/distributed-system/theorem_algorithm_protocol/raft-algorithm.html</link>
      <guid>https://javaguide.cn/distributed-system/theorem_algorithm_protocol/raft-algorithm.html</guid>
      <source url="https://javaguide.cn/rss.xml">Raft 算法</source>
      <description>本文由 SnailClimb 和 Xieqijun 共同完成。 1 背景 当今的数据中心和应用程序在高度动态的环境中运行，为了应对高度动态的环境，它们通过额外的服务器进行横向扩展，并且根据需求进行扩展和收缩。同时，服务器和网络故障也很常见。</description>
      <category>分布式</category>
      <pubDate>Thu, 23 Feb 2023 10:39:58 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>本文由 <a href="https://github.com/Snailclimb" target="_blank" rel="noopener noreferrer">SnailClimb</a> 和 <a href="https://github.com/jun0315" target="_blank" rel="noopener noreferrer">Xieqijun</a> 共同完成。</p>
</blockquote>
<h2> 1 背景</h2>
<p>当今的数据中心和应用程序在高度动态的环境中运行，为了应对高度动态的环境，它们通过额外的服务器进行横向扩展，并且根据需求进行扩展和收缩。同时，服务器和网络故障也很常见。</p>
<p>因此，系统必须在正常操作期间处理服务器的上下线。它们必须对变故做出反应并在几秒钟内自动适应；对客户来说的话，明显的中断通常是不可接受的。</p>
<p>幸运的是，分布式共识可以帮助应对这些挑战。</p>
<h3> 1.1 拜占庭将军</h3>
<p>在介绍共识算法之前，先介绍一个简化版拜占庭将军的例子来帮助理解共识算法。</p>
<blockquote>
<p>假设多位拜占庭将军中没有叛军，信使的信息可靠但有可能被暗杀的情况下，将军们如何达成是否要进攻的一致性决定？</p>
</blockquote>
<p>解决方案大致可以理解成：先在所有的将军中选出一个大将军，用来做出所有的决定。</p>
<p>举例如下：假如现在一共有 3 个将军 A，B 和 C，每个将军都有一个随机时间的倒计时器，倒计时一结束，这个将军就把自己当成大将军候选人，然后派信使传递选举投票的信息给将军 B 和 C，如果将军 B 和 C 还没有把自己当作候选人（自己的倒计时还没有结束），并且没有把选举票投给其他人，它们就会把票投给将军 A，信使回到将军 A 时，将军 A 知道自己收到了足够的票数，成为大将军。在有了大将军之后，是否需要进攻就由大将军 A 决定，然后再去派信使通知另外两个将军，自己已经成为了大将军。如果一段时间还没收到将军 B 和 C 的回复（信使可能会被暗杀），那就再重派一个信使，直到收到回复。</p>
<h3> 1.2 共识算法</h3>
<p>共识是可容错系统中的一个基本问题：即使面对故障，服务器也可以在共享状态上达成一致。</p>
<p>共识算法允许一组节点像一个整体一样一起工作，即使其中的一些节点出现故障也能够继续工作下去，其正确性主要是源于复制状态机的性质：一组<code>Server</code>的状态机计算相同状态的副本，即使有一部分的<code>Server</code>宕机了它们仍然能够继续运行。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/paxos-rsm-architecture.png" alt="rsm-architecture.png"></p>
<p><code>图-1 复制状态机架构</code></p>
<p>一般通过使用复制日志来实现复制状态机。每个<code>Server</code>存储着一份包括命令序列的日志文件，状态机会按顺序执行这些命令。因为每个日志包含相同的命令，并且顺序也相同，所以每个状态机处理相同的命令序列。由于状态机是确定性的，所以处理相同的状态，得到相同的输出。</p>
<p>因此共识算法的工作就是保持复制日志的一致性。服务器上的共识模块从客户端接收命令并将它们添加到日志中。它与其他服务器上的共识模块通信，以确保即使某些服务器发生故障。每个日志最终包含相同顺序的请求。一旦命令被正确地复制，它们就被称为已提交。每个服务器的状态机按照日志顺序处理已提交的命令，并将输出返回给客户端，因此，这些服务器形成了一个单一的、高度可靠的状态机。</p>
<p>适用于实际系统的共识算法通常具有以下特性：</p>
<ul>
<li>
<p>安全。确保在非拜占庭条件（也就是上文中提到的简易版拜占庭）下的安全性，包括网络延迟、分区、包丢失、复制和重新排序。</p>
</li>
<li>
<p>高可用。只要大多数服务器都是可操作的，并且可以相互通信，也可以与客户端进行通信，那么这些服务器就可以看作完全功能可用的。因此，一个典型的由五台服务器组成的集群可以容忍任何两台服务器端故障。假设服务器因停止而发生故障；它们稍后可能会从稳定存储上的状态中恢复并重新加入集群。</p>
</li>
<li>
<p>一致性不依赖时序。错误的时钟和极端的消息延迟，在最坏的情况下也只会造成可用性问题，而不会产生一致性问题。</p>
</li>
<li>
<p>在集群中大多数服务器响应，命令就可以完成，不会被少数运行缓慢的服务器来影响整体系统性能。</p>
</li>
</ul>
<h2> 2 基础</h2>
<h3> 2.1 节点类型</h3>
<p>一个 Raft 集群包括若干服务器，以典型的 5 服务器集群举例。在任意的时间，每个服务器一定会处于以下三个状态中的一个：</p>
<ul>
<li><code>Leader</code>：负责发起心跳，响应客户端，创建日志，同步日志。</li>
<li><code>Candidate</code>：Leader 选举过程中的临时角色，由 Follower 转化而来，发起投票参与竞选。</li>
<li><code>Follower</code>：接受 Leader 的心跳和日志同步数据，投票给 Candidate。</li>
</ul>
<p>在正常的情况下，只有一个服务器是 Leader，剩下的服务器是 Follower。Follower 是被动的，它们不会发送任何请求，只是响应来自 Leader 和 Candidate 的请求。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/paxos-server-state.png" alt=""></p>
<p><code>图-2：服务器的状态</code></p>
<h3> 2.2 任期</h3>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/paxos-term.png" alt=""></p>
<p><code>图-3：任期</code></p>
<p>如图 3 所示，raft 算法将时间划分为任意长度的任期（term），任期用连续的数字表示，看作当前 term 号。每一个任期的开始都是一次选举，在选举开始时，一个或多个 Candidate 会尝试成为 Leader。如果一个 Candidate 赢得了选举，它就会在该任期内担任 Leader。如果没有选出 Leader，将会开启另一个任期，并立刻开始下一次选举。raft 算法保证在给定的一个任期最少要有一个 Leader。</p>
<p>每个节点都会存储当前的 term 号，当服务器之间进行通信时会交换当前的 term 号；如果有服务器发现自己的 term 号比其他人小，那么他会更新到较大的 term 值。如果一个 Candidate 或者 Leader 发现自己的 term 过期了，他会立即退回成 Follower。如果一台服务器收到的请求的 term 号是过期的，那么它会拒绝此次请求。</p>
<h3> 2.3 日志</h3>
<ul>
<li><code>entry</code>：每一个事件成为 entry，只有 Leader 可以创建 entry。entry 的内容为<code>&lt;term,index,cmd&gt;</code>其中 cmd 是可以应用到状态机的操作。</li>
<li><code>log</code>：由 entry 构成的数组，每一个 entry 都有一个表明自己在 log 中的 index。只有 Leader 才可以改变其他节点的 log。entry 总是先被 Leader 添加到自己的 log 数组中，然后再发起共识请求，获得同意后才会被 Leader 提交给状态机。Follower 只能从 Leader 获取新日志和当前的 commitIndex，然后把对应的 entry 应用到自己的状态机中。</li>
</ul>
<h2> 3 领导人选举</h2>
<p>raft 使用心跳机制来触发 Leader 的选举。</p>
<p>如果一台服务器能够收到来自 Leader 或者 Candidate 的有效信息，那么它会一直保持为 Follower 状态，并且刷新自己的 electionElapsed，重新计时。</p>
<p>Leader 会向所有的 Follower 周期性发送心跳来保证自己的 Leader 地位。如果一个 Follower 在一个周期内没有收到心跳信息，就叫做选举超时，然后它就会认为此时没有可用的 Leader，并且开始进行一次选举以选出一个新的 Leader。</p>
<p>为了开始新的选举，Follower 会自增自己的 term 号并且转换状态为 Candidate。然后他会向所有节点发起 RequestVoteRPC 请求， Candidate 的状态会持续到以下情况发生：</p>
<ul>
<li>赢得选举</li>
<li>其他节点赢得选举</li>
<li>一轮选举结束，无人胜出</li>
</ul>
<p>赢得选举的条件是：一个 Candidate 在一个任期内收到了来自集群内的多数选票<code>（N/2+1）</code>，就可以成为 Leader。</p>
<p>在 Candidate 等待选票的时候，它可能收到其他节点声明自己是 Leader 的心跳，此时有两种情况：</p>
<ul>
<li>该 Leader 的 term 号大于等于自己的 term 号，说明对方已经成为 Leader，则自己回退为 Follower。</li>
<li>该 Leader 的 term 号小于自己的 term 号，那么会拒绝该请求并让该节点更新 term。</li>
</ul>
<p>由于可能同一时刻出现多个 Candidate，导致没有 Candidate 获得大多数选票，如果没有其他手段来重新分配选票的话，那么可能会无限重复下去。</p>
<p>raft 使用了随机的选举超时时间来避免上述情况。每一个 Candidate 在发起选举后，都会随机化一个新的枚举超时时间，这种机制使得各个服务器能够分散开来，在大多数情况下只有一个服务器会率先超时；它会在其他服务器超时之前赢得选举。</p>
<h2> 4 日志复制</h2>
<p>一旦选出了 Leader，它就开始接受客户端的请求。每一个客户端的请求都包含一条需要被复制状态机（<code>Replicated State Mechine</code>）执行的命令。</p>
<p>Leader 收到客户端请求后，会生成一个 entry，包含<code>&lt;index,term,cmd&gt;</code>，再将这个 entry 添加到自己的日志末尾后，向所有的节点广播该 entry，要求其他服务器复制这条 entry。</p>
<p>如果 Follower 接受该 entry，则会将 entry 添加到自己的日志后面，同时返回给 Leader 同意。</p>
<p>如果 Leader 收到了多数的成功响应，Leader 会将这个 entry 应用到自己的状态机中，之后可以成为这个 entry 是 committed 的，并且向客户端返回执行结果。</p>
<p>raft 保证以下两个性质：</p>
<ul>
<li>在两个日志里，有两个 entry 拥有相同的 index 和 term，那么它们一定有相同的 cmd</li>
<li>在两个日志里，有两个 entry 拥有相同的 index 和 term，那么它们前面的 entry 也一定相同</li>
</ul>
<p>通过“仅有 Leader 可以生存 entry”来保证第一个性质，第二个性质需要一致性检查来进行保证。</p>
<p>一般情况下，Leader 和 Follower 的日志保持一致，然后，Leader 的崩溃会导致日志不一样，这样一致性检查会产生失败。Leader 通过强制 Follower 复制自己的日志来处理日志的不一致。这就意味着，在 Follower 上的冲突日志会被领导者的日志覆盖。</p>
<p>为了使得 Follower 的日志和自己的日志一致，Leader 需要找到 Follower 与它日志一致的地方，然后删除 Follower 在该位置之后的日志，接着把这之后的日志发送给 Follower。</p>
<p><code>Leader</code> 给每一个<code>Follower</code> 维护了一个 <code>nextIndex</code>，它表示 <code>Leader</code> 将要发送给该追随者的下一条日志条目的索引。当一个 <code>Leader</code> 开始掌权时，它会将 <code>nextIndex</code> 初始化为它的最新的日志条目索引数+1。如果一个 <code>Follower</code> 的日志和 <code>Leader</code> 的不一致，<code>AppendEntries</code> 一致性检查会在下一次 <code>AppendEntries RPC</code> 时返回失败。在失败之后，<code>Leader</code> 会将 <code>nextIndex</code> 递减然后重试 <code>AppendEntries RPC</code>。最终 <code>nextIndex</code> 会达到一个 <code>Leader</code> 和 <code>Follower</code> 日志一致的地方。这时，<code>AppendEntries</code> 会返回成功，<code>Follower</code> 中冲突的日志条目都被移除了，并且添加所缺少的上了 <code>Leader</code> 的日志条目。一旦 <code>AppendEntries</code> 返回成功，<code>Follower</code> 和 <code>Leader</code> 的日志就一致了，这样的状态会保持到该任期结束。</p>
<h2> 5 安全性</h2>
<h3> 5.1 选举限制</h3>
<p>Leader 需要保证自己存储全部已经提交的日志条目。这样才可以使日志条目只有一个流向：从 Leader 流向 Follower，Leader 永远不会覆盖已经存在的日志条目。</p>
<p>每个 Candidate 发送 RequestVoteRPC 时，都会带上最后一个 entry 的信息。所有节点收到投票信息时，会对该 entry 进行比较，如果发现自己的更新，则拒绝投票给该 Candidate。</p>
<p>判断日志新旧的方式：如果两个日志的 term 不同，term 大的更新；如果 term 相同，更长的 index 更新。</p>
<h3> 5.2 节点崩溃</h3>
<p>如果 Leader 崩溃，集群中的节点在 electionTimeout 时间内没有收到 Leader 的心跳信息就会触发新一轮的选主，在选主期间整个集群对外是不可用的。</p>
<p>如果 Follower 和 Candidate 崩溃，处理方式会简单很多。之后发送给它的 RequestVoteRPC 和 AppendEntriesRPC 会失败。由于 raft 的所有请求都是幂等的，所以失败的话会无限的重试。如果崩溃恢复后，就可以收到新的请求，然后选择追加或者拒绝 entry。</p>
<h3> 5.3 时间与可用性</h3>
<p>raft 的要求之一就是安全性不依赖于时间：系统不能仅仅因为一些事件发生的比预想的快一些或者慢一些就产生错误。为了保证上述要求，最好能满足以下的时间条件：</p>
<p><code>broadcastTime &lt;&lt; electionTimeout &lt;&lt; MTBF</code></p>
<ul>
<li><code>broadcastTime</code>：向其他节点并发发送消息的平均响应时间；</li>
<li><code>electionTimeout</code>：选举超时时间；</li>
<li><code>MTBF(mean time between failures)</code>：单台机器的平均健康时间；</li>
</ul>
<p><code>broadcastTime</code>应该比<code>electionTimeout</code>小一个数量级，为的是使<code>Leader</code>能够持续发送心跳信息（heartbeat）来阻止<code>Follower</code>开始选举；</p>
<p><code>electionTimeout</code>也要比<code>MTBF</code>小几个数量级，为的是使得系统稳定运行。当<code>Leader</code>崩溃时，大约会在整个<code>electionTimeout</code>的时间内不可用；我们希望这种情况仅占全部时间的很小一部分。</p>
<p>由于<code>broadcastTime</code>和<code>MTBF</code>是由系统决定的属性，因此需要决定<code>electionTimeout</code>的时间。</p>
<p>一般来说，broadcastTime 一般为 <code>0.5～20ms</code>，electionTimeout 可以设置为 <code>10～500ms</code>，MTBF 一般为一两个月。</p>
<h2> 6 参考</h2>
<ul>
<li>https://tanxinyu.work/raft/</li>
<li>https://github.com/OneSizeFitsQuorum/raft-thesis-zh_cn/blob/master/raft-thesis-zh_cn.md</li>
<li>https://github.com/ongardie/dissertation/blob/master/stanford.pdf</li>
<li>https://knowledge-sharing.gitbooks.io/raft/content/chapter5.html</li>
</ul>
]]></content:encoded>
      <enclosure url="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/paxos-rsm-architecture.png" type="image/png"/>
    </item>
  </channel>
</rss>